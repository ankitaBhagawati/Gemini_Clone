"use client";
import {
  require_react_dom
} from "./chunk-E7Q22A2S.js";
import {
  require_react
} from "./chunk-6P6Q65E3.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/devextreme-react/esm/tooltip.js
var React8 = __toESM(require_react());
var import_react10 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/devextreme/esm/__internal/core/utils/m_callbacks.js
var Callback = function(options2) {
  this._options = options2 || {};
  this._list = [];
  this._queue = [];
  this._firing = false;
  this._fired = false;
  this._firingIndexes = [];
};
Callback.prototype._fireCore = function(context2, args) {
  const firingIndexes = this._firingIndexes;
  const list = this._list;
  const {
    stopOnFalse
  } = this._options;
  const step = firingIndexes.length;
  for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
    const result2 = list[firingIndexes[step]].apply(context2, args);
    if (false === result2 && stopOnFalse) {
      break;
    }
  }
  firingIndexes.pop();
};
Callback.prototype.add = function(fn) {
  if ("function" === typeof fn && (!this._options.unique || !this.has(fn))) {
    this._list.push(fn);
  }
  return this;
};
Callback.prototype.remove = function(fn) {
  const list = this._list;
  const firingIndexes = this._firingIndexes;
  const index2 = list.indexOf(fn);
  if (index2 > -1) {
    list.splice(index2, 1);
    if (this._firing && firingIndexes.length) {
      for (let step = 0; step < firingIndexes.length; step++) {
        if (index2 <= firingIndexes[step]) {
          firingIndexes[step]--;
        }
      }
    }
  }
  return this;
};
Callback.prototype.has = function(fn) {
  const list = this._list;
  return fn ? list.indexOf(fn) > -1 : !!list.length;
};
Callback.prototype.empty = function(fn) {
  this._list = [];
  return this;
};
Callback.prototype.fireWith = function(context2, args) {
  const queue = this._queue;
  args = args || [];
  args = args.slice ? args.slice() : args;
  if (this._options.syncStrategy) {
    this._firing = true;
    this._fireCore(context2, args);
  } else {
    queue.push([context2, args]);
    if (this._firing) {
      return;
    }
    this._firing = true;
    while (queue.length) {
      const memory = queue.shift();
      this._fireCore(memory[0], memory[1]);
    }
  }
  this._firing = false;
  this._fired = true;
  return this;
};
Callback.prototype.fire = function() {
  this.fireWith(this, arguments);
};
Callback.prototype.fired = function() {
  return this._fired;
};
var Callbacks = function(options2) {
  return new Callback(options2);
};
var m_callbacks_default = Callbacks;

// node_modules/devextreme/esm/core/utils/callbacks.js
var callbacks_default = Callbacks;

// node_modules/devextreme/esm/__internal/core/utils/m_iterator.js
var map = (values, callback) => {
  if (Array.isArray(values)) {
    return values.map(callback);
  }
  const result2 = [];
  for (const key in values) {
    result2.push(callback(values[key], key));
  }
  return result2;
};
var each = (values, callback) => {
  if (!values) {
    return;
  }
  if ("length" in values) {
    for (let i = 0; i < values.length; i++) {
      if (false === callback.call(values[i], i, values[i])) {
        break;
      }
    }
  } else {
    for (const key in values) {
      if (false === callback.call(values[key], key, values[key])) {
        break;
      }
    }
  }
  return values;
};

// node_modules/devextreme/esm/__internal/core/m_memorized_callbacks.js
var MemorizedCallbacks = class {
  constructor() {
    this.memory = [];
    this.callbacks = callbacks_default();
  }
  add(fn) {
    each(this.memory, (_, item) => fn.apply(fn, item));
    this.callbacks.add(fn);
  }
  remove(fn) {
    this.callbacks.remove(fn);
  }
  fire() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.memory.push(args);
    this.callbacks.fire.apply(this.callbacks, args);
  }
};

// node_modules/devextreme/esm/core/memorized_callbacks.js
var memorized_callbacks_default = MemorizedCallbacks;

// node_modules/devextreme/esm/__internal/core/m_component_registrator_callbacks.js
var componentRegistratorCallbacks = new memorized_callbacks_default();

// node_modules/devextreme/esm/core/component_registrator_callbacks.js
var component_registrator_callbacks_default = componentRegistratorCallbacks;

// node_modules/devextreme/esm/__internal/core/utils/m_type.js
var types = {
  "[object Array]": "array",
  "[object Date]": "date",
  "[object Object]": "object",
  "[object String]": "string"
};
var type = function(object) {
  if (null === object) {
    return "null";
  }
  const typeOfObject = Object.prototype.toString.call(object);
  return "object" === typeof object ? types[typeOfObject] || "object" : typeof object;
};
var isBoolean = function(object) {
  return "boolean" === typeof object;
};
var isExponential = function(value2) {
  return isNumeric(value2) && -1 !== value2.toString().indexOf("e");
};
var isDate = function(object) {
  return "date" === type(object);
};
var isDefined = function(object) {
  return null !== object && void 0 !== object;
};
var isFunction = function(object) {
  return "function" === typeof object;
};
var isString = function(object) {
  return "string" === typeof object;
};
var isNumeric = function(object) {
  return "number" === typeof object && isFinite(object) || !isNaN(object - parseFloat(object));
};
var isObject = function(object) {
  return "object" === type(object);
};
var isEmptyObject = function(object) {
  let property;
  for (property in object) {
    return false;
  }
  return true;
};
var isPlainObject = function(object) {
  if (!object || "object" !== type(object)) {
    return false;
  }
  const proto = Object.getPrototypeOf(object);
  if (!proto) {
    return true;
  }
  const ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return "function" === typeof ctor && Object.toString.call(ctor) === Object.toString.call(Object);
};
var isPrimitive = function(value2) {
  return !["object", "array", "function"].includes(type(value2));
};
var isWindow = function(object) {
  return null != object && object === object.window;
};
var isRenderer = function(object) {
  return !!object && !!(object.jquery || object.dxRenderer);
};
var isPromise = function(object) {
  return !!object && isFunction(object.then);
};
var isDeferred = function(object) {
  return !!object && isFunction(object.done) && isFunction(object.fail);
};
var isEvent = function(object) {
  return !!(object && object.preventDefault);
};
var m_type_default = {
  isBoolean,
  isDate,
  isDeferred,
  isDefined,
  isEmptyObject,
  isEvent,
  isExponential,
  isFunction,
  isNumeric,
  isObject,
  isPlainObject,
  isPrimitive,
  isPromise,
  isRenderer,
  isString,
  isWindow,
  type
};

// node_modules/devextreme/esm/__internal/core/utils/m_extend.js
var extendFromObject = function(target, source, overrideExistingValues) {
  target = target || {};
  for (const prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      const value2 = source[prop];
      if (!(prop in target) || overrideExistingValues) {
        target[prop] = value2;
      }
    }
  }
  return target;
};
var extend = function(target) {
  target = target || {};
  let i = 1;
  let deep = false;
  if ("boolean" === typeof target) {
    deep = target;
    target = arguments[1] || {};
    i++;
  }
  for (; i < arguments.length; i++) {
    const source = arguments[i];
    if (null == source) {
      continue;
    }
    for (const key in source) {
      const targetValue = target[key];
      const sourceValue = source[key];
      let sourceValueIsArray = false;
      let clone2;
      if ("__proto__" === key || "constructor" === key || target === sourceValue) {
        continue;
      }
      if (deep && sourceValue && (isPlainObject(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
        if (sourceValueIsArray) {
          clone2 = targetValue && Array.isArray(targetValue) ? targetValue : [];
        } else {
          clone2 = targetValue && isPlainObject(targetValue) ? targetValue : {};
        }
        target[key] = extend(deep, clone2, sourceValue);
      } else if (void 0 !== sourceValue) {
        target[key] = sourceValue;
      }
    }
  }
  return target;
};

// node_modules/devextreme/esm/__internal/core/utils/m_string.js
var encodeHtml = function() {
  const encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
  return function(str) {
    return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;");
  };
}();
function format(template) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if (isFunction(template)) {
    return template(...values);
  }
  values.forEach((value2, index2) => {
    if (isString(value2)) {
      value2 = value2.replace(/\$/g, "$$$$");
    }
    const placeholderReg = new RegExp(`\\{${index2}\\}`, "gm");
    template = template.replace(placeholderReg, value2);
  });
  return template;
}

// node_modules/devextreme/esm/core/version.js
var version = "25.1.3";
var fullVersion = "25.1.3";

// node_modules/devextreme/esm/__internal/core/utils/m_console.js
var noop = function() {
};
var getConsoleMethod = function(method) {
  if ("undefined" === typeof console || !isFunction(console[method])) {
    return noop;
  }
  return console[method].bind(console);
};
var logger = {
  log: getConsoleMethod("log"),
  info: getConsoleMethod("info"),
  warn: getConsoleMethod("warn"),
  error: getConsoleMethod("error")
};
var debug = /* @__PURE__ */ function() {
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  return {
    assert,
    assertParam: function(parameter, message) {
      assert(null !== parameter && void 0 !== parameter, message);
    }
  };
}();
var m_console_default = {
  logger,
  debug
};

// node_modules/devextreme/esm/__internal/core/utils/m_error.js
var ERROR_URL = `https://js.devexpress.com/error/${version.split(".").slice(0, 2).join("_")}/`;
function error(baseErrors, errors2) {
  const exports = {
    ERROR_MESSAGES: extend(errors2, baseErrors),
    Error: function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return function(args2) {
        const id = args2[0];
        args2 = args2.slice(1);
        const details = formatDetails(id, args2);
        const url = getErrorUrl(id);
        const message = formatMessage(id, details);
        return extend(new Error(message), {
          __id: id,
          __details: details,
          url
        });
      }(args);
    },
    log() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      const id = args[0];
      let method = "log";
      if (/^E\d+$/.test(id)) {
        method = "error";
      } else if (/^W\d+$/.test(id)) {
        method = "warn";
      }
      m_console_default.logger[method]("log" === method ? id : function(args2) {
        const id2 = args2[0];
        args2 = args2.slice(1);
        return formatMessage(id2, formatDetails(id2, args2));
      }(args));
    }
  };
  function formatDetails(id, args) {
    args = [exports.ERROR_MESSAGES[id]].concat(args);
    return format.apply(this, args).replace(/\.*\s*?$/, "");
  }
  function formatMessage(id, details) {
    const kind = null !== id && void 0 !== id && id.startsWith("W") ? "warning" : "error";
    return format.apply(this, ["{0} - {1}.\n\nFor additional information on this {2} message, see: {3}", id, details, kind, getErrorUrl(id)]);
  }
  function getErrorUrl(id) {
    return ERROR_URL + id;
  }
  return exports;
}

// node_modules/devextreme/esm/core/utils/error.js
var error_default = error;

// node_modules/devextreme/esm/__internal/core/m_errors.js
var m_errors_default = error_default({
  E0001: "Method is not implemented",
  E0002: "Member name collision: {0}",
  E0003: "A class must be instantiated using the 'new' keyword",
  E0004: "The NAME property of the component is not specified",
  E0005: "Unknown device",
  E0006: "Unknown endpoint key is requested",
  E0007: "'Invalidate' method is called outside the update transaction",
  E0008: "Type of the option name is not appropriate to create an action",
  E0009: "Component '{0}' has not been initialized for an element",
  E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
  E0011: "Unknown animation type '{0}'",
  E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
  E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
  E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
  E0015: "Queued task returned an unexpected result",
  E0017: "Event namespace is not defined",
  E0018: "DevExpress.ui.DevExpressPopup widget is required",
  E0020: "Template engine '{0}' is not supported",
  E0021: "Unknown theme is set: {0}",
  E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
  E0023: "Template name is not specified",
  E0024: "DevExtreme bundle already included",
  E0025: "Unexpected argument type",
  E0100: "Unknown validation type is detected",
  E0101: "Misconfigured range validation rule is detected",
  E0102: "Misconfigured comparison validation rule is detected",
  E0103: "validationCallback of an asynchronous rule should return a jQuery or a native promise",
  E0110: "Unknown validation group is detected",
  E0120: "Adapter for a DevExpressValidator component cannot be configured",
  E0121: "The 'customItem' parameter of the 'onCustomItemCreating' function is empty or contains invalid data. Assign a custom object or a Promise that is resolved after the item is created.",
  E0122: "AIIntegration: The sendRequest method is missing.",
  W0000: "'{0}' is deprecated in {1}. {2}",
  W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
  W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
  W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
  W0004: "Timeout for theme loading is over: {0}",
  W0005: "'{0}' event is deprecated in {1}. {2}",
  W0006: "Invalid recurrence rule: '{0}'",
  W0007: "'{0}' Globalize culture is not defined",
  W0008: "Invalid view name: '{0}'",
  W0009: "Invalid time zone name: '{0}'",
  W0010: "{0} is deprecated in {1}. {2}",
  W0011: "Number parsing is invoked while the parser is not defined",
  W0012: "Date parsing is invoked while the parser is not defined",
  W0013: "'{0}' file is deprecated in {1}. {2}",
  W0014: "{0} - '{1}' type is deprecated in {2}. {3}",
  W0015: "Instead of returning a value from the '{0}' function, write it into the '{1}' field of the function's parameter.",
  W0016: 'The "{0}" option does not accept the "{1}" value since v{2}. {3}.',
  W0017: 'Setting the "{0}" property with a function is deprecated since v21.2',
  W0018: 'Setting the "position" property with a function is deprecated since v21.2',
  W0019: "DevExtreme: Unable to Locate a Valid License Key.\n\nDetailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.\n\nIf you are using a 30-day trial version of DevExtreme, you must uninstall all copies of DevExtreme once your 30-day trial period expires. For terms and conditions that govern use of DevExtreme UI components/libraries, please refer to the DevExtreme End User License Agreement: https://js.devexpress.com/EULAs/DevExtremeComplete.\n\nTo use DevExtreme in a commercial project, you must purchase a license. For pricing/licensing options, please visit: https://js.devexpress.com/Buy.\n\nIf you have licensing-related questions or need help with a purchase, please email clientservices@devexpress.com.\n\n",
  W0020: "DevExtreme: License Key Has Expired.\n\nDetailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.\n\nA mismatch exists between the license key used and the DevExtreme version referenced in this project.\n\nTo proceed, you can:\n• use a version of DevExtreme linked to your license key: https://www.devexpress.com/ClientCenter/DownloadManager\n• renew your DevExpress Subscription: https://www.devexpress.com/buy/renew (once you renew your subscription, you will be entitled to product updates and support service as defined in the DevExtreme End User License Agreement)\n\nIf you have licensing-related questions or need help with a renewal, please email clientservices@devexpress.com.\n\n",
  W0021: "DevExtreme: License Key Verification Has Failed.\n\nDetailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.\n\nTo verify your DevExtreme license, make certain to specify a correct key in the GlobalConfig. If you continue to encounter this error, please visit https://www.devexpress.com/ClientCenter/DownloadManager to obtain a valid license key.\n\nIf you have a valid license and this problem persists, please submit a support ticket via the DevExpress Support Center. We will be happy to follow-up: https://supportcenter.devexpress.com/ticket/create.\n\n",
  W0022: "DevExtreme: Pre-release software. Not suitable for commercial use.\n\nDetailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.\n\nPre-release software may contain deficiencies and as such, should not be considered for use or integrated in any mission critical application.\n\n",
  W0023: "DevExtreme: the following 'devextreme' package version does not match versions of other DevExpress products used in this application:\n\n{0}\n\nInteroperability between different versions of the products listed herein cannot be guaranteed.\n\n"
});

// node_modules/devextreme/esm/core/errors.js
var errors_default = m_errors_default;

// node_modules/devextreme/esm/__internal/core/m_config.js
var config = {
  rtlEnabled: false,
  defaultCurrency: "USD",
  defaultUseCurrencyAccountingStyle: true,
  oDataFilterToLower: true,
  serverDecimalSeparator: ".",
  decimalSeparator: ".",
  thousandsSeparator: ",",
  forceIsoDateParsing: true,
  wrapActionsBeforeExecute: true,
  useLegacyStoreResult: false,
  useJQuery: void 0,
  editorStylingMode: void 0,
  useLegacyVisibleIndex: false,
  floatingActionButtonConfig: {
    icon: "add",
    closeIcon: "close",
    label: "",
    position: {
      at: "right bottom",
      my: "right bottom",
      offset: {
        x: -16,
        y: -16
      }
    },
    maxSpeedDialActionCount: 5,
    shading: false,
    direction: "auto"
  },
  optionsParser: (optionsString) => {
    if ("{" !== optionsString.trim().charAt(0)) {
      optionsString = `{${optionsString}}`;
    }
    try {
      return JSON.parse(optionsString);
    } catch (ex) {
      try {
        return JSON.parse(normalizeToJSONString(optionsString));
      } catch (exNormalize) {
        throw errors_default.Error("E3018", ex, optionsString);
      }
    }
  }
};
var normalizeToJSONString = (optionsString) => optionsString.replace(/'/g, '"').replace(/,\s*([\]}])/g, "$1").replace(/([{,])\s*([^":\s]+)\s*:/g, '$1"$2":');
var deprecatedFields = ["decimalSeparator", "thousandsSeparator"];
var configMethod = function() {
  if (!arguments.length) {
    return config;
  }
  const newConfig = arguments.length <= 0 ? void 0 : arguments[0];
  deprecatedFields.forEach((deprecatedField) => {
    if (newConfig[deprecatedField]) {
      const message = `Now, the ${deprecatedField} is selected based on the specified locale.`;
      errors_default.log("W0003", "config", deprecatedField, "19.2", message);
    }
  });
  extend(config, newConfig);
};
if ("undefined" !== typeof DevExpress && DevExpress.config) {
  configMethod(DevExpress.config);
}
var m_config_default = configMethod;

// node_modules/devextreme/esm/common/config.js
var config_default = m_config_default;

// node_modules/devextreme/esm/__internal/core/m_class.js
var wrapOverridden = function(baseProto, methodName, method) {
  return function() {
    const prevCallBase = this.callBase;
    this.callBase = baseProto[methodName];
    try {
      return method.apply(this, arguments);
    } finally {
      this.callBase = prevCallBase;
    }
  };
};
var clonePrototype = function(obj) {
  const func = function() {
  };
  func.prototype = obj.prototype;
  return new func();
};
var redefine = function(members) {
  const that = this;
  let overridden;
  let memberName;
  let member;
  if (!members) {
    return that;
  }
  for (memberName in members) {
    member = members[memberName];
    overridden = "function" === typeof that.prototype[memberName] && "function" === typeof member;
    that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member;
  }
  return that;
};
var include = function() {
  const classObj = this;
  let argument;
  let name2;
  let i;
  const hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
  const isES6Class = !hasClassObjOwnProperty("_includedCtors") && !hasClassObjOwnProperty("_includedPostCtors");
  if (isES6Class) {
    classObj._includedCtors = classObj._includedCtors.slice(0);
    classObj._includedPostCtors = classObj._includedPostCtors.slice(0);
  }
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  for (i = 0; i < args.length; i++) {
    argument = args[i];
    if (argument.ctor) {
      classObj._includedCtors.push(argument.ctor);
    }
    if (argument.postCtor) {
      classObj._includedPostCtors.push(argument.postCtor);
    }
    for (name2 in argument) {
      if ("ctor" === name2 || "postCtor" === name2 || "default" === name2) {
        continue;
      }
      classObj.prototype[name2] = argument[name2];
    }
  }
  return classObj;
};
var subclassOf = function(parentClass) {
  const hasParentProperty = Object.prototype.hasOwnProperty.bind(this)("parent");
  const isES6Class = !hasParentProperty && this.parent;
  if (isES6Class) {
    const baseClass = Object.getPrototypeOf(this);
    return baseClass === parentClass || baseClass.subclassOf(parentClass);
  }
  if (this.parent === parentClass) {
    return true;
  }
  if (!this.parent || !this.parent.subclassOf) {
    return false;
  }
  return this.parent.subclassOf(parentClass);
};
var abstract = function() {
  throw errors_default.Error("E0001");
};
var classImpl = function() {
};
classImpl.inherit = function(members) {
  const inheritor = function() {
    if (!this || isWindow(this) || "function" !== typeof this.constructor) {
      throw errors_default.Error("E0003");
    }
    const instance = this;
    const {
      ctor
    } = instance;
    const includedCtors = instance.constructor._includedCtors;
    const includedPostCtors = instance.constructor._includedPostCtors;
    let i;
    for (i = 0; i < includedCtors.length; i++) {
      includedCtors[i].call(instance);
    }
    if (ctor) {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      ctor.apply(instance, args);
    }
    for (i = 0; i < includedPostCtors.length; i++) {
      includedPostCtors[i].call(instance);
    }
  };
  inheritor.prototype = clonePrototype(this);
  Object.setPrototypeOf(inheritor, this);
  inheritor.inherit = this.inherit;
  inheritor.abstract = abstract;
  inheritor.redefine = redefine;
  inheritor.include = include;
  inheritor.subclassOf = subclassOf;
  inheritor.parent = this;
  inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
  inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
  inheritor.prototype.constructor = inheritor;
  inheritor.redefine(members);
  return inheritor;
};
classImpl.abstract = abstract;
var m_class_default = classImpl;

// node_modules/devextreme/esm/core/class.js
var class_default = m_class_default;

// node_modules/devextreme/esm/__internal/core/m_guid.js
var Guid = class_default.inherit({
  ctor: function(value2) {
    if (value2) {
      value2 = String(value2);
    }
    this._value = this._normalize(value2 || this._generate());
  },
  _normalize: function(value2) {
    value2 = value2.replace(/[^a-f0-9]/gi, "").toLowerCase();
    while (value2.length < 32) {
      value2 += "0";
    }
    return [value2.substr(0, 8), value2.substr(8, 4), value2.substr(12, 4), value2.substr(16, 4), value2.substr(20, 12)].join("-");
  },
  _generate: function() {
    let value2 = "";
    for (let i = 0; i < 32; i++) {
      value2 += Math.round(15 * Math.random()).toString(16);
    }
    return value2;
  },
  toString: function() {
    return this._value;
  },
  valueOf: function() {
    return this._value;
  },
  toJSON: function() {
    return this._value;
  }
});

// node_modules/devextreme/esm/common/guid.js
var guid_default = Guid;

// node_modules/devextreme/esm/__internal/core/templates/m_template_engine_registry.js
var templateEngines = {};
var currentTemplateEngine;
function registerTemplateEngine(name2, templateEngine) {
  templateEngines[name2] = templateEngine;
}
function setTemplateEngine(templateEngine) {
  if (isString(templateEngine)) {
    currentTemplateEngine = templateEngines[templateEngine];
    if (!currentTemplateEngine) {
      throw errors_default.Error("E0020", templateEngine);
    }
  } else {
    currentTemplateEngine = templateEngine;
  }
}
function getCurrentTemplateEngine() {
  return currentTemplateEngine;
}

// node_modules/devextreme/esm/core/config.js
var config_default2 = config_default;

// node_modules/devextreme/esm/core/guid.js
var guid_default2 = guid_default;

// node_modules/devextreme/esm/__internal/core/utils/m_dependency_injector.js
function injector(object) {
  const BaseClass = class_default.inherit(object);
  let InjectedClass = BaseClass;
  let instance = new InjectedClass(object);
  const initialFields = {};
  const injectFields = function(injectionObject, initial) {
    each(injectionObject, function(key) {
      if (isFunction(instance[key])) {
        if (initial || !object[key]) {
          object[key] = function() {
            return instance[key].apply(object, arguments);
          };
        }
      } else {
        if (initial) {
          initialFields[key] = object[key];
        }
        object[key] = instance[key];
      }
    });
  };
  injectFields(object, true);
  object.inject = function(injectionObject) {
    InjectedClass = InjectedClass.inherit(injectionObject);
    instance = new InjectedClass();
    injectFields(injectionObject);
  };
  object.resetInjection = function() {
    extend(object, initialFields);
    InjectedClass = BaseClass;
    instance = new BaseClass();
  };
  return object;
}

// node_modules/devextreme/esm/core/utils/dependency_injector.js
var dependency_injector_default = injector;

// node_modules/devextreme/esm/__internal/core/utils/m_variable_wrapper.js
var variableWrapper = dependency_injector_default({
  isWrapped: function() {
    return false;
  },
  isWritableWrapped: function() {
    return false;
  },
  wrap: function(value2) {
    return value2;
  },
  unwrap: function(value2) {
    return value2;
  },
  assign: function() {
    logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.");
  }
});

// node_modules/devextreme/esm/core/utils/variable_wrapper.js
var variable_wrapper_default = variableWrapper;

// node_modules/devextreme/esm/__internal/core/utils/m_object.js
var getDeepCopyTarget = (item) => {
  if (isObject(item)) {
    return Array.isArray(item) ? [] : {};
  }
  return item;
};
var legacyAssign = function(target, property, value2, extendComplexObject, assignByReference, shouldCopyUndefined) {
  if (!assignByReference && variable_wrapper_default.isWrapped(target[property])) {
    variable_wrapper_default.assign(target[property], value2);
  } else {
    target[property] = value2;
  }
};
var newAssign = function(target, property, value2, extendComplexObject, assignByReference, shouldCopyUndefined) {
  const goDeeper = extendComplexObject ? isObject(target) : isPlainObject(target);
  if (!assignByReference && variable_wrapper_default.isWrapped(target[property])) {
    variable_wrapper_default.assign(target[property], value2);
  } else if (!assignByReference && Array.isArray(value2)) {
    target[property] = value2.map((item) => deepExtendArraySafe(getDeepCopyTarget(item), item, extendComplexObject, assignByReference, shouldCopyUndefined));
  } else if (!assignByReference && goDeeper) {
    target[property] = deepExtendArraySafe(getDeepCopyTarget(value2), value2, extendComplexObject, assignByReference, shouldCopyUndefined, newAssign);
  } else {
    target[property] = value2;
  }
};
var deepExtendArraySafe = function(target, changes, extendComplexObject, assignByReference, shouldCopyUndefined, useNewAssign) {
  let prevValue;
  let newValue;
  const assignFunc = useNewAssign ? newAssign : legacyAssign;
  for (const name2 in changes) {
    prevValue = target[name2];
    newValue = changes[name2];
    if ("__proto__" === name2 || "constructor" === name2 || target === newValue) {
      continue;
    }
    if (isPlainObject(newValue)) {
      const goDeeper = extendComplexObject ? isObject(prevValue) : isPlainObject(prevValue);
      newValue = deepExtendArraySafe(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference, shouldCopyUndefined);
    }
    const isDeepCopyArray = Array.isArray(newValue) && !assignByReference;
    const hasDifferentNewValue = (shouldCopyUndefined || void 0 !== newValue) && prevValue !== newValue || shouldCopyUndefined && void 0 === prevValue;
    if (isDeepCopyArray || hasDifferentNewValue) {
      assignFunc(target, name2, newValue, extendComplexObject, assignByReference, shouldCopyUndefined);
    }
  }
  return target;
};

// node_modules/devextreme/esm/__internal/core/utils/m_data.js
var unwrapVariable = variable_wrapper_default.unwrap;
var {
  isWrapped
} = variable_wrapper_default;
var {
  assign
} = variable_wrapper_default;
var bracketsToDots = function(expr) {
  return expr.replace(/\[/g, ".").replace(/\]/g, "");
};
var getPathParts = function(name2) {
  return bracketsToDots(name2).split(".");
};
var readPropValue = function(obj, propName, options2) {
  options2 = options2 || {};
  if ("this" === propName) {
    return unwrap(obj, options2);
  }
  return unwrap(obj[propName], options2);
};
var assignPropValue = function(obj, propName, value2, options2) {
  if ("this" === propName) {
    throw new errors_default.Error("E4016");
  }
  const propValue = obj[propName];
  if (options2.unwrapObservables && isWrapped(propValue)) {
    assign(propValue, value2);
  } else {
    obj[propName] = value2;
  }
};
var prepareOptions = function(options2) {
  options2 = options2 || {};
  options2.unwrapObservables = void 0 !== options2.unwrapObservables ? options2.unwrapObservables : true;
  return options2;
};
function unwrap(value2, options2) {
  return options2.unwrapObservables ? unwrapVariable(value2) : value2;
}
var compileGetter = function(expr) {
  if (arguments.length > 1) {
    expr = [].slice.call(arguments);
  }
  if (!expr || "this" === expr) {
    return function(obj) {
      return obj;
    };
  }
  if ("string" === typeof expr) {
    const path = getPathParts(expr);
    return function(obj, options2) {
      options2 = prepareOptions(options2);
      const functionAsIs = options2.functionsAsIs;
      const hasDefaultValue = "defaultValue" in options2;
      let current2 = unwrap(obj, options2);
      for (let i = 0; i < path.length; i++) {
        if (!current2) {
          if (null == current2 && hasDefaultValue) {
            return options2.defaultValue;
          }
          break;
        }
        const pathPart = path[i];
        if (hasDefaultValue && isObject(current2) && !(pathPart in current2)) {
          return options2.defaultValue;
        }
        let next = unwrap(current2[pathPart], options2);
        if (!functionAsIs && isFunction(next)) {
          next = next.call(current2);
        }
        current2 = next;
      }
      return current2;
    };
  }
  if (Array.isArray(expr)) {
    return combineGetters(expr);
  }
  if (isFunction(expr)) {
    return expr;
  }
};
function combineGetters(getters) {
  const compiledGetters = {};
  for (let i = 0, l = getters.length; i < l; i++) {
    const getter = getters[i];
    compiledGetters[getter] = compileGetter(getter);
  }
  return function(obj, options2) {
    let result2;
    each(compiledGetters, function(name2) {
      const value2 = this(obj, options2);
      if (void 0 === value2) {
        return;
      }
      let current2 = result2 || (result2 = {});
      const path = name2.split(".");
      const last = path.length - 1;
      for (let i = 0; i < last; i++) {
        const pathItem = path[i];
        if (!(pathItem in current2)) {
          current2[pathItem] = {};
        }
        current2 = current2[pathItem];
      }
      current2[path[last]] = value2;
    });
    return result2;
  };
}
function toLowerCase(value2, options2) {
  return null !== options2 && void 0 !== options2 && options2.locale ? value2.toLocaleLowerCase(options2.locale) : value2.toLowerCase();
}
function toUpperCase(value2, options2) {
  return null !== options2 && void 0 !== options2 && options2.locale ? value2.toLocaleUpperCase(options2.locale) : value2.toUpperCase();
}
var ensurePropValueDefined = function(obj, propName, value2, options2) {
  if (isDefined(value2)) {
    return value2;
  }
  const newValue = {};
  assignPropValue(obj, propName, newValue, options2);
  return newValue;
};
var compileSetter = function(expr) {
  expr = getPathParts(expr || "this");
  const lastLevelIndex = expr.length - 1;
  return function(obj, value2, options2) {
    options2 = prepareOptions(options2);
    let currentValue = unwrap(obj, options2);
    expr.forEach(function(propertyName, levelIndex) {
      let propertyValue = readPropValue(currentValue, propertyName, options2);
      const isPropertyFunc = !options2.functionsAsIs && isFunction(propertyValue) && !isWrapped(propertyValue);
      if (levelIndex === lastLevelIndex) {
        if (options2.merge && isPlainObject(value2) && (!isDefined(propertyValue) || isPlainObject(propertyValue))) {
          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
          deepExtendArraySafe(propertyValue, value2, false, true);
        } else if (isPropertyFunc) {
          currentValue[propertyName](value2);
        } else {
          assignPropValue(currentValue, propertyName, value2, options2);
        }
      } else {
        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
        if (isPropertyFunc) {
          propertyValue = propertyValue.call(currentValue);
        }
        currentValue = propertyValue;
      }
    });
  };
};
var toComparable = function(value2, caseSensitive) {
  var _options$collatorOpti;
  let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
  if (value2 instanceof Date) {
    return value2.getTime();
  }
  const collatorSensitivity = null === options2 || void 0 === options2 || null === (_options$collatorOpti = options2.collatorOptions) || void 0 === _options$collatorOpti ? void 0 : _options$collatorOpti.sensitivity;
  if (value2 && value2 instanceof class_default && value2.valueOf) {
    value2 = value2.valueOf();
  } else if ("string" === typeof value2 && ("base" === collatorSensitivity || "case" === collatorSensitivity)) {
    const REMOVE_DIACRITICAL_MARKS_REGEXP = /[\u0300-\u036f]/g;
    if ("base" === collatorSensitivity) {
      value2 = toLowerCase(value2, options2);
    }
    value2 = value2.normalize("NFD").replace(REMOVE_DIACRITICAL_MARKS_REGEXP, "");
  }
  const isCaseSensitive = caseSensitive || "case" === collatorSensitivity || "variant" === collatorSensitivity;
  if ("string" === typeof value2 && !isCaseSensitive) {
    var _options$locale;
    const locale = null === options2 || void 0 === options2 || null === (_options$locale = options2.locale) || void 0 === _options$locale ? void 0 : _options$locale.toLowerCase();
    const useUpperCase = locale && !!["hy", "el"].find((code) => locale === code || locale.startsWith(`${code}-`));
    return (useUpperCase ? toUpperCase : toLowerCase)(value2, options2);
  }
  return value2;
};

// node_modules/devextreme/esm/__internal/core/utils/m_deferred.js
var deferredConfig = [{
  method: "resolve",
  handler: "done",
  state: "resolved"
}, {
  method: "reject",
  handler: "fail",
  state: "rejected"
}, {
  method: "notify",
  handler: "progress"
}];
var DeferredObj = function() {
  const that = this;
  this._state = "pending";
  this._promise = {};
  deferredConfig.forEach((function(config3) {
    const methodName = config3.method;
    this[`${methodName}Callbacks`] = callbacks_default();
    this[methodName] = (function() {
      return this[`${methodName}With`](this._promise, arguments);
    }).bind(this);
    this._promise[config3.handler] = function(handler) {
      if (!handler) {
        return this;
      }
      const callbacks2 = that[`${methodName}Callbacks`];
      if (callbacks2.fired()) {
        handler.apply(that[`${methodName}Context`], that[`${methodName}Args`]);
      } else {
        callbacks2.add(function(context2, args) {
          handler.apply(context2, args);
        });
      }
      return this;
    };
  }).bind(this));
  this._promise.always = function(handler) {
    return this.done(handler).fail(handler);
  };
  this._promise.catch = function(handler) {
    return this.then(null, handler);
  };
  this._promise.then = function(resolve, reject) {
    const result2 = new DeferredObj();
    ["done", "fail"].forEach((function(method) {
      const callback = "done" === method ? resolve : reject;
      this[method](function() {
        if (!callback) {
          result2["done" === method ? "resolve" : "reject"].apply(this, arguments);
          return;
        }
        const callbackResult = callback && callback.apply(this, arguments);
        if (isDeferred(callbackResult)) {
          callbackResult.done(result2.resolve).fail(result2.reject);
        } else if (isPromise(callbackResult)) {
          callbackResult.then(result2.resolve, result2.reject);
        } else {
          result2.resolve.apply(this, isDefined(callbackResult) ? [callbackResult] : arguments);
        }
      });
    }).bind(this));
    return result2.promise();
  };
  this._promise.state = function() {
    return that._state;
  };
  this._promise.promise = function(args) {
    return args ? extend(args, that._promise) : that._promise;
  };
  this._promise.promise(this);
};
deferredConfig.forEach(function(config3) {
  const methodName = config3.method;
  const {
    state
  } = config3;
  DeferredObj.prototype[`${methodName}With`] = function(context2, args) {
    const callbacks2 = this[`${methodName}Callbacks`];
    if ("pending" === this.state()) {
      this[`${methodName}Args`] = args;
      this[`${methodName}Context`] = context2;
      if (state) {
        this._state = state;
      }
      callbacks2.fire(context2, args);
      if ("pending" !== state) {
        this.resolveCallbacks.empty();
        this.rejectCallbacks.empty();
      }
    }
    return this;
  };
});
function fromPromise(promise, context2) {
  if (isDeferred(promise)) {
    return promise;
  }
  if (isPromise(promise)) {
    const d = new DeferredObj();
    promise.then(function() {
      d.resolveWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    }, function() {
      d.rejectWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    });
    return d;
  }
  return new DeferredObj().resolveWith(context2, [promise]);
}
var whenFunc = function() {
  if (1 === arguments.length) {
    return fromPromise(arguments[0]);
  }
  const values = [].slice.call(arguments);
  const contexts = [];
  let resolvedCount = 0;
  const deferred = new DeferredObj();
  const updateState = function(i) {
    return function(value2) {
      contexts[i] = this;
      values[i] = arguments.length > 1 ? [].slice.call(arguments) : value2;
      resolvedCount++;
      if (resolvedCount === values.length) {
        deferred.resolveWith(contexts, values);
      }
    };
  };
  for (let i = 0; i < values.length; i++) {
    if (isDeferred(values[i])) {
      values[i].promise().done(updateState(i)).fail(deferred.reject);
    } else {
      resolvedCount++;
    }
  }
  if (resolvedCount === values.length) {
    deferred.resolveWith(contexts, values);
  }
  return deferred.promise();
};
function Deferred() {
  return new DeferredObj();
}
function when() {
  return whenFunc.apply(this, arguments);
}

// node_modules/devextreme/esm/__internal/core/utils/m_common.js
var uiLayerInitialized = new Deferred();
var ensureDefined = function(value2, defaultValue) {
  return isDefined(value2) ? value2 : defaultValue;
};
var executeAsync = function(action, context2) {
  const deferred = new Deferred();
  const normalizedContext = context2 || this;
  const task = {
    promise: deferred.promise(),
    abort() {
      clearTimeout(timerId);
      deferred.rejectWith(normalizedContext);
    }
  };
  const timerId = (arguments[2] || setTimeout)(function() {
    const result2 = action.call(normalizedContext);
    if (result2 && result2.done && isFunction(result2.done)) {
      result2.done(function() {
        deferred.resolveWith(normalizedContext);
      });
    } else {
      deferred.resolveWith(normalizedContext);
    }
  }, "number" === typeof context2 ? context2 : 0);
  return task;
};
var delayedFuncs = [];
var delayedNames = [];
var delayedDeferreds = [];
var executingName;
var deferExecute = function(name2, func, deferred) {
  if (executingName && executingName !== name2) {
    delayedFuncs.push(func);
    delayedNames.push(name2);
    deferred = deferred || new Deferred();
    delayedDeferreds.push(deferred);
    return deferred;
  }
  const oldExecutingName = executingName;
  const currentDelayedCount = delayedDeferreds.length;
  executingName = name2;
  let result2 = func();
  if (!result2) {
    if (delayedDeferreds.length > currentDelayedCount) {
      result2 = when.apply(this, delayedDeferreds.slice(currentDelayedCount));
    } else if (deferred) {
      deferred.resolve();
    }
  }
  executingName = oldExecutingName;
  if (deferred && result2 && result2.done) {
    result2.done(deferred.resolve).fail(deferred.reject);
  }
  if (!executingName && delayedFuncs.length) {
    ("render" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());
  }
  return result2 || when();
};
var deferRender = function(func, deferred) {
  return deferExecute("render", func, deferred);
};
var deferUpdate = function(func, deferred) {
  return deferExecute("update", func, deferred);
};
var deferRenderer = function(func) {
  return function() {
    const that = this;
    return deferExecute("render", function() {
      return func.call(that);
    });
  };
};
var deferUpdater = function(func) {
  return function() {
    const that = this;
    return deferExecute("update", function() {
      return func.call(that);
    });
  };
};
var findBestMatches = (targetFilter, items, mapFn) => {
  const bestMatches = [];
  let maxMatchCount = 0;
  each(items, (index2, itemSrc) => {
    let matchCount = 0;
    const item = mapFn ? mapFn(itemSrc) : itemSrc;
    each(targetFilter, (paramName, targetValue) => {
      const value2 = item[paramName];
      if (void 0 === value2) {
        return;
      }
      if (match(value2, targetValue)) {
        matchCount++;
        return;
      }
      matchCount = -1;
      return false;
    });
    if (matchCount < maxMatchCount) {
      return;
    }
    if (matchCount > maxMatchCount) {
      bestMatches.length = 0;
      maxMatchCount = matchCount;
    }
    bestMatches.push(itemSrc);
  });
  return bestMatches;
};
var match = function(value2, targetValue) {
  if (Array.isArray(value2) && Array.isArray(targetValue)) {
    let mismatch = false;
    each(value2, (index2, valueItem) => {
      if (valueItem !== targetValue[index2]) {
        mismatch = true;
        return false;
      }
    });
    if (mismatch) {
      return false;
    }
    return true;
  }
  if (value2 === targetValue) {
    return true;
  }
  return false;
};
var splitPair = function(raw) {
  switch (type(raw)) {
    case "string":
      return raw.split(/\s+/, 2);
    case "object":
      return [raw.x ?? raw.h, raw.y ?? raw.v];
    case "number":
      return [raw];
    case "array":
      return raw;
    default:
      return null;
  }
};
var normalizeKey = function(id) {
  let key = isString(id) ? id : id.toString();
  const arr = key.match(/[^a-zA-Z0-9_]/g);
  arr && each(arr, (_, sign2) => {
    key = key.replace(sign2, `__${sign2.charCodeAt()}__`);
  });
  return key;
};
var denormalizeKey = function(key) {
  const arr = key.match(/__\d+__/g);
  arr && arr.forEach((char) => {
    const charCode = parseInt(char.replace("__", ""));
    key = key.replace(char, String.fromCharCode(charCode));
  });
  return key;
};
var pairToObject = function(raw, preventRound) {
  const pair = splitPair(raw);
  let h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
  let v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);
  if (!isFinite(h)) {
    h = 0;
  }
  if (!isFinite(v)) {
    v = h;
  }
  return {
    h,
    v
  };
};
var getKeyHash = function(key) {
  if (key instanceof guid_default2) {
    return key.toString();
  }
  if (isObject(key) || Array.isArray(key)) {
    try {
      const keyHash = JSON.stringify(key);
      return "{}" === keyHash ? key : keyHash;
    } catch (e) {
      return key;
    }
  }
  return key;
};
var escapeRegExp = function(string) {
  return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, "\\$&");
};
var applyServerDecimalSeparator = function(value2) {
  const separator = config_default2().serverDecimalSeparator;
  if (isDefined(value2)) {
    value2 = value2.toString().replace(".", separator);
  }
  return value2;
};
var noop2 = function() {
};
var asyncNoop = function() {
  return new Deferred().resolve().promise();
};
var grep = function(elements, checkFunction, invert) {
  const result2 = [];
  let check;
  const expectedCheck = !invert;
  for (let i = 0; i < elements.length; i++) {
    check = !!checkFunction(elements[i], i);
    if (check === expectedCheck) {
      result2.push(elements[i]);
    }
  }
  return result2;
};
var compareArrays = (array1, array2, depth, options2) => {
  if (array1.length !== array2.length) {
    return false;
  }
  return !array1.some((item, idx) => !compareByValue(item, array2[idx], depth + 1, _extends({}, options2, {
    strict: true
  })));
};
var compareObjects = (object1, object2, depth, options2) => {
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  const keys2Set = new Set(keys2);
  return !keys1.some((key) => !keys2Set.has(key) || !compareByValue(object1[key], object2[key], depth + 1, options2));
};
var DEFAULT_EQUAL_BY_VALUE_OPTS = {
  maxDepth: 3,
  strict: true
};
var compareByValue = (value1, value2, depth, options2) => {
  const {
    strict,
    maxDepth
  } = options2;
  const comparable1 = toComparable(value1, true);
  const comparable2 = toComparable(value2, true);
  const comparisonResult = strict ? comparable1 === comparable2 : comparable1 == comparable2;
  switch (true) {
    case comparisonResult:
    case depth >= maxDepth:
      return true;
    case (isObject(comparable1) && isObject(comparable2)):
      return compareObjects(comparable1, comparable2, depth, options2);
    case (Array.isArray(comparable1) && Array.isArray(comparable2)):
      return compareArrays(comparable1, comparable2, depth, options2);
    default:
      return false;
  }
};
var equalByValue = function(value1, value2) {
  let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : DEFAULT_EQUAL_BY_VALUE_OPTS;
  const compareOptions = _extends({}, DEFAULT_EQUAL_BY_VALUE_OPTS, options2);
  return compareByValue(value1, value2, 0, compareOptions);
};
var m_common_default = {
  ensureDefined,
  executeAsync,
  deferRender,
  deferUpdate,
  deferRenderer,
  deferUpdater,
  findBestMatches,
  splitPair,
  normalizeKey,
  denormalizeKey,
  pairToObject,
  getKeyHash,
  escapeRegExp,
  applyServerDecimalSeparator,
  noop: noop2,
  asyncNoop,
  grep,
  equalByValue
};

// node_modules/devextreme/esm/__internal/core/utils/m_shadow_dom.js
var ownerDocumentStyleSheet = null;
function createConstructedStyleSheet(rootNode) {
  try {
    return new CSSStyleSheet();
  } catch (err) {
    const styleElement = rootNode.ownerDocument.createElement("style");
    rootNode.appendChild(styleElement);
    return styleElement.sheet;
  }
}
function processRules(targetStyleSheet, styleSheets, needApplyAllStyles) {
  for (let i = 0; i < styleSheets.length; i++) {
    const sheet = styleSheets[i];
    try {
      for (let j = 0; j < sheet.cssRules.length; j++) {
        insertRule(targetStyleSheet, sheet.cssRules[j], needApplyAllStyles);
      }
    } catch (err) {
    }
  }
}
function insertRule(targetStyleSheet, rule, needApplyAllStyles) {
  var _rule$selectorText, _rule$cssRules, _rule$name, _rule$style;
  const isDxRule = needApplyAllStyles || (null === (_rule$selectorText = rule.selectorText) || void 0 === _rule$selectorText ? void 0 : _rule$selectorText.includes("dx-")) || (null === (_rule$cssRules = rule.cssRules) || void 0 === _rule$cssRules || null === (_rule$cssRules = _rule$cssRules[0]) || void 0 === _rule$cssRules || null === (_rule$cssRules = _rule$cssRules.selectorText) || void 0 === _rule$cssRules ? void 0 : _rule$cssRules.includes("dx-")) || (null === (_rule$name = rule.name) || void 0 === _rule$name ? void 0 : _rule$name.startsWith("dx-")) || "DXIcons" === (null === (_rule$style = rule.style) || void 0 === _rule$style ? void 0 : _rule$style.fontFamily);
  if (isDxRule) {
    targetStyleSheet.insertRule(rule.cssText, targetStyleSheet.cssRules.length);
  }
}
function addShadowDomStyles($element) {
  var _el$getRootNode;
  const el = $element.get(0);
  const root = null === (_el$getRootNode = el.getRootNode) || void 0 === _el$getRootNode ? void 0 : _el$getRootNode.call(el);
  if (!(null !== root && void 0 !== root && root.host)) {
    return;
  }
  if (!ownerDocumentStyleSheet) {
    ownerDocumentStyleSheet = createConstructedStyleSheet(root);
    processRules(ownerDocumentStyleSheet, el.ownerDocument.styleSheets, false);
  }
  const currentShadowDomStyleSheet = createConstructedStyleSheet(root);
  processRules(currentShadowDomStyleSheet, root.styleSheets, true);
  root.adoptedStyleSheets = [ownerDocumentStyleSheet, currentShadowDomStyleSheet];
}
function isPositionInElementRectangle(element, x, y) {
  var _element$getBoundingC;
  const rect = null === (_element$getBoundingC = element.getBoundingClientRect) || void 0 === _element$getBoundingC ? void 0 : _element$getBoundingC.call(element);
  return rect && x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom;
}
function createQueue() {
  let shiftIndex = 0;
  const items = [];
  return {
    push(item) {
      items.push(item);
      return this;
    },
    shift() {
      shiftIndex++;
      return items[shiftIndex - 1];
    },
    get length() {
      return items.length - shiftIndex;
    },
    get items() {
      return items;
    }
  };
}
function getShadowElementsFromPoint(x, y, root) {
  const elementQueue = createQueue().push(root);
  while (elementQueue.length) {
    const el = elementQueue.shift();
    for (let i = 0; i < el.childNodes.length; i++) {
      const childNode = el.childNodes[i];
      if (childNode.nodeType === Node.ELEMENT_NODE && isPositionInElementRectangle(childNode, x, y) && "none" !== getComputedStyle(childNode).pointerEvents) {
        elementQueue.push(childNode);
      }
    }
  }
  const result2 = elementQueue.items.reverse();
  result2.pop();
  return result2;
}

// node_modules/devextreme/esm/__internal/core/m_dom_adapter.js
var nativeDOMAdapterStrategy = {
  querySelectorAll: (element, selector) => element.querySelectorAll(selector),
  elementMatches(element, selector) {
    const matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || ((selector2) => {
      const doc = element.document || element.ownerDocument;
      if (!doc) {
        return false;
      }
      const items = this.querySelectorAll(doc, selector2);
      for (let i = 0; i < items.length; i++) {
        if (items[i] === element) {
          return true;
        }
      }
    });
    return matches.call(element, selector);
  },
  createElement(tagName, context2) {
    context2 = context2 ?? this._document;
    return context2.createElement(tagName);
  },
  createElementNS(ns, tagName, context2) {
    context2 = context2 || this._document;
    return context2.createElementNS(ns, tagName);
  },
  createTextNode(text, context2) {
    context2 = context2 || this._document;
    return context2.createTextNode(text);
  },
  createAttribute(text, context2) {
    context2 = context2 || this._document;
    return context2.createAttribute(text);
  },
  isNode: (element) => !!element && "object" === typeof element && "nodeType" in element && "nodeName" in element,
  isElementNode: (element) => !!element && 1 === element.nodeType,
  isTextNode: (element) => element && 3 === element.nodeType,
  isDocument: (element) => element && 9 === element.nodeType,
  isDocumentFragment: (element) => element && 11 === element.nodeType,
  removeElement(element) {
    const parentNode = element && element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  },
  insertElement(parentElement, newElement, nextSiblingElement) {
    if (parentElement && newElement && parentElement !== newElement) {
      if (nextSiblingElement) {
        parentElement.insertBefore(newElement, nextSiblingElement);
      } else {
        parentElement.appendChild(newElement);
      }
    }
  },
  getAttribute: (element, name2) => element.getAttribute(name2),
  setAttribute(element, name2, value2) {
    if ("style" === name2) {
      element.style.cssText = value2;
    } else {
      element.setAttribute(name2, value2);
    }
  },
  removeAttribute(element, name2) {
    element.removeAttribute(name2);
  },
  setProperty(element, name2, value2) {
    element[name2] = value2;
  },
  setText(element, text) {
    if (element) {
      element.textContent = text;
    }
  },
  setClass(element, className, isAdd) {
    if (1 === element.nodeType && className) {
      isAdd ? element.classList.add(className) : element.classList.remove(className);
    }
  },
  setStyle(element, name2, value2) {
    element.style[name2] = value2 || "";
  },
  _document: "undefined" === typeof document ? void 0 : document,
  getDocument() {
    return this._document;
  },
  getActiveElement(element) {
    const activeElementHolder = this.getRootNode(element);
    return activeElementHolder.activeElement;
  },
  getRootNode(element) {
    var _element$getRootNode;
    return (null === element || void 0 === element || null === (_element$getRootNode = element.getRootNode) || void 0 === _element$getRootNode ? void 0 : _element$getRootNode.call(element)) ?? this._document;
  },
  getBody() {
    return this._document.body;
  },
  createDocumentFragment() {
    return this._document.createDocumentFragment();
  },
  getDocumentElement() {
    return this._document.documentElement;
  },
  getLocation() {
    return this._document.location;
  },
  getSelection() {
    return this._document.selection;
  },
  getReadyState() {
    return this._document.readyState;
  },
  getHead() {
    return this._document.head;
  },
  hasDocumentProperty(property) {
    return property in this._document;
  },
  listen(element, event, callback, options2) {
    if (!element || !("addEventListener" in element)) {
      return noop2;
    }
    element.addEventListener(event, callback, options2);
    return () => {
      element.removeEventListener(event, callback);
    };
  },
  elementsFromPoint(x, y, element) {
    const activeElementHolder = this.getRootNode(element);
    if (activeElementHolder.host) {
      return getShadowElementsFromPoint(x, y, activeElementHolder);
    }
    return activeElementHolder.elementsFromPoint(x, y);
  }
};
var domAdapter = dependency_injector_default(nativeDOMAdapterStrategy);

// node_modules/devextreme/esm/core/dom_adapter.js
var dom_adapter_default = domAdapter;

// node_modules/devextreme/esm/common/core/events/core/event_registrator_callbacks.js
var event_registrator_callbacks_default = new memorized_callbacks_default();

// node_modules/devextreme/esm/__internal/events/core/m_hook_touch_props.js
var touchPropsToHook = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"];
var touchPropHook = function(name2, event) {
  if (event[name2] && !event.touches || !event.touches) {
    return event[name2];
  }
  const touches = event.touches.length ? event.touches : event.changedTouches;
  if (!touches.length) {
    return;
  }
  return touches[0][name2];
};
function m_hook_touch_props_default(callback) {
  touchPropsToHook.forEach((name2) => {
    callback(name2, (event) => touchPropHook(name2, event));
  }, this);
}

// node_modules/devextreme/esm/__internal/events/utils/m_event_target.js
var getEventTarget = (event) => {
  var _originalEvent$target, _originalEvent$compos;
  const {
    originalEvent
  } = event;
  if (!originalEvent) {
    return event.target;
  }
  const isShadowDOMUsed = Boolean(null === (_originalEvent$target = originalEvent.target) || void 0 === _originalEvent$target ? void 0 : _originalEvent$target.shadowRoot);
  if (!isShadowDOMUsed) {
    return originalEvent.target;
  }
  const path = originalEvent.path ?? (null === (_originalEvent$compos = originalEvent.composedPath) || void 0 === _originalEvent$compos ? void 0 : _originalEvent$compos.call(originalEvent));
  const target = (null === path || void 0 === path ? void 0 : path[0]) ?? event.target;
  return target;
};

// node_modules/devextreme/esm/__internal/core/utils/m_call_once.js
var callOnce = function(handler) {
  let result2;
  let wrappedHandler = function() {
    result2 = handler.apply(this, arguments);
    wrappedHandler = function() {
      return result2;
    };
    return result2;
  };
  return function() {
    return wrappedHandler.apply(this, arguments);
  };
};

// node_modules/devextreme/esm/core/utils/call_once.js
var call_once_default = callOnce;

// node_modules/devextreme/esm/__internal/core/utils/m_window.js
var hasWindowValue = "undefined" !== typeof window;
var hasWindow = () => hasWindowValue;
var windowObject = hasWindow() ? window : void 0;
if (!windowObject) {
  windowObject = {};
  windowObject.window = windowObject;
}
var getWindow = () => windowObject;
var setWindow = (newWindowObject, hasWindow2) => {
  if (void 0 === hasWindow2) {
    hasWindowValue = "undefined" !== typeof window && window === newWindowObject;
  } else {
    hasWindowValue = hasWindow2;
  }
  windowObject = newWindowObject;
};
var hasProperty = (prop) => hasWindow() && prop in windowObject;
var defaultScreenFactorFunc = (width) => {
  if (width < 768) {
    return "xs";
  }
  if (width < 992) {
    return "sm";
  }
  if (width < 1200) {
    return "md";
  }
  return "lg";
};
var getCurrentScreenFactor = (screenFactorCallback) => {
  const screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
  const windowWidth = dom_adapter_default.getDocumentElement().clientWidth;
  return screenFactorFunc(windowWidth);
};
var getNavigator = () => {
  var _windowObject;
  return hasWindow() ? null === (_windowObject = windowObject) || void 0 === _windowObject ? void 0 : _windowObject.navigator : {
    userAgent: ""
  };
};
var m_window_default = {
  defaultScreenFactorFunc,
  getCurrentScreenFactor,
  getNavigator,
  getWindow,
  hasProperty,
  hasWindow,
  setWindow
};

// node_modules/devextreme/esm/__internal/events/core/m_events_engine.js
var window2 = getWindow();
var EMPTY_EVENT_NAME = "dxEmptyEventType";
var NATIVE_EVENTS_TO_SUBSCRIBE = {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
};
var NATIVE_EVENTS_TO_TRIGGER = {
  focusin: "focus",
  focusout: "blur"
};
var NO_BUBBLE_EVENTS = ["blur", "focus", "load"];
var forcePassiveFalseEventNames = ["touchmove", "wheel", "mousewheel", "touchstart"];
var EVENT_PROPERTIES = ["target", "relatedTarget", "delegateTarget", "altKey", "bubbles", "cancelable", "changedTouches", "ctrlKey", "detail", "eventPhase", "metaKey", "shiftKey", "view", "char", "code", "charCode", "key", "keyCode", "button", "buttons", "offsetX", "offsetY", "pointerId", "pointerType", "targetTouches", "toElement", "touches"];
function matchesSafe(target, selector) {
  return !isWindow(target) && "#document" !== target.nodeName && dom_adapter_default.elementMatches(target, selector);
}
var elementDataMap = /* @__PURE__ */ new WeakMap();
var guid = 0;
var skipEvent;
var special = function() {
  const specialData = {};
  event_registrator_callbacks_default.add((eventName, eventObject) => {
    specialData[eventName] = eventObject;
  });
  return {
    getField: (eventName, field) => specialData[eventName] && specialData[eventName][field],
    callMethod: (eventName, methodName, context2, args) => specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context2, args)
  };
}();
var eventsEngine = dependency_injector_default({
  on: getHandler(normalizeOnArguments(iterate((element, eventName, selector, data2, handler) => {
    const handlersController = getHandlersController(element, eventName);
    handlersController.addHandler(handler, selector, data2);
  }))),
  one: getHandler(normalizeOnArguments((element, eventName, selector, data2, handler) => {
    const oneTimeHandler = function() {
      eventsEngine.off(element, eventName, selector, oneTimeHandler);
      handler.apply(this, arguments);
    };
    eventsEngine.on(element, eventName, selector, data2, oneTimeHandler);
  })),
  off: getHandler(normalizeOffArguments(iterate((element, eventName, selector, handler) => {
    const handlersController = getHandlersController(element, eventName);
    handlersController.removeHandler(handler, selector);
  }))),
  trigger: getHandler(normalizeTriggerArguments((element, event, extraParameters) => {
    const eventName = event.type;
    const handlersController = getHandlersController(element, event.type);
    special.callMethod(eventName, "trigger", element, [event, extraParameters]);
    handlersController.callHandlers(event, extraParameters);
    const noBubble = special.getField(eventName, "noBubble") || event.isPropagationStopped() || NO_BUBBLE_EVENTS.includes(eventName);
    if (!noBubble) {
      const parents = [];
      const getParents = function(element2) {
        const parent = element2.parentNode ?? (isObject(element2.host) ? element2.host : null);
        if (parent) {
          parents.push(parent);
          getParents(parent);
        }
      };
      getParents(element);
      parents.push(window2);
      let i = 0;
      while (parents[i] && !event.isPropagationStopped()) {
        const parentDataByEvent = getHandlersController(parents[i], event.type);
        parentDataByEvent.callHandlers(extend(event, {
          currentTarget: parents[i]
        }), extraParameters);
        i++;
      }
    }
    if (element.nodeType || isWindow(element)) {
      special.callMethod(eventName, "_default", element, [event, extraParameters]);
      callNativeMethod(eventName, element);
    }
  })),
  triggerHandler: getHandler(normalizeTriggerArguments((element, event, extraParameters) => {
    const handlersController = getHandlersController(element, event.type);
    handlersController.callHandlers(event, extraParameters);
  }))
});
function applyForEach(args, method) {
  const element = args[0];
  if (!element) {
    return;
  }
  if (dom_adapter_default.isNode(element) || isWindow(element)) {
    method.apply(eventsEngine, args);
  } else if (!isString(element) && "length" in element) {
    const itemArgs = Array.prototype.slice.call(args, 0);
    Array.prototype.forEach.call(element, (itemElement) => {
      itemArgs[0] = itemElement;
      applyForEach(itemArgs, method);
    });
  } else {
    throw errors_default.Error("E0025");
  }
}
function getHandler(method) {
  return function() {
    applyForEach(arguments, method);
  };
}
function detectPassiveEventHandlersSupport() {
  let isSupported = false;
  try {
    const options2 = Object.defineProperty({}, "passive", {
      get() {
        isSupported = true;
        return true;
      }
    });
    window2.addEventListener("test", null, options2);
  } catch (e) {
  }
  return isSupported;
}
var passiveEventHandlersSupported = call_once_default(detectPassiveEventHandlersSupport);
var contains = (container, element) => {
  if (isWindow(container)) {
    return contains(container.document, element);
  }
  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};
function getHandlersController(element, eventName) {
  let elementData = elementDataMap.get(element);
  eventName = eventName || "";
  const eventNameParts = eventName.split(".");
  const namespaces2 = eventNameParts.slice(1);
  const eventNameIsDefined = !!eventNameParts[0];
  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;
  if (!elementData) {
    elementData = {};
    elementDataMap.set(element, elementData);
  }
  if (!elementData[eventName]) {
    elementData[eventName] = {
      handleObjects: [],
      nativeHandler: null
    };
  }
  const eventData2 = elementData[eventName];
  return {
    addHandler(handler, selector, data2) {
      const callHandler = function(e, extraParameters) {
        const handlerArgs = [e];
        const target = e.currentTarget;
        const {
          relatedTarget
        } = e;
        let secondaryTargetIsInside;
        let result2;
        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget));
        }
        if (void 0 !== extraParameters) {
          handlerArgs.push(extraParameters);
        }
        special.callMethod(eventName, "handle", element, [e, data2]);
        if (!secondaryTargetIsInside) {
          result2 = handler.apply(target, handlerArgs);
        }
        if (false === result2) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      const handleObject = {
        handler,
        wrappedHandler: function(e, extraParameters) {
          if (skipEvent && e.type === skipEvent) {
            return;
          }
          e.data = data2;
          e.delegateTarget = element;
          if (selector) {
            let currentTarget = e.target;
            while (currentTarget && currentTarget !== element) {
              if (matchesSafe(currentTarget, selector)) {
                e.currentTarget = currentTarget;
                callHandler(e, extraParameters);
              }
              currentTarget = currentTarget.parentNode;
            }
          } else {
            var _e$target;
            e.currentTarget = e.delegateTarget || e.target;
            const isTargetInShadowDOM = Boolean(null === (_e$target = e.target) || void 0 === _e$target ? void 0 : _e$target.shadowRoot);
            if (isTargetInShadowDOM) {
              const target = getEventTarget(e);
              e.target = target;
            }
            callHandler(e, extraParameters);
          }
        },
        selector,
        type: eventName,
        data: data2,
        namespace: namespaces2.join("."),
        namespaces: namespaces2,
        guid: ++guid
      };
      eventData2.handleObjects.push(handleObject);
      const firstHandlerForTheType = 1 === eventData2.handleObjects.length;
      let shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
      let nativeListenerOptions;
      if (shouldAddNativeListener) {
        shouldAddNativeListener = !special.callMethod(eventName, "setup", element, [data2, namespaces2, handler]);
      }
      if (shouldAddNativeListener) {
        eventData2.nativeHandler = getNativeHandler(eventName);
        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.includes(eventName)) {
          nativeListenerOptions = {
            passive: false
          };
        }
        eventData2.removeListener = dom_adapter_default.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData2.nativeHandler, nativeListenerOptions);
      }
      special.callMethod(eventName, "add", element, [handleObject]);
    },
    removeHandler(handler, selector) {
      const removeByEventName = function(eventName2) {
        const eventData3 = elementData[eventName2];
        if (!eventData3.handleObjects.length) {
          delete elementData[eventName2];
          return;
        }
        let removedHandler;
        eventData3.handleObjects = eventData3.handleObjects.filter((handleObject) => {
          const skip = namespaces2.length && !isSubset(handleObject.namespaces, namespaces2) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;
          if (!skip) {
            removedHandler = handleObject.handler;
            special.callMethod(eventName2, "remove", element, [handleObject]);
          }
          return skip;
        });
        const lastHandlerForTheType = !eventData3.handleObjects.length;
        const shouldRemoveNativeListener = lastHandlerForTheType && eventName2 !== EMPTY_EVENT_NAME;
        if (shouldRemoveNativeListener) {
          special.callMethod(eventName2, "teardown", element, [namespaces2, removedHandler]);
          if (eventData3.nativeHandler) {
            eventData3.removeListener();
          }
          delete elementData[eventName2];
        }
      };
      if (eventNameIsDefined) {
        removeByEventName(eventName);
      } else {
        for (const name2 in elementData) {
          removeByEventName(name2);
        }
      }
      const elementDataIsEmpty = 0 === Object.keys(elementData).length;
      if (elementDataIsEmpty) {
        elementDataMap.delete(element);
      }
    },
    callHandlers(event, extraParameters) {
      let forceStop = false;
      const handleCallback = function(handleObject) {
        if (forceStop) {
          return;
        }
        if (!namespaces2.length || isSubset(handleObject.namespaces, namespaces2)) {
          handleObject.wrappedHandler(event, extraParameters);
          forceStop = event.isImmediatePropagationStopped();
        }
      };
      eventData2.handleObjects.forEach(handleCallback);
      if (namespaces2.length && elementData[EMPTY_EVENT_NAME]) {
        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);
      }
    }
  };
}
function getNativeHandler(subscribeName) {
  return function(event, extraParameters) {
    const handlersController = getHandlersController(this, subscribeName);
    event = eventsEngine.Event(event);
    handlersController.callHandlers(event, extraParameters);
  };
}
function isSubset(original, checked) {
  for (let i = 0; i < checked.length; i++) {
    if (original.indexOf(checked[i]) < 0) {
      return false;
    }
  }
  return true;
}
function normalizeOnArguments(callback) {
  return function(element, eventName, selector, data2, handler) {
    if (!handler) {
      handler = data2;
      data2 = void 0;
    }
    if ("string" !== typeof selector) {
      data2 = selector;
      selector = void 0;
    }
    if (!handler && "string" === typeof eventName) {
      handler = data2 || selector;
      selector = void 0;
      data2 = void 0;
    }
    callback(element, eventName, selector, data2, handler);
  };
}
function normalizeOffArguments(callback) {
  return function(element, eventName, selector, handler) {
    if ("function" === typeof selector) {
      handler = selector;
      selector = void 0;
    }
    callback(element, eventName, selector, handler);
  };
}
function normalizeTriggerArguments(callback) {
  return function(element, src, extraParameters) {
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!src.target) {
      src.target = element;
    }
    src.currentTarget = element;
    if (!src.delegateTarget) {
      src.delegateTarget = element;
    }
    if (!src.type && src.originalEvent) {
      src.type = src.originalEvent.type;
    }
    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);
  };
}
function normalizeEventArguments(callback) {
  eventsEngine.Event = function(src, config3) {
    if (!(this instanceof eventsEngine.Event)) {
      return new eventsEngine.Event(src, config3);
    }
    if (!src) {
      src = {};
    }
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!config3) {
      config3 = {};
    }
    callback.call(this, src, config3);
  };
  Object.assign(eventsEngine.Event.prototype, {
    _propagationStopped: false,
    _immediatePropagationStopped: false,
    _defaultPrevented: false,
    isPropagationStopped() {
      return !!(this._propagationStopped || this.originalEvent && this.originalEvent.propagationStopped);
    },
    stopPropagation() {
      this._propagationStopped = true;
      this.originalEvent && this.originalEvent.stopPropagation();
    },
    isImmediatePropagationStopped() {
      return this._immediatePropagationStopped;
    },
    stopImmediatePropagation() {
      this.stopPropagation();
      this._immediatePropagationStopped = true;
      this.originalEvent && this.originalEvent.stopImmediatePropagation();
    },
    isDefaultPrevented() {
      return !!(this._defaultPrevented || this.originalEvent && this.originalEvent.defaultPrevented);
    },
    preventDefault() {
      this._defaultPrevented = true;
      this.originalEvent && this.originalEvent.preventDefault();
    }
  });
  return eventsEngine.Event;
}
function iterate(callback) {
  const iterateEventNames = function(element, eventName) {
    if (eventName && eventName.indexOf(" ") > -1) {
      const args = Array.prototype.slice.call(arguments, 0);
      eventName.split(" ").forEach(function(eventName2) {
        args[1] = eventName2;
        callback.apply(this, args);
      });
    } else {
      callback.apply(this, arguments);
    }
  };
  return function(element, eventName) {
    if ("object" === typeof eventName) {
      const args = Array.prototype.slice.call(arguments, 0);
      for (const name2 in eventName) {
        args[1] = name2;
        args[args.length - 1] = eventName[name2];
        iterateEventNames.apply(this, args);
      }
    } else {
      iterateEventNames.apply(this, arguments);
    }
  };
}
function callNativeMethod(eventName, element) {
  const nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;
  if (function(eventName2, element2) {
    return "click" === eventName2 && "a" === element2.localName;
  }(eventName, element)) {
    return;
  }
  if (isFunction(element[nativeMethodName])) {
    skipEvent = eventName;
    element[nativeMethodName]();
    skipEvent = void 0;
  }
}
function calculateWhich(event) {
  if (function(event2) {
    return null == event2.which && 0 === event2.type.indexOf("key");
  }(event)) {
    return null != event.charCode ? event.charCode : event.keyCode;
  }
  if (function(event2) {
    return !event2.which && void 0 !== event2.button && /^(?:mouse|pointer|contextmenu|drag|drop)|click/.test(event2.type);
  }(event)) {
    const whichByButton = {
      1: 1,
      2: 3,
      3: 1,
      4: 2
    };
    return whichByButton[event.button];
  }
  return event.which;
}
function initEvent(EventClass) {
  if (EventClass) {
    eventsEngine.Event = EventClass;
    eventsEngine.Event.prototype = EventClass.prototype;
  }
}
initEvent(normalizeEventArguments(function(src, config3) {
  var _src$view;
  const srcIsEvent = src instanceof eventsEngine.Event || hasWindow() && src instanceof window2.Event || (null === (_src$view = src.view) || void 0 === _src$view ? void 0 : _src$view.Event) && src instanceof src.view.Event;
  if (srcIsEvent) {
    this.originalEvent = src;
    this.type = src.type;
    this.currentTarget = void 0;
    if (Object.prototype.hasOwnProperty.call(src, "isTrusted")) {
      this.isTrusted = src.isTrusted;
    }
    this.timeStamp = src.timeStamp || Date.now();
  } else {
    Object.assign(this, src);
  }
  addProperty("which", calculateWhich, this);
  if (0 === src.type.indexOf("touch")) {
    delete config3.pageX;
    delete config3.pageY;
  }
  Object.assign(this, config3);
  this.guid = ++guid;
}));
function addProperty(propName, hook, eventInstance) {
  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
    enumerable: true,
    configurable: true,
    get() {
      return this.originalEvent && hook(this.originalEvent);
    },
    set(value2) {
      Object.defineProperty(this, propName, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value2
      });
    }
  });
}
EVENT_PROPERTIES.forEach((prop) => addProperty(prop, (event) => event[prop]));
m_hook_touch_props_default(addProperty);
var beforeSetStrategy = callbacks_default();
var afterSetStrategy = callbacks_default();
eventsEngine.set = function(engine) {
  beforeSetStrategy.fire();
  eventsEngine.inject(engine);
  initEvent(engine.Event);
  afterSetStrategy.fire();
};
eventsEngine.subscribeGlobal = function() {
  applyForEach(arguments, normalizeOnArguments(function() {
    const args = arguments;
    eventsEngine.on.apply(this, args);
    beforeSetStrategy.add(function() {
      const offArgs = Array.prototype.slice.call(args, 0);
      offArgs.splice(3, 1);
      eventsEngine.off.apply(this, offArgs);
    });
    afterSetStrategy.add(function() {
      eventsEngine.on.apply(this, args);
    });
  }));
};
eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
var m_events_engine_default = eventsEngine;

// node_modules/devextreme/esm/__internal/core/m_element_data.js
var dataMap = /* @__PURE__ */ new WeakMap();
var strategy;
var strategyChanging = new memorized_callbacks_default();
var beforeCleanDataFunc = function() {
};
var afterCleanDataFunc = function() {
};
var setDataStrategy = function(value2) {
  strategyChanging.fire(value2);
  strategy = value2;
  const {
    cleanData: cleanData2
  } = strategy;
  strategy.cleanData = function(nodes) {
    beforeCleanDataFunc(nodes);
    const result2 = cleanData2.call(this, nodes);
    afterCleanDataFunc(nodes);
    return result2;
  };
};
setDataStrategy({
  data: function() {
    const element = arguments.length <= 0 ? void 0 : arguments[0];
    const key = arguments.length <= 1 ? void 0 : arguments[1];
    const value2 = arguments.length <= 2 ? void 0 : arguments[2];
    if (!element) {
      return;
    }
    let elementData = dataMap.get(element);
    if (!elementData) {
      elementData = {};
      dataMap.set(element, elementData);
    }
    if (void 0 === key) {
      return elementData;
    }
    if (2 === arguments.length) {
      return elementData[key];
    }
    elementData[key] = value2;
    return value2;
  },
  removeData: function(element, key) {
    if (!element) {
      return;
    }
    if (void 0 === key) {
      dataMap.delete(element);
    } else {
      const elementData = dataMap.get(element);
      if (elementData) {
        delete elementData[key];
      }
    }
  },
  cleanData: function(elements) {
    for (let i = 0; i < elements.length; i++) {
      m_events_engine_default.off(elements[i]);
      dataMap.delete(elements[i]);
    }
  }
});
function data() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return strategy.data.apply(this, args);
}
function beforeCleanData(callback) {
  beforeCleanDataFunc = callback;
}
function removeData(element, key) {
  return strategy.removeData.call(this, element, key);
}
function cleanDataRecursive(element, cleanSelf) {
  if (!dom_adapter_default.isElementNode(element)) {
    return;
  }
  const childElements = element.getElementsByTagName("*");
  strategy.cleanData(childElements);
  if (cleanSelf) {
    strategy.cleanData([element]);
  }
}

// node_modules/devextreme/esm/__internal/core/utils/m_html_parser.js
var isTagName = /<([a-z][^/\0>\x20\t\r\n\f]+)/i;
var tagWrappers = {
  default: {
    tagsCount: 0,
    startTags: "",
    endTags: ""
  },
  thead: {
    tagsCount: 1,
    startTags: "<table>",
    endTags: "</table>"
  },
  td: {
    tagsCount: 3,
    startTags: "<table><tbody><tr>",
    endTags: "</tr></tbody></table>"
  },
  col: {
    tagsCount: 2,
    startTags: "<table><colgroup>",
    endTags: "</colgroup></table>"
  },
  tr: {
    tagsCount: 2,
    startTags: "<table><tbody>",
    endTags: "</tbody></table>"
  }
};
tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
tagWrappers.th = tagWrappers.td;
var parseHTML = function(html) {
  if ("string" !== typeof html) {
    return null;
  }
  const fragment = dom_adapter_default.createDocumentFragment();
  let container = fragment.appendChild(dom_adapter_default.createElement("div"));
  const tags = isTagName.exec(html);
  const firstRootTag = null === tags || void 0 === tags ? void 0 : tags[1].toLowerCase();
  const tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
  container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;
  for (let i = 0; i < tagWrapper.tagsCount; i++) {
    container = container.lastChild;
  }
  return [...container.childNodes];
};
var isTablePart = function(html) {
  const tags = isTagName.exec(html);
  return tags && tags[1] in tagWrappers;
};

// node_modules/devextreme/esm/__internal/core/utils/m_size.js
var window3 = getWindow();
var SPECIAL_HEIGHT_VALUES = ["auto", "none", "inherit", "initial"];
var getSizeByStyles = function(elementStyles, styles) {
  let result2 = 0;
  styles.forEach(function(style) {
    result2 += parseFloat(elementStyles[style]) || 0;
  });
  return result2;
};
var getElementBoxParams = function(name2, elementStyles) {
  const beforeName = "width" === name2 ? "Left" : "Top";
  const afterName = "width" === name2 ? "Right" : "Bottom";
  return {
    padding: getSizeByStyles(elementStyles, [`padding${beforeName}`, `padding${afterName}`]),
    border: getSizeByStyles(elementStyles, [`border${beforeName}Width`, `border${afterName}Width`]),
    margin: getSizeByStyles(elementStyles, [`margin${beforeName}`, `margin${afterName}`])
  };
};
var getElementComputedStyle = function(element) {
  var _element$ownerDocumen;
  const view = (null === element || void 0 === element || null === (_element$ownerDocumen = element.ownerDocument) || void 0 === _element$ownerDocumen ? void 0 : _element$ownerDocumen.defaultView) || window3;
  return view.getComputedStyle && view.getComputedStyle(element);
};
var getCSSProperty = function(element, styles, name2, defaultValue) {
  var _element$style;
  return (null === styles || void 0 === styles ? void 0 : styles[name2]) || (null === (_element$style = element.style) || void 0 === _element$style ? void 0 : _element$style[name2]) || defaultValue;
};
var boxIndices = {
  content: 0,
  padding: 1,
  border: 2,
  margin: 3,
  "content-box": 0,
  "border-box": 2
};
var dimensionComponents = {
  width: ["left", "right"],
  height: ["top", "bottom"]
};
function getComponentThickness(elem, dimension, component, styles) {
  const get = (elem2, styles2, field) => parseFloat(getCSSProperty(elem2, styles2, field, "0")) || 0;
  const suffix = "border" === component ? "-width" : "";
  return get(elem, styles, `${component}-${dimensionComponents[dimension][0]}${suffix}`) + get(elem, styles, `${component}-${dimensionComponents[dimension][1]}${suffix}`);
}
var getSize = function(element, dimension, box) {
  const offsetFieldName = "width" === dimension ? "offsetWidth" : "offsetHeight";
  const styles = getElementComputedStyle(element);
  let result2 = getCSSProperty(element, styles, dimension);
  if ("" === result2 || "auto" === result2) {
    result2 = element[offsetFieldName];
  }
  result2 = parseFloat(result2) || 0;
  const currentBox = getCSSProperty(element, styles, "boxSizing", "content-box");
  const targetBox = box || currentBox;
  let targetBoxIndex = boxIndices[targetBox];
  let currentBoxIndex = boxIndices[currentBox];
  if (void 0 === targetBoxIndex || void 0 === currentBoxIndex) {
    throw new Error();
  }
  if (currentBoxIndex === targetBoxIndex) {
    return result2;
  }
  const coeff = Math.sign(targetBoxIndex - currentBoxIndex);
  let padding = false;
  let border = false;
  let margin = false;
  let scrollThickness = false;
  if (1 === coeff) {
    targetBoxIndex += 1;
    currentBoxIndex += 1;
  }
  for (let boxPart = currentBoxIndex; boxPart !== targetBoxIndex; boxPart += coeff) {
    switch (boxPart) {
      case boxIndices.content:
        break;
      case boxIndices.padding:
        padding = coeff * getComponentThickness(element, dimension, "padding", styles);
        break;
      case boxIndices.border:
        border = coeff * getComponentThickness(element, dimension, "border", styles);
        break;
      case boxIndices.margin:
        margin = coeff * getComponentThickness(element, dimension, "margin", styles);
    }
  }
  if (padding || border) {
    const paddingAndBorder = (false === padding ? coeff * getComponentThickness(element, dimension, "padding", styles) : padding) + (false === border ? coeff * getComponentThickness(element, dimension, "border", styles) : border);
    scrollThickness = coeff * Math.max(0, Math.floor(element[offsetFieldName] - result2 - coeff * paddingAndBorder)) || 0;
  }
  return result2 + margin + padding + border + scrollThickness;
};
var getContainerHeight = function(container) {
  return isWindow(container) ? container.innerHeight : container.offsetHeight;
};
var parseHeight = function(value2, container, element) {
  if (value2.indexOf("px") > 0) {
    value2 = parseInt(value2.replace("px", ""));
  } else if (value2.indexOf("%") > 0) {
    value2 = parseInt(value2.replace("%", "")) * getContainerHeight(container) / 100;
  } else if (!isNaN(value2)) {
    value2 = parseInt(value2);
  } else if (value2.indexOf("vh") > 0) {
    value2 = window3.innerHeight / 100 * parseInt(value2.replace("vh", ""));
  } else if (element && value2.indexOf("em") > 0) {
    value2 = parseFloat(value2.replace("em", "")) * parseFloat(window3.getComputedStyle(element).fontSize);
  }
  return value2;
};
var getHeightWithOffset = function(value2, offset2, container) {
  if (!value2) {
    return null;
  }
  if (SPECIAL_HEIGHT_VALUES.includes(value2)) {
    return offset2 ? null : value2;
  }
  if (isString(value2)) {
    value2 = parseHeight(value2, container);
  }
  if (isNumeric(value2)) {
    return Math.max(0, value2 + offset2);
  }
  const operationString = offset2 < 0 ? " - " : " ";
  return `calc(${value2}${operationString}${Math.abs(offset2)}px)`;
};
var addOffsetToMaxHeight = function(value2, offset2, container) {
  const maxHeight = getHeightWithOffset(value2, offset2, container);
  return null !== maxHeight ? maxHeight : "none";
};
var addOffsetToMinHeight = function(value2, offset2, container) {
  const minHeight = getHeightWithOffset(value2, offset2, container);
  return null !== minHeight ? minHeight : 0;
};
var getVerticalOffsets = function(element, withMargins) {
  if (!element) {
    return 0;
  }
  const boxParams = getElementBoxParams("height", window3.getComputedStyle(element));
  return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0);
};
var getVisibleHeight = function(element) {
  if (element) {
    var _element$getBoundingC;
    const boundingClientRect = null === (_element$getBoundingC = element.getBoundingClientRect) || void 0 === _element$getBoundingC ? void 0 : _element$getBoundingC.call(element);
    if (null !== boundingClientRect && void 0 !== boundingClientRect && boundingClientRect.height) {
      return boundingClientRect.height;
    }
  }
  return 0;
};
var implementationsMap = {
  getWidth: function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return elementSizeHelper("width", ...args);
  },
  setWidth: function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return elementSizeHelper("width", ...args);
  },
  getHeight: function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return elementSizeHelper("height", ...args);
  },
  setHeight: function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return elementSizeHelper("height", ...args);
  },
  getOuterWidth: function() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return elementSizeHelper("outerWidth", ...args);
  },
  setOuterWidth: function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return elementSizeHelper("outerWidth", ...args);
  },
  getOuterHeight: function() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return elementSizeHelper("outerHeight", ...args);
  },
  setOuterHeight: function() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return elementSizeHelper("outerHeight", ...args);
  },
  getInnerWidth: function() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return elementSizeHelper("innerWidth", ...args);
  },
  setInnerWidth: function() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return elementSizeHelper("innerWidth", ...args);
  },
  getInnerHeight: function() {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }
    return elementSizeHelper("innerHeight", ...args);
  },
  setInnerHeight: function() {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return elementSizeHelper("innerHeight", ...args);
  }
};
function elementSizeHelper(sizeProperty, el, value2) {
  return 2 === arguments.length ? elementSize(el, sizeProperty) : elementSize(el, sizeProperty, value2);
}
var getWidth = (el) => implementationsMap.getWidth(el);
var setWidth = (el, value2) => implementationsMap.setWidth(el, value2);
var getHeight = (el) => implementationsMap.getHeight(el);
var setHeight = (el, value2) => implementationsMap.setHeight(el, value2);
var getOuterWidth = (el, includeMargin) => implementationsMap.getOuterWidth(el, includeMargin || false);
var getOuterHeight = (el, includeMargin) => implementationsMap.getOuterHeight(el, includeMargin || false);
var getInnerWidth = (el) => implementationsMap.getInnerWidth(el);
var getInnerHeight = (el) => implementationsMap.getInnerHeight(el);
var elementSize = function(el, sizeProperty, value2) {
  const partialName = sizeProperty.toLowerCase().indexOf("width") >= 0 ? "Width" : "Height";
  const propName = partialName.toLowerCase();
  const isOuter = 0 === sizeProperty.indexOf("outer");
  const isInner = 0 === sizeProperty.indexOf("inner");
  const isGetter = 2 === arguments.length || "boolean" === typeof value2;
  if (isRenderer(el)) {
    if (el.length > 1 && !isGetter) {
      for (let i = 0; i < el.length; i++) {
        elementSize(el[i], sizeProperty, value2);
      }
      return;
    }
    el = el[0];
  }
  if (!el) {
    return;
  }
  if (isWindow(el)) {
    return isOuter ? el[`inner${partialName}`] : dom_adapter_default.getDocumentElement()[`client${partialName}`];
  }
  if (dom_adapter_default.isDocument(el)) {
    const documentElement = dom_adapter_default.getDocumentElement();
    const body = dom_adapter_default.getBody();
    return Math.max(body[`scroll${partialName}`], body[`offset${partialName}`], documentElement[`scroll${partialName}`], documentElement[`offset${partialName}`], documentElement[`client${partialName}`]);
  }
  if (isGetter) {
    let box = "content";
    if (isOuter) {
      box = value2 ? "margin" : "border";
    }
    if (isInner) {
      box = "padding";
    }
    return getSize(el, propName, box);
  }
  if (isNumeric(value2)) {
    const elementStyles = getElementComputedStyle(el);
    const sizeAdjustment = getElementBoxParams(propName, elementStyles);
    const isBorderBox = "border-box" === elementStyles.boxSizing;
    value2 = Number(value2);
    if (isOuter) {
      value2 -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding;
    } else if (isInner) {
      value2 += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding;
    } else if (isBorderBox) {
      value2 += sizeAdjustment.border + sizeAdjustment.padding;
    }
  }
  value2 += isNumeric(value2) ? "px" : "";
  dom_adapter_default.setStyle(el, propName, value2);
  return null;
};
var getWindowByElement = (el) => isWindow(el) ? el : el.defaultView;
var getOffset = (el) => {
  if (!el.getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  }
  const rect = el.getBoundingClientRect();
  const win = getWindowByElement(el.ownerDocument);
  const docElem = el.ownerDocument.documentElement;
  return {
    top: rect.top + win.pageYOffset - docElem.clientTop,
    left: rect.left + win.pageXOffset - docElem.clientLeft
  };
};

// node_modules/devextreme/esm/__internal/core/utils/m_inflector.js
var _normalize = function(text) {
  if (void 0 === text || null === text) {
    return "";
  }
  return String(text);
};
var _upperCaseFirst = function(text) {
  return _normalize(text).charAt(0).toUpperCase() + text.substr(1);
};
var _chop = function(text) {
  return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/);
};
var dasherize = function(text) {
  return map(_chop(text), function(p2) {
    return p2.toLowerCase();
  }).join("-");
};
var camelize = function(text, upperFirst) {
  return map(_chop(text), function(p2, i) {
    p2 = p2.toLowerCase();
    if (upperFirst || i > 0) {
      p2 = _upperCaseFirst(p2);
    }
    return p2;
  }).join("");
};
var humanize = function(text) {
  return _upperCaseFirst(dasherize(text).replace(/-/g, " "));
};

// node_modules/devextreme/esm/__internal/core/utils/m_style.js
var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"];
var cssPrefixes = {
  "": "",
  Webkit: "-webkit-",
  Moz: "-moz-",
  O: "-o-",
  ms: "-ms-"
};
var getStyles = call_once_default(function() {
  return dom_adapter_default.createElement("dx").style;
});
var forEachPrefixes = function(prop, callBack) {
  prop = camelize(prop, true);
  let result2;
  for (let i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
    const jsPrefix = jsPrefixes[i];
    const prefixedProp = jsPrefix + prop;
    const lowerPrefixedProp = camelize(prefixedProp);
    result2 = callBack(lowerPrefixedProp, jsPrefix);
    if (void 0 === result2) {
      result2 = callBack(prefixedProp, jsPrefix);
    }
    if (void 0 !== result2) {
      break;
    }
  }
  return result2 || "";
};
var styleProp = function(name2) {
  if (name2 in getStyles()) {
    return name2;
  }
  const originalName = name2;
  name2 = name2.charAt(0).toUpperCase() + name2.substr(1);
  for (let i = 1; i < jsPrefixes.length; i++) {
    const prefixedProp = jsPrefixes[i].toLowerCase() + name2;
    if (prefixedProp in getStyles()) {
      return prefixedProp;
    }
  }
  return originalName;
};
var stylePropPrefix = function(prop) {
  return forEachPrefixes(prop, function(specific, jsPrefix) {
    if (specific in getStyles()) {
      return cssPrefixes[jsPrefix];
    }
  });
};
var pxExceptions = ["fillOpacity", "columnCount", "flexGrow", "flexShrink", "fontWeight", "lineHeight", "opacity", "zIndex", "zoom"];
var normalizeStyleProp = function(prop, value2) {
  if (isNumeric(value2) && !pxExceptions.includes(prop)) {
    value2 += "px";
  }
  return value2;
};
var setStyle = function(element, styleString) {
  let resetStyle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
  if (resetStyle) {
    const styleList = [].slice.call(element.style);
    styleList.forEach((propertyName) => {
      element.style.removeProperty(propertyName);
    });
  }
  styleString.split(";").forEach((style) => {
    const parts = style.split(":").map((stylePart) => stylePart.trim());
    if (2 === parts.length) {
      const [property, value2] = parts;
      element.style[property] = value2;
    }
  });
};

// node_modules/devextreme/esm/__internal/core/m_renderer_base.js
var window4 = getWindow();
var renderer;
var initRender = function(selector, context2) {
  if (!selector) {
    this.length = 0;
    return this;
  }
  if ("string" === typeof selector) {
    if ("body" === selector) {
      this[0] = context2 ? context2.body : dom_adapter_default.getBody();
      this.length = 1;
      return this;
    }
    context2 = context2 || dom_adapter_default.getDocument();
    if (selector.startsWith("<")) {
      this[0] = dom_adapter_default.createElement(selector.slice(1, -1), context2);
      this.length = 1;
      return this;
    }
    [].push.apply(this, dom_adapter_default.querySelectorAll(context2, selector));
    return this;
  }
  if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
    this[0] = selector;
    this.length = 1;
    return this;
  }
  if (Array.isArray(selector)) {
    [].push.apply(this, selector);
    return this;
  }
  return renderer(selector.toArray ? selector.toArray() : [selector]);
};
renderer = function(selector, context2) {
  return new initRender(selector, context2);
};
renderer.fn = {
  dxRenderer: true
};
initRender.prototype = renderer.fn;
var repeatMethod = function(methodName, args) {
  for (let i = 0; i < this.length; i++) {
    const item = renderer(this[i]);
    item[methodName].apply(item, args);
  }
  return this;
};
var setAttributeValue = function(element, attrName, value2) {
  if (void 0 !== value2 && null !== value2 && false !== value2) {
    dom_adapter_default.setAttribute(element, attrName, value2);
  } else {
    dom_adapter_default.removeAttribute(element, attrName);
  }
};
initRender.prototype.show = function() {
  return this.toggle(true);
};
initRender.prototype.hide = function() {
  return this.toggle(false);
};
initRender.prototype.toggle = function(value2) {
  if (this[0]) {
    this.toggleClass("dx-state-invisible", !value2);
  }
  return this;
};
initRender.prototype.attr = function(attrName, value2) {
  if (this.length > 1 && arguments.length > 1) {
    return repeatMethod.call(this, "attr", arguments);
  }
  if (!this[0]) {
    if (isObject(attrName) || void 0 !== value2) {
      return this;
    }
    return;
  }
  if (!this[0].getAttribute) {
    return this.prop(attrName, value2);
  }
  if ("string" === typeof attrName && 1 === arguments.length) {
    const result2 = this[0].getAttribute(attrName);
    return null == result2 ? void 0 : result2;
  }
  if (isPlainObject(attrName)) {
    for (const key in attrName) {
      this.attr(key, attrName[key]);
    }
  } else {
    setAttributeValue(this[0], attrName, value2);
  }
  return this;
};
initRender.prototype.removeAttr = function(attrName) {
  this.each(function(_, element) {
    dom_adapter_default.removeAttribute(element, attrName);
  });
  return this;
};
initRender.prototype.prop = function(propName, value2) {
  if (!this[0]) {
    return this;
  }
  if ("string" === typeof propName && 1 === arguments.length) {
    return this[0][propName];
  }
  if (isPlainObject(propName)) {
    for (const key in propName) {
      this.prop(key, propName[key]);
    }
  } else {
    dom_adapter_default.setProperty(this[0], propName, value2);
  }
  return this;
};
initRender.prototype.addClass = function(className) {
  return this.toggleClass(className, true);
};
initRender.prototype.removeClass = function(className) {
  return this.toggleClass(className, false);
};
initRender.prototype.hasClass = function(className) {
  if (!this[0] || void 0 === this[0].className) {
    return false;
  }
  const classNames = className.split(" ");
  for (let i = 0; i < classNames.length; i++) {
    if (this[0].classList) {
      if (this[0].classList.contains(classNames[i])) {
        return true;
      }
    } else {
      const className2 = isString(this[0].className) ? this[0].className : dom_adapter_default.getAttribute(this[0], "class");
      if ((className2 || "").split(" ").indexOf(classNames[i]) >= 0) {
        return true;
      }
    }
  }
  return false;
};
initRender.prototype.toggleClass = function(className, value2) {
  if (this.length > 1) {
    return repeatMethod.call(this, "toggleClass", arguments);
  }
  if (!this[0] || !className) {
    return this;
  }
  value2 = void 0 === value2 ? !this.hasClass(className) : value2;
  const classNames = className.split(" ");
  for (let i = 0; i < classNames.length; i++) {
    dom_adapter_default.setClass(this[0], classNames[i], value2);
  }
  return this;
};
initRender.prototype.html = function(value2) {
  if (!arguments.length) {
    return this[0].innerHTML;
  }
  this.empty();
  if ("string" === typeof value2 && !isTablePart(value2) || "number" === typeof value2) {
    this[0].innerHTML = value2;
    return this;
  }
  return this.append(parseHTML(value2));
};
var appendElements = function(element, nextSibling) {
  if (!this[0] || !element) {
    return;
  }
  if ("string" === typeof element) {
    element = parseHTML(element);
  } else if (element.nodeType) {
    element = [element];
  } else if (isNumeric(element)) {
    element = [dom_adapter_default.createTextNode(element)];
  }
  for (let i = 0; i < element.length; i++) {
    const item = element[i];
    let container = this[0];
    const wrapTR = "TABLE" === container.tagName && "TR" === item.tagName;
    if (wrapTR && container.tBodies && container.tBodies.length) {
      container = container.tBodies[0];
    }
    dom_adapter_default.insertElement(container, item.nodeType ? item : item[0], nextSibling);
  }
};
var setCss = function(name2, value2) {
  if (!this[0] || !this[0].style) {
    return;
  }
  if (null === value2 || "number" === typeof value2 && isNaN(value2)) {
    return;
  }
  name2 = styleProp(name2);
  for (let i = 0; i < this.length; i++) {
    this[i].style[name2] = normalizeStyleProp(name2, value2);
  }
};
initRender.prototype.css = function(name2, value2) {
  if (isString(name2)) {
    if (2 === arguments.length) {
      setCss.call(this, name2, value2);
    } else {
      if (!this[0]) {
        return;
      }
      name2 = styleProp(name2);
      const result2 = window4.getComputedStyle(this[0])[name2] || this[0].style[name2];
      return isNumeric(result2) ? result2.toString() : result2;
    }
  } else if (isPlainObject(name2)) {
    for (const key in name2) {
      setCss.call(this, key, name2[key]);
    }
  }
  return this;
};
initRender.prototype.prepend = function(element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.prepend(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element, this[0].firstChild]);
  return this;
};
initRender.prototype.append = function(element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.append(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element]);
  return this;
};
initRender.prototype.prependTo = function(element) {
  if (this.length > 1) {
    for (let i = this.length - 1; i >= 0; i--) {
      renderer(this[i]).prependTo(element);
    }
    return this;
  }
  element = renderer(element);
  if (element[0]) {
    dom_adapter_default.insertElement(element[0], this[0], element[0].firstChild);
  }
  return this;
};
initRender.prototype.appendTo = function(element) {
  if (this.length > 1) {
    return repeatMethod.call(this, "appendTo", arguments);
  }
  dom_adapter_default.insertElement(renderer(element)[0], this[0]);
  return this;
};
initRender.prototype.insertBefore = function(element) {
  if (element && element[0]) {
    dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0]);
  }
  return this;
};
initRender.prototype.insertAfter = function(element) {
  if (element && element[0]) {
    dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0].nextSibling);
  }
  return this;
};
initRender.prototype.before = function(element) {
  if (this[0]) {
    dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0]);
  }
  return this;
};
initRender.prototype.after = function(element) {
  if (this[0]) {
    dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0].nextSibling);
  }
  return this;
};
initRender.prototype.wrap = function(wrapper) {
  if (this[0]) {
    const wrap = renderer(wrapper);
    wrap.insertBefore(this);
    wrap.append(this);
  }
  return this;
};
initRender.prototype.wrapInner = function(wrapper) {
  const contents = this.contents();
  if (contents.length) {
    contents.wrap(wrapper);
  } else {
    this.append(wrapper);
  }
  return this;
};
initRender.prototype.replaceWith = function(element) {
  if (!(element && element[0])) {
    return;
  }
  if (element.is(this)) {
    return this;
  }
  element.insertBefore(this);
  this.remove();
  return element;
};
initRender.prototype.remove = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "remove", arguments);
  }
  cleanDataRecursive(this[0], true);
  dom_adapter_default.removeElement(this[0]);
  return this;
};
initRender.prototype.detach = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "detach", arguments);
  }
  dom_adapter_default.removeElement(this[0]);
  return this;
};
initRender.prototype.empty = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "empty", arguments);
  }
  cleanDataRecursive(this[0]);
  dom_adapter_default.setText(this[0], "");
  return this;
};
initRender.prototype.clone = function() {
  const result2 = [];
  for (let i = 0; i < this.length; i++) {
    result2.push(this[i].cloneNode(true));
  }
  return renderer(result2);
};
initRender.prototype.text = function(value2) {
  if (!arguments.length) {
    let result2 = "";
    for (let i = 0; i < this.length; i++) {
      result2 += this[i] && this[i].textContent || "";
    }
    return result2;
  }
  const text = isFunction(value2) ? value2() : value2;
  cleanDataRecursive(this[0], false);
  dom_adapter_default.setText(this[0], isDefined(text) ? text : "");
  return this;
};
initRender.prototype.val = function(value2) {
  if (1 === arguments.length) {
    return this.prop("value", isDefined(value2) ? value2 : "");
  }
  return this.prop("value");
};
initRender.prototype.contents = function() {
  if (!this[0]) {
    return renderer();
  }
  const result2 = [];
  result2.push.apply(result2, this[0].childNodes);
  return renderer(result2);
};
initRender.prototype.find = function(selector) {
  const result2 = renderer();
  if (!selector) {
    return result2;
  }
  const nodes = [];
  let i;
  if ("string" === typeof selector) {
    selector = selector.trim();
    for (i = 0; i < this.length; i++) {
      const element = this[i];
      if (dom_adapter_default.isElementNode(element)) {
        const elementId = element.getAttribute("id");
        let queryId = elementId || "dx-query-children";
        if (!elementId) {
          setAttributeValue(element, "id", queryId);
        }
        queryId = `[id='${queryId}'] `;
        const querySelector = queryId + selector.replace(/([^\\])(,)/g, `$1, ${queryId}`);
        nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, querySelector));
        setAttributeValue(element, "id", elementId);
      } else if (dom_adapter_default.isDocument(element) || dom_adapter_default.isDocumentFragment(element)) {
        nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, selector));
      }
    }
  } else {
    for (i = 0; i < this.length; i++) {
      selector = dom_adapter_default.isNode(selector) ? selector : selector[0];
      if (this[i] !== selector && this[i].contains(selector)) {
        nodes.push(selector);
      }
    }
  }
  return result2.add(nodes);
};
var isVisible = function(_, element) {
  var _element$getClientRec, _element;
  element = element.host ?? element;
  if (!element.nodeType) {
    return true;
  }
  return !!(element.offsetWidth || element.offsetHeight || null !== (_element$getClientRec = (_element = element).getClientRects) && void 0 !== _element$getClientRec && _element$getClientRec.call(_element).length);
};
initRender.prototype.filter = function(selector) {
  if (!selector) {
    return renderer();
  }
  if (":visible" === selector) {
    return this.filter(isVisible);
  }
  if (":hidden" === selector) {
    return this.filter(function(_, element) {
      return !isVisible(0, element);
    });
  }
  const result2 = [];
  for (let i = 0; i < this.length; i++) {
    const item = this[i];
    if (dom_adapter_default.isElementNode(item) && "string" === type(selector)) {
      dom_adapter_default.elementMatches(item, selector) && result2.push(item);
    } else if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
      selector === item && result2.push(item);
    } else if (isFunction(selector)) {
      selector.call(item, i, item) && result2.push(item);
    } else {
      for (let j = 0; j < selector.length; j++) {
        selector[j] === item && result2.push(item);
      }
    }
  }
  return renderer(result2);
};
initRender.prototype.not = function(selector) {
  const result2 = [];
  const nodes = this.filter(selector).toArray();
  for (let i = 0; i < this.length; i++) {
    if (-1 === nodes.indexOf(this[i])) {
      result2.push(this[i]);
    }
  }
  return renderer(result2);
};
initRender.prototype.is = function(selector) {
  return !!this.filter(selector).length;
};
initRender.prototype.children = function(selector) {
  let result2 = [];
  for (let i = 0; i < this.length; i++) {
    const nodes = this[i] ? this[i].childNodes : [];
    for (let j = 0; j < nodes.length; j++) {
      if (dom_adapter_default.isElementNode(nodes[j])) {
        result2.push(nodes[j]);
      }
    }
  }
  result2 = renderer(result2);
  return selector ? result2.filter(selector) : result2;
};
initRender.prototype.siblings = function() {
  const element = this[0];
  if (!element || !element.parentNode) {
    return renderer();
  }
  const result2 = [];
  const parentChildNodes = element.parentNode.childNodes || [];
  for (let i = 0; i < parentChildNodes.length; i++) {
    const node = parentChildNodes[i];
    if (dom_adapter_default.isElementNode(node) && node !== element) {
      result2.push(node);
    }
  }
  return renderer(result2);
};
initRender.prototype.each = function(callback) {
  for (let i = 0; i < this.length; i++) {
    if (false === callback.call(this[i], i, this[i])) {
      break;
    }
  }
};
initRender.prototype.index = function(element) {
  if (!element) {
    return this.parent().children().index(this);
  }
  element = renderer(element);
  return this.toArray().indexOf(element[0]);
};
initRender.prototype.get = function(index2) {
  return this[index2 < 0 ? this.length + index2 : index2];
};
initRender.prototype.eq = function(index2) {
  index2 = index2 < 0 ? this.length + index2 : index2;
  return renderer(this[index2]);
};
initRender.prototype.first = function() {
  return this.eq(0);
};
initRender.prototype.last = function() {
  return this.eq(-1);
};
initRender.prototype.select = function() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].select && this[i].select();
  }
  return this;
};
initRender.prototype.parent = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  const result2 = renderer(this[0].parentNode);
  return !selector || result2.is(selector) ? result2 : renderer();
};
initRender.prototype.parents = function(selector) {
  const result2 = [];
  let parent = this.parent();
  while (parent && parent[0] && !dom_adapter_default.isDocument(parent[0])) {
    if (dom_adapter_default.isElementNode(parent[0])) {
      if (!selector || parent.is(selector)) {
        result2.push(parent.get(0));
      }
    }
    parent = parent.parent();
  }
  return renderer(result2);
};
initRender.prototype.closest = function(selector) {
  if (this.is(selector)) {
    return this;
  }
  let parent = this.parent();
  while (parent && parent.length) {
    if (parent.is(selector)) {
      return parent;
    }
    parent = parent.parent();
  }
  return renderer();
};
initRender.prototype.next = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  let next = renderer(this[0].nextSibling);
  if (!arguments.length) {
    return next;
  }
  while (next && next.length) {
    if (next.is(selector)) {
      return next;
    }
    next = next.next();
  }
  return renderer();
};
initRender.prototype.prev = function() {
  if (!this[0]) {
    return renderer();
  }
  return renderer(this[0].previousSibling);
};
initRender.prototype.add = function(selector) {
  const targets = renderer(selector);
  const result2 = this.toArray();
  for (let i = 0; i < targets.length; i++) {
    const target = targets[i];
    if (-1 === result2.indexOf(target)) {
      result2.push(target);
    }
  }
  return renderer(result2);
};
var emptyArray = [];
initRender.prototype.splice = function() {
  return renderer(emptyArray.splice.apply(this, arguments));
};
initRender.prototype.slice = function() {
  return renderer(emptyArray.slice.apply(this, arguments));
};
initRender.prototype.toArray = function() {
  return emptyArray.slice.call(this);
};
initRender.prototype.offset = function() {
  if (!this[0]) {
    return;
  }
  return getOffset(this[0]);
};
initRender.prototype.offsetParent = function() {
  if (!this[0]) {
    return renderer();
  }
  let offsetParent = renderer(this[0].offsetParent);
  while (offsetParent[0] && "static" === offsetParent.css("position")) {
    offsetParent = renderer(offsetParent[0].offsetParent);
  }
  offsetParent = offsetParent[0] ? offsetParent : renderer(dom_adapter_default.getDocumentElement());
  return offsetParent;
};
initRender.prototype.position = function() {
  if (!this[0]) {
    return;
  }
  let offset2;
  const marginTop = parseFloat(this.css("marginTop"));
  const marginLeft = parseFloat(this.css("marginLeft"));
  if ("fixed" === this.css("position")) {
    offset2 = this[0].getBoundingClientRect();
    return {
      top: offset2.top - marginTop,
      left: offset2.left - marginLeft
    };
  }
  offset2 = this.offset();
  const offsetParent = this.offsetParent();
  let parentOffset = {
    top: 0,
    left: 0
  };
  if ("HTML" !== offsetParent[0].nodeName) {
    parentOffset = offsetParent.offset();
  }
  parentOffset = {
    top: parentOffset.top + parseFloat(offsetParent.css("borderTopWidth")),
    left: parentOffset.left + parseFloat(offsetParent.css("borderLeftWidth"))
  };
  return {
    top: offset2.top - parentOffset.top - marginTop,
    left: offset2.left - parentOffset.left - marginLeft
  };
};
[{
  name: "scrollLeft",
  offsetProp: "pageXOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(value2, win.pageYOffset);
  }
}, {
  name: "scrollTop",
  offsetProp: "pageYOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(win.pageXOffset, value2);
  }
}].forEach(function(directionStrategy) {
  const propName = directionStrategy.name;
  initRender.prototype[propName] = function(value2) {
    if (!this[0]) {
      return;
    }
    const window21 = getWindowByElement(this[0]);
    if (void 0 === value2) {
      return window21 ? window21[directionStrategy.offsetProp] : this[0][propName];
    }
    if (window21) {
      directionStrategy.scrollWindow(window21, value2);
    } else {
      this[0][propName] = value2;
    }
    return this;
  };
});
initRender.prototype.data = function(key, value2) {
  if (!this[0]) {
    return;
  }
  if (arguments.length < 2) {
    return data.call(renderer, this[0], key);
  }
  data.call(renderer, this[0], key, value2);
  return this;
};
initRender.prototype.removeData = function(key) {
  this[0] && removeData(this[0], key);
  return this;
};
var rendererWrapper = function() {
  return renderer.apply(this, arguments);
};
Object.defineProperty(rendererWrapper, "fn", {
  enumerable: true,
  configurable: true,
  get: function() {
    return renderer.fn;
  },
  set: function(value2) {
    renderer.fn = value2;
  }
});
var m_renderer_base_default = {
  set: function(strategy3) {
    renderer = strategy3;
  },
  get: function() {
    return rendererWrapper;
  }
};

// node_modules/devextreme/esm/__internal/core/m_renderer.js
var renderer2 = m_renderer_base_default.get();

// node_modules/devextreme/esm/core/renderer.js
var renderer_default = renderer2;

// node_modules/devextreme/esm/__internal/events/core/m_event_registrator.js
var registerEvent = function(name2, eventObject) {
  const strategy3 = {};
  if ("noBubble" in eventObject) {
    strategy3.noBubble = eventObject.noBubble;
  }
  if ("bindType" in eventObject) {
    strategy3.bindType = eventObject.bindType;
  }
  if ("delegateType" in eventObject) {
    strategy3.delegateType = eventObject.delegateType;
  }
  each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], (_, methodName) => {
    if (!eventObject[methodName]) {
      return;
    }
    strategy3[methodName] = function() {
      const args = [].slice.call(arguments);
      args.unshift(this);
      return eventObject[methodName].apply(eventObject, args);
    };
  });
  event_registrator_callbacks_default.fire(name2, strategy3);
};
registerEvent.callbacks = event_registrator_callbacks_default;
var m_event_registrator_default = registerEvent;

// node_modules/devextreme/esm/__internal/events/m_remove.js
var removeEvent = "dxremove";
var eventPropName = "dxRemoveEvent";
beforeCleanData((elements) => {
  elements = [].slice.call(elements);
  for (let i = 0; i < elements.length; i++) {
    const $element = renderer_default(elements[i]);
    if ($element.prop(eventPropName)) {
      $element[0][eventPropName] = null;
      m_events_engine_default.triggerHandler($element, "dxremove");
    }
  }
});
m_event_registrator_default("dxremove", {
  noBubble: true,
  setup(element) {
    renderer_default(element).prop(eventPropName, true);
  }
});

// node_modules/devextreme/esm/__internal/core/utils/m_public_component.js
var componentNames = /* @__PURE__ */ new WeakMap();
var nextAnonymousComponent = 0;
var getName = function(componentClass, newName) {
  if (isDefined(newName)) {
    componentNames.set(componentClass, newName);
    return;
  }
  if (!componentNames.has(componentClass)) {
    const generatedName = "dxPrivateComponent" + nextAnonymousComponent++;
    componentNames.set(componentClass, generatedName);
    return generatedName;
  }
  return componentNames.get(componentClass);
};
function attachInstanceToElement($element, componentInstance, disposeFn) {
  const data2 = data($element.get(0));
  const name2 = getName(componentInstance.constructor);
  data2[name2] = componentInstance;
  if (disposeFn) {
    m_events_engine_default.one($element, removeEvent, function() {
      disposeFn.call(componentInstance);
    });
  }
  if (!data2.dxComponents) {
    data2.dxComponents = [];
  }
  data2.dxComponents.push(name2);
}
function getInstanceByElement($element, componentClass) {
  const name2 = getName(componentClass);
  return data($element.get(0), name2);
}

// node_modules/devextreme/esm/__internal/core/m_component_registrator.js
var registerComponent = function(name2, namespace, componentClass) {
  if (!componentClass) {
    componentClass = namespace;
  } else {
    namespace[name2] = componentClass;
  }
  getName(componentClass, name2);
  component_registrator_callbacks_default.fire(name2, componentClass);
};
var registerRendererComponent = function(name2, componentClass) {
  renderer_default.fn[name2] = function(options2) {
    const isMemberInvoke = "string" === typeof options2;
    let result2;
    if (isMemberInvoke) {
      const memberName = options2;
      const memberArgs = [].slice.call(arguments).slice(1);
      this.each(function() {
        const instance = componentClass.getInstance(this);
        if (!instance) {
          throw errors_default.Error("E0009", name2);
        }
        const member = instance[memberName];
        const memberValue = member.apply(instance, memberArgs);
        if (void 0 === result2) {
          result2 = memberValue;
        }
      });
    } else {
      this.each(function() {
        const instance = componentClass.getInstance(this);
        if (instance) {
          instance.option(options2);
        } else {
          new componentClass(this, options2);
        }
      });
      result2 = this;
    }
    return result2;
  };
};
component_registrator_callbacks_default.add(registerRendererComponent);

// node_modules/devextreme/esm/core/component_registrator.js
var component_registrator_default = registerComponent;

// node_modules/devextreme/esm/__internal/core/utils/m_position.js
var getBoundingRect = (element) => {
  var _element$getBoundingC;
  if (isWindow(element)) {
    return {
      width: element.outerWidth,
      height: element.outerHeight
    };
  }
  return null === (_element$getBoundingC = element.getBoundingClientRect) || void 0 === _element$getBoundingC ? void 0 : _element$getBoundingC.call(element);
};

// node_modules/devextreme/esm/__internal/core/utils/m_browser.js
var navigator = getNavigator();
var webkitRegExp = /(webkit)[ /]([\w.]+)/;
var mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
var browserFromUA = (ua) => {
  ua = ua.toLowerCase();
  const result2 = {};
  const matches = webkitRegExp.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || [];
  let browserName = matches[1];
  let browserVersion = matches[2];
  if ("webkit" === browserName) {
    result2.webkit = true;
    if (ua.indexOf("chrome") >= 0 || ua.indexOf("crios") >= 0) {
      browserName = "chrome";
      browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf("fxios") >= 0) {
      browserName = "mozilla";
      browserVersion = /fxios\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf("safari") >= 0 && /version|phantomjs/.test(ua)) {
      browserName = "safari";
      browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else {
      browserName = "unknown";
      browserVersion = /applewebkit\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    }
  }
  if (browserName) {
    result2[browserName] = true;
    result2.version = browserVersion;
  }
  return result2;
};
var browser = extend({
  _fromUA: browserFromUA
}, browserFromUA(navigator.userAgent));

// node_modules/devextreme/esm/core/utils/browser.js
var browser_default = browser;

// node_modules/devextreme/esm/common/core/animation/translator.js
var TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
var TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
var locate = function($element) {
  $element = renderer_default($element);
  const translate = getTranslate($element);
  return {
    left: translate.x,
    top: translate.y
  };
};
function isPercentValue(value2) {
  return "string" === type(value2) && "%" === value2[value2.length - 1];
}
function cacheTranslate($element, translate) {
  if ($element.length) {
    data($element.get(0), "dxTranslator", translate);
  }
}
var clearCache = function($element) {
  if ($element.length) {
    removeData($element.get(0), "dxTranslator");
  }
};
var getTranslateCss = function(translate) {
  translate.x = translate.x || 0;
  translate.y = translate.y || 0;
  const xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
  const yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
  return "translate(" + xValueString + ", " + yValueString + ")";
};
var getTranslate = function($element) {
  let result2 = $element.length ? data($element.get(0), "dxTranslator") : null;
  if (!result2) {
    const transformValue = $element.css("transform") || getTranslateCss({
      x: 0,
      y: 0
    });
    let matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
    const is3D = matrix && matrix[1];
    if (matrix) {
      matrix = matrix[2].split(",");
      if ("3d" === is3D) {
        matrix = matrix.slice(12, 15);
      } else {
        matrix.push(0);
        matrix = matrix.slice(4, 7);
      }
    } else {
      matrix = [0, 0, 0];
    }
    result2 = {
      x: parseFloat(matrix[0]),
      y: parseFloat(matrix[1]),
      z: parseFloat(matrix[2])
    };
    cacheTranslate($element, result2);
  }
  return result2;
};
var move = function($element, position2) {
  $element = renderer_default($element);
  const left = position2.left;
  const top = position2.top;
  let translate;
  if (void 0 === left) {
    translate = getTranslate($element);
    translate.y = top || 0;
  } else if (void 0 === top) {
    translate = getTranslate($element);
    translate.x = left || 0;
  } else {
    translate = {
      x: left || 0,
      y: top || 0,
      z: 0
    };
    cacheTranslate($element, translate);
  }
  $element.css({
    transform: getTranslateCss(translate)
  });
  if (isPercentValue(left) || isPercentValue(top)) {
    clearCache($element);
  }
};
var resetPosition = function($element, finishTransition) {
  $element = renderer_default($element);
  let originalTransition;
  const stylesConfig = {
    left: 0,
    top: 0,
    transform: "none"
  };
  if (finishTransition) {
    originalTransition = $element.css("transition");
    stylesConfig.transition = "none";
  }
  $element.css(stylesConfig);
  clearCache($element);
  if (finishTransition) {
    $element.get(0).offsetHeight;
    $element.css("transition", originalTransition);
  }
};
var parseTranslate = function(translateString) {
  let result2 = translateString.match(TRANSLATE_REGEX);
  if (!result2 || !result2[1]) {
    return;
  }
  result2 = result2[1].split(",");
  result2 = {
    x: parseFloat(result2[0]),
    y: parseFloat(result2[1]),
    z: parseFloat(result2[2])
  };
  return result2;
};

// node_modules/devextreme/esm/__internal/core/m_events_strategy.js
var EventsStrategy = class _EventsStrategy {
  constructor(owner) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    this._events = {};
    this._owner = owner;
    this._options = options2;
  }
  static create(owner, strategy3) {
    if (strategy3) {
      return isFunction(strategy3) ? strategy3(owner) : strategy3;
    }
    return new _EventsStrategy(owner);
  }
  hasEvent(eventName) {
    const callbacks2 = this._events[eventName];
    return callbacks2 ? callbacks2.has() : false;
  }
  fireEvent(eventName, eventArgs) {
    const callbacks2 = this._events[eventName];
    if (callbacks2) {
      callbacks2.fireWith(this._owner, eventArgs);
    }
    return this._owner;
  }
  on(eventName, eventHandler) {
    if (isPlainObject(eventName)) {
      each(eventName, (e, h) => {
        this.on(e, h);
      });
    } else {
      let callbacks2 = this._events[eventName];
      if (!callbacks2) {
        callbacks2 = callbacks_default({
          syncStrategy: this._options.syncStrategy
        });
        this._events[eventName] = callbacks2;
      }
      const addFn = callbacks2.originalAdd || callbacks2.add;
      addFn.call(callbacks2, eventHandler);
    }
  }
  off(eventName, eventHandler) {
    const callbacks2 = this._events[eventName];
    if (callbacks2) {
      if (isFunction(eventHandler)) {
        callbacks2.remove(eventHandler);
      } else {
        callbacks2.empty();
      }
    }
  }
  dispose() {
    each(this._events, (eventName, event) => {
      event.empty();
    });
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_ready_callbacks.js
var callbacks = [];
var subscribeReady = call_once_default(() => {
  const removeListener = dom_adapter_default.listen(dom_adapter_default.getDocument(), "DOMContentLoaded", () => {
    readyCallbacks.fire();
    removeListener();
  });
});
var readyCallbacks = {
  add: (callback) => {
    const windowExists = hasWindow();
    if (windowExists && "loading" !== dom_adapter_default.getReadyState()) {
      callback();
    } else {
      callbacks.push(callback);
      windowExists && subscribeReady();
    }
  },
  fire: () => {
    callbacks.forEach((callback) => callback());
    callbacks = [];
  }
};
var readyCallbacksModule = dependency_injector_default(readyCallbacks);
var m_ready_callbacks_default = readyCallbacksModule;

// node_modules/devextreme/esm/core/utils/ready_callbacks.js
var ready_callbacks_default = readyCallbacksModule;

// node_modules/devextreme/esm/__internal/core/utils/m_resize_callbacks.js
var resizeCallbacks = function() {
  let prevSize;
  const callbacks2 = m_callbacks_default();
  const originalCallbacksAdd = callbacks2.add;
  const originalCallbacksRemove = callbacks2.remove;
  if (!m_window_default.hasWindow()) {
    return callbacks2;
  }
  const formatSize = function() {
    const window21 = m_window_default.getWindow();
    return {
      width: window21.innerWidth,
      height: window21.innerHeight
    };
  };
  const handleResize = function() {
    const now = formatSize();
    if (now.width === prevSize.width && now.height === prevSize.height) {
      return;
    }
    let changedDimension;
    if (now.width === prevSize.width) {
      changedDimension = "height";
    }
    if (now.height === prevSize.height) {
      changedDimension = "width";
    }
    prevSize = now;
    callbacks2.fire(changedDimension);
  };
  const setPrevSize = call_once_default(function() {
    prevSize = formatSize();
  });
  let removeListener;
  callbacks2.add = function() {
    const result2 = originalCallbacksAdd.apply(callbacks2, arguments);
    setPrevSize();
    m_ready_callbacks_default.add(function() {
      if (!removeListener && callbacks2.has()) {
        removeListener = dom_adapter_default.listen(m_window_default.getWindow(), "resize", handleResize);
      }
    });
    return result2;
  };
  callbacks2.remove = function() {
    const result2 = originalCallbacksRemove.apply(callbacks2, arguments);
    if (!callbacks2.has() && removeListener) {
      removeListener();
      removeListener = void 0;
    }
    return result2;
  };
  return callbacks2;
}();

// node_modules/devextreme/esm/core/utils/resize_callbacks.js
var resize_callbacks_default = resizeCallbacks;

// node_modules/devextreme/esm/__internal/core/utils/m_storage.js
var window5 = getWindow();
var getSessionStorage = function() {
  let sessionStorage;
  try {
    sessionStorage = window5.sessionStorage;
  } catch (e) {
  }
  return sessionStorage;
};

// node_modules/devextreme/esm/__internal/core/utils/m_view_port.js
var ready = ready_callbacks_default.add;
var changeCallback = callbacks_default();
var $originalViewPort = renderer_default();
var value = /* @__PURE__ */ function() {
  let $current;
  return function(element) {
    if (!arguments.length) {
      return $current;
    }
    const $element = renderer_default(element);
    $originalViewPort = $element;
    const isNewViewportFound = !!$element.length;
    const prevViewPort = value();
    $current = isNewViewportFound ? $element : renderer_default("body");
    changeCallback.fire(isNewViewportFound ? value() : renderer_default(), prevViewPort);
  };
}();
ready(function() {
  value(".dx-viewport");
});
function originalViewPort() {
  return $originalViewPort;
}

// node_modules/devextreme/esm/__internal/core/m_devices.js
var window6 = getWindow();
var KNOWN_UA_TABLE = {
  iPhone: "iPhone",
  iPhone5: "iPhone",
  iPhone6: "iPhone",
  iPhone6plus: "iPhone",
  iPad: "iPad",
  iPadMini: "iPad Mini",
  androidPhone: "Android Mobile",
  androidTablet: "Android",
  msSurface: "Windows ARM Tablet PC",
  desktop: "desktop"
};
var DEFAULT_DEVICE = {
  deviceType: "desktop",
  platform: "generic",
  version: [],
  phone: false,
  tablet: false,
  android: false,
  ios: false,
  generic: true,
  grade: "A",
  mac: false
};
var UA_PARSERS = {
  generic(userAgent) {
    const isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
    const isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
    const isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
    const isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());
    if (!(isPhone || isTablet || isDesktop || isMac)) {
      return null;
    }
    return {
      deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
      platform: "generic",
      version: [],
      grade: "A",
      mac: isMac
    };
  },
  appleTouchDevice(userAgent) {
    const navigator2 = getNavigator();
    const isIpadOs = /Macintosh/i.test(userAgent) && (null === navigator2 || void 0 === navigator2 ? void 0 : navigator2.maxTouchPoints) > 2;
    const isAppleDevice = /ip(hone|od|ad)/i.test(userAgent);
    if (!isAppleDevice && !isIpadOs) {
      return null;
    }
    const isPhone = /ip(hone|od)/i.test(userAgent);
    const matches = userAgent.match(/os\s{0,}X? (\d+)_(\d+)_?(\d+)?/i);
    const version2 = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
    const isIPhone4 = 480 === window6.screen.height;
    const grade = isIPhone4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "ios",
      version: version2,
      grade
    };
  },
  android(userAgent) {
    const isAndroid = /android|htc_|silk/i.test(userAgent);
    const isWinPhone = /windows phone/i.test(userAgent);
    if (!isAndroid || isWinPhone) {
      return null;
    }
    const isPhone = /mobile/i.test(userAgent);
    const matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
    const version2 = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
    const worseThan4_4 = version2.length > 1 && (version2[0] < 4 || 4 === version2[0] && version2[1] < 4);
    const grade = worseThan4_4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "android",
      version: version2,
      grade
    };
  }
};
var UA_PARSERS_ARRAY = [UA_PARSERS.appleTouchDevice, UA_PARSERS.android, UA_PARSERS.generic];
var Devices = class {
  constructor(options2) {
    this._window = (null === options2 || void 0 === options2 ? void 0 : options2.window) ?? window6;
    this._realDevice = this._getDevice();
    this._currentDevice = void 0;
    this._currentOrientation = void 0;
    this._eventsStrategy = new EventsStrategy(this);
    this.changed = callbacks_default();
    if (hasWindow()) {
      ready_callbacks_default.add(this._recalculateOrientation.bind(this));
      resize_callbacks_default.add(this._recalculateOrientation.bind(this));
    }
  }
  current(deviceOrName) {
    if (deviceOrName) {
      this._currentDevice = this._getDevice(deviceOrName);
      this._forced = true;
      this.changed.fire();
      return;
    }
    if (!this._currentDevice) {
      deviceOrName = void 0;
      try {
        deviceOrName = this._getDeviceOrNameFromWindowScope();
      } catch (e) {
        deviceOrName = this._getDeviceNameFromSessionStorage();
      } finally {
        if (!deviceOrName) {
          deviceOrName = this._getDeviceNameFromSessionStorage();
        }
        if (deviceOrName) {
          this._forced = true;
        }
      }
      this._currentDevice = this._getDevice(deviceOrName);
    }
    return this._currentDevice;
  }
  real(forceDevice) {
    return extend({}, this._realDevice);
  }
  orientation() {
    return this._currentOrientation;
  }
  isForced() {
    return this._forced;
  }
  isRippleEmulator() {
    return !!this._window.tinyHippos;
  }
  _getCssClasses(device) {
    const result2 = [];
    const realDevice2 = this._realDevice;
    device = device || this.current();
    if (device.deviceType) {
      result2.push(`dx-device-${device.deviceType}`);
      if ("desktop" !== device.deviceType) {
        result2.push("dx-device-mobile");
      }
    }
    result2.push(`dx-device-${realDevice2.platform}`);
    if (realDevice2.version && realDevice2.version.length) {
      result2.push(`dx-device-${realDevice2.platform}-${realDevice2.version[0]}`);
    }
    if (this.isSimulator()) {
      result2.push("dx-simulator");
    }
    if (config_default2().rtlEnabled) {
      result2.push("dx-rtl");
    }
    return result2;
  }
  attachCssClasses(element, device) {
    this._deviceClasses = this._getCssClasses(device).join(" ");
    renderer_default(element).addClass(this._deviceClasses);
  }
  detachCssClasses(element) {
    renderer_default(element).removeClass(this._deviceClasses);
  }
  isSimulator() {
    try {
      var _this$_window$top;
      return this._isSimulator || hasWindow() && this._window.top !== this._window.self && (null === (_this$_window$top = this._window.top) || void 0 === _this$_window$top ? void 0 : _this$_window$top["dx-force-device"]) || this.isRippleEmulator();
    } catch (e) {
      return false;
    }
  }
  forceSimulator() {
    this._isSimulator = true;
  }
  _getDevice(deviceName) {
    if ("genericPhone" === deviceName) {
      deviceName = {
        deviceType: "phone",
        platform: "generic",
        generic: true
      };
    }
    if (isPlainObject(deviceName)) {
      return this._fromConfig(deviceName);
    }
    let ua;
    if (deviceName) {
      ua = KNOWN_UA_TABLE[deviceName];
      if (!ua) {
        throw errors_default.Error("E0005");
      }
    } else {
      const navigator2 = getNavigator();
      ua = navigator2.userAgent;
    }
    return this._fromUA(ua);
  }
  _getDeviceOrNameFromWindowScope() {
    var _this$_window$top2, _this$_window$top3;
    let result2;
    if (hasWindow() && (null !== (_this$_window$top2 = this._window.top) && void 0 !== _this$_window$top2 && _this$_window$top2["dx-force-device-object"] || null !== (_this$_window$top3 = this._window.top) && void 0 !== _this$_window$top3 && _this$_window$top3["dx-force-device"])) {
      var _this$_window$top4, _this$_window$top5;
      result2 = (null === (_this$_window$top4 = this._window.top) || void 0 === _this$_window$top4 ? void 0 : _this$_window$top4["dx-force-device-object"]) || (null === (_this$_window$top5 = this._window.top) || void 0 === _this$_window$top5 ? void 0 : _this$_window$top5["dx-force-device"]);
    }
    return result2;
  }
  _getDeviceNameFromSessionStorage() {
    const sessionStorage = getSessionStorage();
    if (!sessionStorage) {
      return;
    }
    const deviceOrName = sessionStorage.getItem("dx-force-device");
    try {
      return JSON.parse(deviceOrName);
    } catch (ex) {
      return deviceOrName;
    }
  }
  _fromConfig(config3) {
    const result2 = extend({}, DEFAULT_DEVICE, this._currentDevice, config3);
    const shortcuts = {
      phone: "phone" === result2.deviceType,
      tablet: "tablet" === result2.deviceType,
      android: "android" === result2.platform,
      ios: "ios" === result2.platform,
      generic: "generic" === result2.platform
    };
    return extend(result2, shortcuts);
  }
  _fromUA(ua) {
    for (let idx = 0; idx < UA_PARSERS_ARRAY.length; idx += 1) {
      const parser = UA_PARSERS_ARRAY[idx];
      const config3 = parser(ua);
      if (config3) {
        return this._fromConfig(config3);
      }
    }
    return DEFAULT_DEVICE;
  }
  _changeOrientation() {
    const $window = renderer_default(this._window);
    const orientation = getHeight($window) > getWidth($window) ? "portrait" : "landscape";
    if (this._currentOrientation === orientation) {
      return;
    }
    this._currentOrientation = orientation;
    this._eventsStrategy.fireEvent("orientationChanged", [{
      orientation
    }]);
  }
  _recalculateOrientation() {
    const windowWidth = getWidth(this._window);
    if (this._currentWidth === windowWidth) {
      return;
    }
    this._currentWidth = windowWidth;
    this._changeOrientation();
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
};
var devices = new Devices();
when(uiLayerInitialized).done(() => {
  const viewPortElement = value();
  if (viewPortElement) {
    devices.attachCssClasses(viewPortElement);
  }
  changeCallback.add((viewPort2, prevViewport) => {
    devices.detachCssClasses(prevViewport);
    devices.attachCssClasses(viewPort2);
  });
});
var m_devices_default = devices;

// node_modules/devextreme/esm/__internal/core/utils/m_support.js
var {
  maxTouchPoints
} = getNavigator();
var transitionEndEventNames = {
  webkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd",
  transition: "transitionend"
};
var supportProp = function(prop) {
  return !!styleProp(prop);
};
var isNativeScrollingSupported = function() {
  const {
    platform,
    mac: isMac
  } = m_devices_default.real();
  const isNativeScrollDevice = "ios" === platform || "android" === platform || isMac;
  return isNativeScrollDevice;
};
var inputType = function(type2) {
  if ("text" === type2) {
    return true;
  }
  const input = dom_adapter_default.createElement("input");
  try {
    input.setAttribute("type", type2);
    input.value = "wrongValue";
    return !input.value;
  } catch (e) {
    return false;
  }
};
var detectTouchEvents = function(hasWindowProperty, maxTouchPoints2) {
  return (hasWindowProperty("ontouchstart") || !!maxTouchPoints2) && !hasWindowProperty("callPhantom");
};
var detectPointerEvent = function(hasWindowProperty) {
  return hasWindowProperty("PointerEvent");
};
var touchEvents = detectTouchEvents(hasProperty, maxTouchPoints);
var pointerEvents = detectPointerEvent(hasProperty);
var touchPointersPresent = !!maxTouchPoints;
var touch = touchEvents || pointerEvents && touchPointersPresent;
var transition = call_once_default(function() {
  return supportProp("transition");
});
var transitionEndEventName = call_once_default(function() {
  return transitionEndEventNames[styleProp("transition")];
});
var animation = call_once_default(function() {
  return supportProp("animation");
});
var nativeScrolling = isNativeScrollingSupported();
var m_support_default = {
  animation,
  inputType,
  nativeScrolling,
  pointerEvents,
  styleProp,
  stylePropPrefix,
  supportProp,
  touch,
  touchEvents,
  transition,
  transitionEndEventName
};

// node_modules/devextreme/esm/common/core/environment/hide_callback.js
var hideCallback = /* @__PURE__ */ function() {
  let callbacks2 = [];
  return {
    add: function(callback) {
      if (!callbacks2.includes(callback)) {
        callbacks2.push(callback);
      }
    },
    remove: function(callback) {
      const indexOfCallback = callbacks2.indexOf(callback);
      if (-1 !== indexOfCallback) {
        callbacks2.splice(indexOfCallback, 1);
      }
    },
    fire: function() {
      const callback = callbacks2.pop();
      const result2 = !!callback;
      if (result2) {
        callback();
      }
      return result2;
    },
    hasCallback: function() {
      return callbacks2.length > 0;
    }
  };
}();

// node_modules/devextreme/esm/common/core/environment/init_mobile_viewport/init_mobile_viewport.js
var window7 = getWindow();

// node_modules/devextreme/esm/__internal/core/utils/date.js
var addOffsets = (date, offsets) => {
  const newDateMs = offsets.reduce((result2, offset2) => result2 + offset2, date.getTime());
  return new Date(newDateMs);
};
var isValidDate = (date) => Boolean(date && !isNaN(new Date(date).valueOf()));
var dateUtilsTs = {
  addOffsets,
  isValidDate
};

// node_modules/devextreme/esm/__internal/scheduler/utils/macro_task_array/dispatcher.js
var macroTaskIdSet = /* @__PURE__ */ new Set();
var schedule = async (callback, macroTaskTimeoutMs) => new Promise((resolve) => {
  const taskId = setTimeout(() => {
    callback();
    macroTaskIdSet.delete(taskId);
    resolve();
  }, macroTaskTimeoutMs);
  macroTaskIdSet.add(taskId);
});
var dispose = () => {
  Array.from(macroTaskIdSet).forEach((id) => {
    clearTimeout(id);
    macroTaskIdSet.delete(id);
  });
};
var dispatcher_default = {
  schedule,
  dispose
};

// node_modules/devextreme/esm/__internal/scheduler/utils/macro_task_array/methods.js
var macroTaskArrayForEach = async function(array, callback) {
  let step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 100;
  let macroTaskTimeoutMs = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
  const promises = [];
  const batchesCount = Math.ceil(array.length / step);
  for (let batchIdx = 0; batchIdx < batchesCount; batchIdx += 1) {
    const scheduledTask = dispatcher_default.schedule(() => {
      const startIdx = batchIdx * step;
      const maxIdx = startIdx + step;
      for (let idx = startIdx; idx < maxIdx && void 0 !== array[idx]; idx += 1) {
        callback(array[idx]);
      }
    }, macroTaskTimeoutMs);
    promises.push(scheduledTask);
  }
  await Promise.all(promises);
};
var macroTaskArrayMap = async function(array, callback) {
  let step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 100;
  let macroTaskTimeoutMs = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
  const result2 = [];
  await macroTaskArrayForEach(array, (item) => {
    result2.push(callback(item));
  }, step, macroTaskTimeoutMs);
  return result2;
};

// node_modules/devextreme/esm/__internal/scheduler/utils/macro_task_array/index.js
var macro_task_array_default = {
  forEach: macroTaskArrayForEach,
  map: macroTaskArrayMap,
  dispose: dispatcher_default.dispose
};

// node_modules/devextreme/esm/common/core/localization/default_date_names.js
var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var DAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var PERIODS = ["AM", "PM"];
var QUARTERS = ["Q1", "Q2", "Q3", "Q4"];
var cutCaptions = (captions, format2) => {
  const lengthByFormat = {
    abbreviated: 3,
    short: 2,
    narrow: 1
  };
  return map(captions, (caption) => caption.substr(0, lengthByFormat[format2]));
};
var default_date_names_default = {
  getMonthNames: function(format2) {
    return cutCaptions(MONTHS, format2);
  },
  getDayNames: function(format2) {
    return cutCaptions(DAYS, format2);
  },
  getQuarterNames: function(format2) {
    return QUARTERS;
  },
  getPeriodNames: function(format2) {
    return PERIODS;
  }
};

// node_modules/devextreme/esm/common/core/localization/ldml/date.formatter.js
function leftPad(text, length) {
  while (text.length < length) {
    text = "0" + text;
  }
  return text;
}
var FORMAT_TYPES = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
};
var LDML_FORMATTERS = {
  y: function(date, count, useUtc) {
    let year = date[useUtc ? "getUTCFullYear" : "getFullYear"]();
    if (2 === count) {
      year %= 100;
    }
    return leftPad(year.toString(), count);
  },
  M: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "format")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  L: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "standalone")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  Q: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const quarter = Math.floor(month / 3);
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getQuarterNames(formatType)[quarter];
    }
    return leftPad((quarter + 1).toString(), Math.min(count, 2));
  },
  E: function(date, count, useUtc, dateParts) {
    const day = date[useUtc ? "getUTCDay" : "getDay"]();
    const formatType = FORMAT_TYPES[count < 3 ? 3 : count];
    return dateParts.getDayNames(formatType)[day];
  },
  a: function(date, count, useUtc, dateParts) {
    const hours = date[useUtc ? "getUTCHours" : "getHours"]();
    const period = hours < 12 ? 0 : 1;
    const formatType = FORMAT_TYPES[count];
    return dateParts.getPeriodNames(formatType)[period];
  },
  d: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCDate" : "getDate"]().toString(), Math.min(count, 2));
  },
  H: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCHours" : "getHours"]().toString(), Math.min(count, 2));
  },
  h: function(date, count, useUtc) {
    const hours = date[useUtc ? "getUTCHours" : "getHours"]();
    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));
  },
  m: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMinutes" : "getMinutes"]().toString(), Math.min(count, 2));
  },
  s: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCSeconds" : "getSeconds"]().toString(), Math.min(count, 2));
  },
  S: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMilliseconds" : "getMilliseconds"]().toString(), 3).substr(0, count);
  },
  x: function(date, count, useUtc) {
    const timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
    const signPart = timezoneOffset > 0 ? "-" : "+";
    const timezoneOffsetAbs = Math.abs(timezoneOffset);
    const hours = Math.floor(timezoneOffsetAbs / 60);
    const minutes = timezoneOffsetAbs % 60;
    const hoursPart = leftPad(hours.toString(), 2);
    const minutesPart = leftPad(minutes.toString(), 2);
    return signPart + hoursPart + (count >= 3 ? ":" : "") + (count > 1 || minutes ? minutesPart : "");
  },
  X: function(date, count, useUtc) {
    if (useUtc || !date.getTimezoneOffset()) {
      return "Z";
    }
    return LDML_FORMATTERS.x(date, count, useUtc);
  },
  Z: function(date, count, useUtc) {
    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);
  }
};
var getFormatter = function(format2, dateParts) {
  return function(date) {
    let charIndex;
    let formatter;
    let char;
    let charCount = 0;
    let isEscaping = false;
    let isCurrentCharEqualsNext;
    let result2 = "";
    if (!date) {
      return null;
    }
    if (!format2) {
      return date;
    }
    const useUtc = "Z" === format2[format2.length - 1] || "'Z'" === format2.slice(-3);
    for (charIndex = 0; charIndex < format2.length; charIndex++) {
      char = format2[charIndex];
      formatter = LDML_FORMATTERS[char];
      isCurrentCharEqualsNext = char === format2[charIndex + 1];
      charCount++;
      if (!isCurrentCharEqualsNext) {
        if (formatter && !isEscaping) {
          result2 += formatter(date, charCount, useUtc, dateParts);
        }
        charCount = 0;
      }
      if ("'" === char && !isCurrentCharEqualsNext) {
        isEscaping = !isEscaping;
      } else if (isEscaping || !formatter) {
        result2 += char;
      }
      if ("'" === char && isCurrentCharEqualsNext) {
        charIndex++;
      }
    }
    return result2;
  };
};

// node_modules/devextreme/esm/__internal/core/utils/m_date_serialization.js
var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
var ISO8601_PATTERN_PARTS = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"];
var DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
var dateParser = function(text, skipISO8601Parsing) {
  let result2;
  if (isString(text) && !skipISO8601Parsing) {
    result2 = parseISO8601String(text);
  }
  return result2 || parseDate(text);
};
function getTimePart(part) {
  return +part || 0;
}
function parseDate(text) {
  const isDefaultSerializationFormat = "yyyy/MM/dd" === getDateSerializationFormat(text);
  const parsedValue = !isDate(text) && Date.parse(text);
  if (!parsedValue && isDefaultSerializationFormat) {
    const parts = text.match(DATE_SERIALIZATION_PATTERN);
    if (parts) {
      const newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
      newDate.setFullYear(getTimePart(parts[1]));
      newDate.setMonth(getTimePart(parts[2]) - 1);
      newDate.setDate(getTimePart(parts[3]));
      return newDate;
    }
  }
  return isNumeric(parsedValue) ? new Date(parsedValue) : text;
}
function parseISO8601String(text) {
  let parts = text.match(ISO8601_PATTERN);
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));
    }
    return;
  }
  const year = getTimePart(parts[1]);
  const month = --parts[3];
  const day = parts[5];
  let timeZoneHour = 0;
  let timeZoneMinute = 0;
  const correctYear = (d) => {
    year < 100 && d.setFullYear(year);
    return d;
  };
  timeZoneHour = getTimePart(parts[14]);
  timeZoneMinute = getTimePart(parts[16]);
  if ("-" === parts[13]) {
    timeZoneHour = -timeZoneHour;
    timeZoneMinute = -timeZoneMinute;
  }
  const hour = getTimePart(parts[6]) - timeZoneHour;
  const minute = getTimePart(parts[8]) - timeZoneMinute;
  const second = getTimePart(parts[10]);
  const millisecond = function(part) {
    part = part || "";
    return getTimePart(part) * 10 ** (3 - part.length);
  }(parts[11]);
  if (parts[12]) {
    return correctYear(new Date(Date.UTC(year, month, day, hour, minute, second, millisecond)));
  }
  return correctYear(new Date(year, month, day, hour, minute, second, millisecond));
}
var getIso8601Format = function(text, useUtc) {
  let parts = text.match(ISO8601_PATTERN);
  let result2 = "";
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return parts[3] ? "HH:mm:ss" : "HH:mm";
    }
    return;
  }
  for (let i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
    if (parts[i]) {
      result2 += ISO8601_PATTERN_PARTS[i] || parts[i];
    }
  }
  if ("Z" === parts[12]) {
    result2 += "'Z'";
  }
  if (parts[14]) {
    if (parts[15]) {
      result2 += "xxx";
    } else if (parts[16]) {
      result2 += "xx";
    } else {
      result2 += "x";
    }
  }
  return result2;
};
var deserializeDate = function(value2) {
  if ("number" === typeof value2) {
    return new Date(value2);
  }
  return dateParser(value2, !config_default2().forceIsoDateParsing);
};
var serializeDate = function(value2, serializationFormat) {
  if (!serializationFormat) {
    return value2;
  }
  if (!isDate(value2)) {
    return null;
  }
  if ("number" === serializationFormat) {
    return value2 && value2.valueOf ? value2.valueOf() : null;
  }
  return getFormatter(serializationFormat, default_date_names_default)(value2);
};
var getDateSerializationFormat = function(value2) {
  if ("number" === typeof value2) {
    return "number";
  }
  if (isString(value2)) {
    let format2;
    if (config_default2().forceIsoDateParsing) {
      format2 = getIso8601Format(value2);
    }
    if (format2) {
      return format2;
    }
    if (value2.includes(":")) {
      return "yyyy/MM/dd HH:mm:ss";
    }
    return "yyyy/MM/dd";
  }
  if (value2) {
    return null;
  }
};
var dateSerialization = {
  dateParser,
  deserializeDate,
  serializeDate,
  getDateSerializationFormat
};

// node_modules/devextreme/esm/core/utils/date_serialization.js
var date_serialization_default = dateSerialization;

// node_modules/devextreme/esm/__internal/core/utils/m_math.js
var sign = function(value2) {
  if (0 === value2) {
    return 0;
  }
  return value2 / Math.abs(value2);
};
var fitIntoRange = function(value2, minValue, maxValue) {
  const isMinValueUndefined = !minValue && 0 !== minValue;
  const isMaxValueUndefined = !maxValue && 0 !== maxValue;
  isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value2, maxValue) : value2);
  isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value2, minValue) : value2);
  return Math.min(Math.max(value2, minValue), maxValue);
};
var inRange = function(value2, minValue, maxValue) {
  return value2 >= minValue && value2 <= maxValue;
};
function getExponent(value2) {
  return Math.abs(parseInt(value2.toExponential().split("e")[1], 10));
}
function getExponentialNotation(value2) {
  const parts = value2.toExponential().split("e");
  const mantissa = parseFloat(parts[0]);
  const exponent = parseInt(parts[1], 10);
  return {
    exponent,
    mantissa
  };
}
function multiplyInExponentialForm(value2, exponentShift) {
  const exponentialNotation = getExponentialNotation(value2);
  return parseFloat(`${exponentialNotation.mantissa}e${exponentialNotation.exponent + exponentShift}`);
}
function isEdgeBug() {
  return "0.000300" !== 3e-4.toPrecision(3);
}
function adjust(value2, interval) {
  let precision = getPrecision(interval || 0) + 2;
  const separatedValue = value2.toString().split(".");
  const sourceValue = value2;
  const absValue = Math.abs(value2);
  let separatedAdjustedValue;
  const isExponentValue = isExponential(value2);
  const integerPart = absValue > 1 ? 10 : 0;
  if (1 === separatedValue.length) {
    return value2;
  }
  if (!isExponentValue) {
    if (isExponential(interval)) {
      precision = separatedValue[0].length + getExponent(interval);
    }
    value2 = absValue;
    value2 = value2 - Math.floor(value2) + integerPart;
  }
  precision = isEdgeBug() && getExponent(value2) > 6 || precision > 7 ? 15 : 7;
  if (!isExponentValue) {
    separatedAdjustedValue = parseFloat(value2.toPrecision(precision)).toString().split(".");
    if (separatedAdjustedValue[0] === integerPart.toString()) {
      return parseFloat(`${separatedValue[0]}.${separatedAdjustedValue[1]}`);
    }
  }
  return parseFloat(sourceValue.toPrecision(precision));
}
function getPrecision(value2) {
  const str = value2.toString();
  if (str.indexOf(".") < 0) {
    return 0;
  }
  const mantissa = str.split(".");
  const positionOfDelimiter = mantissa[1].indexOf("e");
  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;
}

// node_modules/devextreme/esm/__internal/utils/toMilliseconds.js
var timeIntervals = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 864e5,
  week: 6048e5,
  month: 2592e6,
  quarter: 7776e6,
  year: 31536e6
};
function toMilliseconds(value2) {
  return timeIntervals[value2];
}

// node_modules/devextreme/esm/__internal/core/utils/m_date.js
var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
var getDatesInterval = function(startDate, endDate, intervalUnit) {
  const delta = endDate.getTime() - startDate.getTime();
  const millisecondCount = toMilliseconds(intervalUnit) || 1;
  return Math.floor(delta / millisecondCount);
};
var getNextDateUnit = function(unit, withWeeks) {
  const interval = getDateUnitInterval(unit);
  switch (interval) {
    case "millisecond":
      return "second";
    case "second":
      return "minute";
    case "minute":
      return "hour";
    case "hour":
      return "day";
    case "day":
      return withWeeks ? "week" : "month";
    case "week":
      return "month";
    case "month":
      return "quarter";
    case "quarter":
    case "year":
      return "year";
    default:
      return 0;
  }
};
var convertMillisecondsToDateUnits = function(value2) {
  let i;
  let dateUnitCount;
  let dateUnitInterval;
  const dateUnitIntervals2 = ["millisecond", "second", "minute", "hour", "day", "month", "year"];
  const result2 = {};
  for (i = dateUnitIntervals2.length - 1; i >= 0; i--) {
    dateUnitInterval = dateUnitIntervals2[i];
    dateUnitCount = Math.floor(value2 / toMilliseconds(dateUnitInterval));
    if (dateUnitCount > 0) {
      result2[`${dateUnitInterval}s`] = dateUnitCount;
      value2 -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount);
    }
  }
  return result2;
};
var dateToMilliseconds = function(tickInterval) {
  let milliseconds = 0;
  if (isObject(tickInterval)) {
    each(tickInterval, function(key, value2) {
      milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value2);
    });
  }
  if (isString(tickInterval)) {
    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
  }
  return milliseconds;
};
function convertDateUnitToMilliseconds(dateUnit, count) {
  return toMilliseconds(dateUnit) * count;
}
function getDateUnitInterval(tickInterval) {
  let maxInterval = -1;
  let i;
  if (isString(tickInterval)) {
    return tickInterval;
  }
  if (isObject(tickInterval)) {
    each(tickInterval, function(key, value2) {
      for (i = 0; i < dateUnitIntervals.length; i++) {
        if (value2 && (key === `${dateUnitIntervals[i]}s` || key === dateUnitIntervals[i]) && maxInterval < i) {
          maxInterval = i;
        }
      }
    });
    return dateUnitIntervals[maxInterval];
  }
  return "";
}
var tickIntervalToFormatMap = {
  millisecond: "millisecond",
  second: "longtime",
  minute: "shorttime",
  hour: "shorttime",
  day: "day",
  week: "day",
  month: "month",
  quarter: "quarter",
  year: "year"
};
function getDateFormatByTickInterval(tickInterval) {
  return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || "";
}
var getQuarter = function(month) {
  return Math.floor(month / 3);
};
var getFirstQuarterMonth = function(month) {
  return 3 * getQuarter(month);
};
function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
  date = new Date(date.getTime());
  const oldDate = new Date(date.getTime());
  let firstQuarterMonth;
  let month;
  const dateUnitInterval = getDateUnitInterval(dateInterval);
  switch (dateUnitInterval) {
    case "second":
      date = new Date(1e3 * Math.floor(oldDate.getTime() / 1e3));
      break;
    case "minute":
      date = new Date(6e4 * Math.floor(oldDate.getTime() / 6e4));
      break;
    case "hour":
      date = new Date(36e5 * Math.floor(oldDate.getTime() / 36e5));
      break;
    case "year":
      date.setMonth(0);
    case "month":
      date.setDate(1);
    case "day":
      date.setHours(0, 0, 0, 0);
      break;
    case "week":
      date = getFirstWeekDate(date, firstDayOfWeek || 0);
      date.setHours(0, 0, 0, 0);
      break;
    case "quarter":
      firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
      month = date.getMonth();
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      if (month !== firstQuarterMonth) {
        date.setMonth(firstQuarterMonth);
      }
  }
  if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
    fixTimezoneGap(oldDate, date);
  }
  return date;
}
function trimTime(date) {
  return correctDateWithUnitBeginning(date, "day");
}
var setToDayEnd = function(date) {
  const result2 = trimTime(date);
  result2.setDate(result2.getDate() + 1);
  return new Date(result2.getTime() - 1);
};
var getDatesDifferences = function(date1, date2) {
  let counter = 0;
  const differences = {
    year: date1.getFullYear() !== date2.getFullYear(),
    month: date1.getMonth() !== date2.getMonth(),
    day: date1.getDate() !== date2.getDate(),
    hour: date1.getHours() !== date2.getHours(),
    minute: date1.getMinutes() !== date2.getMinutes(),
    second: date1.getSeconds() !== date2.getSeconds(),
    millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
  };
  each(differences, function(key, value2) {
    if (value2) {
      counter++;
    }
  });
  if (0 === counter && 0 !== getTimezonesDifference(date1, date2)) {
    differences.hour = true;
    counter++;
  }
  differences.count = counter;
  return differences;
};
function addDateInterval(value2, interval, dir) {
  const result2 = new Date(value2.getTime());
  const intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : isNumeric(interval) ? convertMillisecondsToDateUnits(interval) : interval;
  if (intervalObject.years) {
    result2.setFullYear(result2.getFullYear() + intervalObject.years * dir);
  }
  if (intervalObject.quarters) {
    result2.setMonth(result2.getMonth() + 3 * intervalObject.quarters * dir);
  }
  if (intervalObject.months) {
    result2.setMonth(result2.getMonth() + intervalObject.months * dir);
  }
  if (intervalObject.weeks) {
    result2.setDate(result2.getDate() + 7 * intervalObject.weeks * dir);
  }
  if (intervalObject.days) {
    result2.setDate(result2.getDate() + intervalObject.days * dir);
  }
  if (intervalObject.hours) {
    result2.setTime(result2.getTime() + 36e5 * intervalObject.hours * dir);
  }
  if (intervalObject.minutes) {
    result2.setTime(result2.getTime() + 6e4 * intervalObject.minutes * dir);
  }
  if (intervalObject.seconds) {
    result2.setTime(result2.getTime() + 1e3 * intervalObject.seconds * dir);
  }
  if (intervalObject.milliseconds) {
    result2.setTime(result2.getTime() + intervalObject.milliseconds * dir);
  }
  return result2;
}
var addInterval = function(value2, interval, isNegative) {
  const dir = isNegative ? -1 : 1;
  return isDate(value2) ? addDateInterval(value2, interval, dir) : adjust(value2 + interval * dir, interval);
};
var getSequenceByInterval = function(min, max, interval) {
  const intervals = [];
  let cur;
  intervals.push(isDate(min) ? new Date(min.getTime()) : min);
  cur = min;
  while (cur < max) {
    cur = addInterval(cur, interval);
    intervals.push(cur);
  }
  return intervals;
};
var getViewFirstCellDate = function(viewType, date) {
  if ("month" === viewType) {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  }
  if ("year" === viewType) {
    return createDateWithFullYear(date.getFullYear(), 0, date.getDate());
  }
  if ("decade" === viewType) {
    return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate());
  }
  if ("century" === viewType) {
    return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate());
  }
};
var getViewLastCellDate = function(viewType, date) {
  if ("month" === viewType) {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
  }
  if ("year" === viewType) {
    return createDateWithFullYear(date.getFullYear(), 11, date.getDate());
  }
  if ("decade" === viewType) {
    return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
  }
  if ("century" === viewType) {
    return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate());
  }
};
var getViewMinBoundaryDate = function(viewType, date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  if ("month" === viewType) {
    return resultDate;
  }
  resultDate.setMonth(0);
  if ("year" === viewType) {
    return resultDate;
  }
  if ("decade" === viewType) {
    resultDate.setFullYear(getFirstYearInDecade(date));
  }
  if ("century" === viewType) {
    resultDate.setFullYear(getFirstDecadeInCentury(date));
  }
  return resultDate;
};
var getViewMaxBoundaryDate = function(viewType, date) {
  const resultDate = new Date(date);
  resultDate.setDate(getLastMonthDay(date));
  if ("month" === viewType) {
    return resultDate;
  }
  resultDate.setMonth(11);
  resultDate.setDate(getLastMonthDay(resultDate));
  if ("year" === viewType) {
    return resultDate;
  }
  if ("decade" === viewType) {
    resultDate.setFullYear(getFirstYearInDecade(date) + 9);
  }
  if ("century" === viewType) {
    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
  }
  return resultDate;
};
function getLastMonthDay(date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
  return resultDate.getDate();
}
var getViewUp = function(typeView) {
  switch (typeView) {
    case "month":
      return "year";
    case "year":
      return "decade";
    case "decade":
      return "century";
  }
};
var getViewDown = function(typeView) {
  switch (typeView) {
    case "century":
      return "decade";
    case "decade":
      return "year";
    case "year":
      return "month";
  }
};
var getDifferenceInMonth = function(typeView) {
  let difference = 1;
  if ("year" === typeView) {
    difference = 12;
  }
  if ("decade" === typeView) {
    difference = 120;
  }
  if ("century" === typeView) {
    difference = 1200;
  }
  return difference;
};
var getDifferenceInMonthForCells = function(typeView) {
  let difference = 1;
  if ("decade" === typeView) {
    difference = 12;
  }
  if ("century" === typeView) {
    difference = 120;
  }
  return difference;
};
function getDateIntervalByString(intervalString) {
  const result2 = {};
  switch (intervalString) {
    case "year":
      result2.years = 1;
      break;
    case "month":
      result2.months = 1;
      break;
    case "quarter":
      result2.months = 3;
      break;
    case "week":
      result2.weeks = 1;
      break;
    case "day":
      result2.days = 1;
      break;
    case "hour":
      result2.hours = 1;
      break;
    case "minute":
      result2.minutes = 1;
      break;
    case "second":
      result2.seconds = 1;
      break;
    case "millisecond":
      result2.milliseconds = 1;
  }
  return result2;
}
function sameDate(date1, date2) {
  return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate();
}
function sameMonthAndYear(date1, date2) {
  return sameYear(date1, date2) && date1.getMonth() === date2.getMonth();
}
function sameYear(date1, date2) {
  return date1 && date2 && date1.getFullYear() === date2.getFullYear();
}
function sameHoursAndMinutes(date1, date2) {
  return date1 && date2 && date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes();
}
var sameDecade = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  const startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
  const startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
  return date1 && date2 && startDecadeDate1 === startDecadeDate2;
};
var sameCentury = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  const startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
  const startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
  return date1 && date2 && startCenturyDate1 === startCenturyDate2;
};
var sameDatesArrays = (arr1, arr2) => {
  if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length !== arr2.length) {
    return false;
  }
  return arr1.every((date1, index2) => {
    const date2 = arr2[index2];
    if ([date1, date2].some((date) => null !== date && !(date instanceof Date))) {
      return false;
    }
    if (date1 instanceof Date && date2 instanceof Date) {
      return sameDate(date1, date2);
    }
    return date1 === date2;
  });
};
function getFirstDecadeInCentury(date) {
  return date && date.getFullYear() - date.getFullYear() % 100;
}
function getFirstYearInDecade(date) {
  return date && date.getFullYear() - date.getFullYear() % 10;
}
var getShortDateFormat = function() {
  return "yyyy/MM/dd";
};
var getFirstMonthDate = function(date) {
  let offset2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
  if (!isDefined(date)) {
    return;
  }
  const currentDate = new Date(date.getTime());
  const month = currentDate.getMonth() + offset2;
  currentDate.setMonth(month);
  return createDateWithFullYear(currentDate.getFullYear(), month, 1);
};
var getLastMonthDate = function(date) {
  let offset2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
  if (!isDefined(date)) {
    return;
  }
  const currentDate = new Date(date.getTime());
  const month = currentDate.getMonth() + offset2;
  currentDate.setMonth(month);
  return createDateWithFullYear(currentDate.getFullYear(), month + 1, 0);
};
function getFirstWeekDate(date, firstDayOfWeek) {
  const delta = (date.getDay() - firstDayOfWeek + 7) % 7;
  const result2 = new Date(date);
  result2.setDate(date.getDate() - delta);
  return result2;
}
function getUTCTime(date) {
  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
}
function getDayNumber(date) {
  const ms = getUTCTime(date) - getUTCTime(getFirstDateInYear(date.getFullYear()));
  return 1 + Math.floor(ms / toMilliseconds("day"));
}
function getFirstDateInYear(year) {
  return new Date(year, 0, 1);
}
function getLastDateInYear(year) {
  return new Date(year, 11, 31);
}
function getDayWeekNumber(date, firstDayOfWeek) {
  let day = date.getDay() - firstDayOfWeek + 1;
  if (day <= 0) {
    day += 7;
  }
  return day;
}
function getWeekNumber(date, firstDayOfWeek, rule) {
  const firstWeekDayInYear = getDayWeekNumber(getFirstDateInYear(date.getFullYear()), firstDayOfWeek);
  const lastWeekDayInYear = getDayWeekNumber(getLastDateInYear(date.getFullYear()), firstDayOfWeek);
  const daysInFirstWeek = 7 - firstWeekDayInYear + 1;
  let weekNumber = Math.ceil((getDayNumber(date) - daysInFirstWeek) / 7);
  switch (rule) {
    case "fullWeek":
      if (7 === daysInFirstWeek) {
        weekNumber++;
      }
      if (0 === weekNumber) {
        const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
        return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
      }
      return weekNumber;
    case "firstDay": {
      if (daysInFirstWeek > 0) {
        weekNumber++;
      }
      const isSunday = 7 === firstWeekDayInYear || 7 === lastWeekDayInYear;
      if (weekNumber > 52 && !isSunday || 54 === weekNumber) {
        weekNumber = 1;
      }
      return weekNumber;
    }
    case "firstFourDays": {
      if (daysInFirstWeek > 3) {
        weekNumber++;
      }
      const isThursday = 4 === firstWeekDayInYear || 4 === lastWeekDayInYear;
      if (weekNumber > 52 && !isThursday) {
        weekNumber = 1;
      }
      if (0 === weekNumber) {
        const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
        return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
      }
      return weekNumber;
    }
  }
}
var normalizeDateByWeek = function(date, currentDate) {
  const differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day");
  let resultDate = new Date(date);
  if (differenceInDays >= 6) {
    resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7));
  }
  return resultDate;
};
var dateInRange = function(date, min, max, format2) {
  if ("date" === format2) {
    min = min && dateUtils.correctDateWithUnitBeginning(min, "day");
    max = max && dateUtils.correctDateWithUnitBeginning(max, "day");
    date = date && dateUtils.correctDateWithUnitBeginning(date, "day");
  }
  return normalizeDate(date, min, max) === date;
};
var intervalsOverlap = function(options2) {
  const {
    firstMin,
    firstMax,
    secondMin,
    secondMax
  } = options2;
  return firstMin <= secondMin && secondMin <= firstMax || firstMin > secondMin && firstMin < secondMax || firstMin < secondMax && firstMax > secondMax;
};
var dateTimeFromDecimal = function(number) {
  const hours = Math.floor(number);
  const minutes = number % 1 * 60;
  return {
    hours,
    minutes
  };
};
var roundDateByStartDayHour = function(date, startDayHour) {
  const startTime = this.dateTimeFromDecimal(startDayHour);
  const result2 = new Date(date);
  if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
    result2.setHours(startTime.hours, startTime.minutes, 0, 0);
  }
  return result2;
};
function normalizeDate(date, min, max) {
  let normalizedDate = date;
  if (!isDefined(date)) {
    return date;
  }
  if (isDefined(min) && date < min) {
    normalizedDate = min;
  }
  if (isDefined(max) && date > max) {
    normalizedDate = max;
  }
  return normalizedDate;
}
function fixTimezoneGap(oldDate, newDate) {
  if (!isDefined(oldDate)) {
    return;
  }
  const diff = newDate.getHours() - oldDate.getHours();
  if (0 === diff) {
    return;
  }
  const sign2 = 1 === diff || -23 === diff ? -1 : 1;
  const trial = new Date(newDate.getTime() + 36e5 * sign2);
  if (sign2 > 0 || trial.getDate() === newDate.getDate()) {
    newDate.setTime(trial.getTime());
  }
}
var roundToHour = function(date) {
  const result2 = new Date(date.getTime());
  result2.setHours(result2.getHours() + 1);
  result2.setMinutes(0);
  return result2;
};
function getTimezonesDifference(min, max) {
  return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3;
}
var makeDate = function(date) {
  return new Date(date);
};
var getDatesOfInterval = function(startDate, endDate, step) {
  const result2 = [];
  let currentDate = new Date(startDate.getTime());
  while (currentDate < endDate) {
    result2.push(new Date(currentDate.getTime()));
    currentDate = this.addInterval(currentDate, step);
  }
  return result2;
};
var createDateWithFullYear = function(year) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  const result2 = new Date(year, ...args);
  result2.setFullYear(year);
  return result2;
};
var getMachineTimezoneName = () => {
  const hasIntl2 = "undefined" !== typeof Intl;
  return hasIntl2 ? Intl.DateTimeFormat().resolvedOptions().timeZone : null;
};
var getRangesByDates = (dates) => {
  const datesInMilliseconds = dates.map((value2) => correctDateWithUnitBeginning(value2, "day").getTime());
  const sortedDates = datesInMilliseconds.sort((a, b) => a - b);
  const msInDay = toMilliseconds("day");
  const ranges = [];
  let startDate = sortedDates[0];
  for (let i = 1; i <= sortedDates.length; ++i) {
    const nextDate = sortedDates[i];
    const currentDate = sortedDates[i - 1];
    const isNewRange = nextDate - currentDate > msInDay;
    if (isNewRange || i === sortedDates.length) {
      const range = startDate === sortedDates[i - 1] ? [startDate] : [startDate, sortedDates[i - 1]];
      const serializedRange = range.map((value2) => date_serialization_default.deserializeDate(value2));
      ranges.push(serializedRange);
      startDate = nextDate;
    }
  }
  return ranges;
};
var sameView = function(view, date1, date2) {
  return dateUtils[camelize(`same ${view}`)](date1, date2);
};
var dateUtils = {
  dateUnitIntervals,
  convertMillisecondsToDateUnits,
  dateToMilliseconds,
  getNextDateUnit,
  convertDateUnitToMilliseconds,
  getDateUnitInterval,
  getDateFormatByTickInterval,
  getDatesDifferences,
  correctDateWithUnitBeginning,
  trimTime,
  setToDayEnd,
  roundDateByStartDayHour,
  dateTimeFromDecimal,
  addDateInterval,
  addInterval,
  getSequenceByInterval,
  getDateIntervalByString,
  sameHoursAndMinutes,
  sameDate,
  sameMonthAndYear,
  sameMonth: sameMonthAndYear,
  sameYear,
  sameDecade,
  sameCentury,
  sameView,
  sameDatesArrays,
  getDifferenceInMonth,
  getDifferenceInMonthForCells,
  getFirstYearInDecade,
  getFirstDecadeInCentury,
  getShortDateFormat,
  getViewFirstCellDate,
  getViewLastCellDate,
  getViewDown,
  getViewUp,
  getLastMonthDay,
  getLastMonthDate,
  getFirstMonthDate,
  getFirstWeekDate,
  getWeekNumber,
  normalizeDateByWeek,
  getQuarter,
  getFirstQuarterMonth,
  dateInRange,
  intervalsOverlap,
  roundToHour,
  normalizeDate,
  getViewMinBoundaryDate,
  getViewMaxBoundaryDate,
  fixTimezoneGap,
  getTimezonesDifference,
  makeDate,
  getDatesInterval,
  getDatesOfInterval,
  createDateWithFullYear,
  getMachineTimezoneName,
  getRangesByDates
};

// node_modules/devextreme/esm/core/utils/date.js
var date_default = dateUtils;

// node_modules/devextreme/esm/__internal/scheduler/m_date_adapter.js
var toMs = date_default.dateToMilliseconds;
var DateAdapterCore = class {
  constructor(source) {
    this._source = new Date(source.getTime ? source.getTime() : source);
  }
  get source() {
    return this._source;
  }
  result() {
    return this._source;
  }
  getTimezoneOffset() {
    let format2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    const value2 = this._source.getTimezoneOffset();
    if ("minute" === format2) {
      return value2 * toMs("minute");
    }
    return value2;
  }
  getTime() {
    return this._source.getTime();
  }
  setTime(value2) {
    this._source.setTime(value2);
    return this;
  }
  addTime(value2) {
    this._source.setTime(this._source.getTime() + value2);
    return this;
  }
  setMinutes(value2) {
    this._source.setMinutes(value2);
    return this;
  }
  addMinutes(value2) {
    this._source.setMinutes(this._source.getMinutes() + value2);
    return this;
  }
  subtractMinutes(value2) {
    this._source.setMinutes(this._source.getMinutes() - value2);
    return this;
  }
};
var DateAdapter = (date) => new DateAdapterCore(date);
var m_date_adapter_default = DateAdapter;

// node_modules/devextreme/esm/__internal/scheduler/timezones/m_utils_timezones_data.js
var getConvertedUntils = (value2) => value2.split("|").map((until) => {
  if ("Infinity" === until) {
    return null;
  }
  return 1e3 * parseInt(until, 36);
});
var parseTimezone = (timeZoneConfig) => {
  const {
    offsets
  } = timeZoneConfig;
  const {
    offsetIndices
  } = timeZoneConfig;
  const {
    untils
  } = timeZoneConfig;
  const offsetList = offsets.split("|").map((value2) => parseInt(value2));
  const offsetIndexList = offsetIndices.split("").map((value2) => parseInt(value2));
  const dateList = getConvertedUntils(untils).map((accumulator = 0, (value2) => accumulator += value2));
  var accumulator;
  return {
    offsetList,
    offsetIndexList,
    dateList
  };
};
var TimeZoneCache = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  tryGet(id) {
    if (!this.map.get(id)) {
      const config3 = timeZoneDataUtils.getTimezoneById(id);
      if (!config3) {
        return false;
      }
      const timeZoneInfo = parseTimezone(config3);
      this.map.set(id, timeZoneInfo);
    }
    return this.map.get(id);
  }
};
var tzCache = new TimeZoneCache();
var timeZoneDataUtils = {
  _tzCache: tzCache,
  getTimeZonesOld: () => config_default2().timezones ?? [],
  formatOffset(offset2) {
    const hours = Math.floor(offset2);
    const minutesInDecimal = offset2 - hours;
    const signString = sign(offset2) >= 0 ? "+" : "-";
    const hoursString = `0${Math.abs(hours)}`.slice(-2);
    const minutesString = minutesInDecimal > 0 ? ":" + 60 * minutesInDecimal : ":00";
    return signString + hoursString + minutesString;
  },
  formatId: (id) => id.split("/").join(" - ").split("_").join(" "),
  getTimezoneById(id) {
    if (!id) {
      return;
    }
    const tzList = this.getTimeZonesOld();
    for (let i = 0; i < tzList.length; i++) {
      const currentId = tzList[i].id;
      if (currentId === id) {
        return tzList[i];
      }
    }
    return;
  },
  getTimeZoneOffsetById(id, timestamp) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getUtcOffset(timeZoneInfo, timestamp) : void 0;
  },
  getTimeZoneDeclarationTuple(id, year) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getTimeZoneDeclarationTupleCore(timeZoneInfo, year) : [];
  },
  getTimeZoneDeclarationTupleCore(timeZoneInfo, year) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const tupleResult = [];
    for (let i = 0; i < dateList.length; i++) {
      const currentDate = dateList[i];
      const currentYear = new Date(currentDate).getFullYear();
      if (currentYear === year) {
        const offset2 = offsetList[offsetIndexList[i + 1]];
        tupleResult.push({
          date: currentDate,
          offset: -offset2 / 60
        });
      }
      if (currentYear > year) {
        break;
      }
    }
    return tupleResult;
  },
  getUtcOffset(timeZoneInfo, dateTimeStamp) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const lastIntervalStartIndex = dateList.length - 1 - 1;
    let index2 = lastIntervalStartIndex;
    while (index2 >= 0 && dateTimeStamp < dateList[index2]) {
      index2--;
    }
    const offset2 = offsetList[offsetIndexList[index2 + 1]];
    return -offset2 / 60 || offset2;
  }
};
var m_utils_timezones_data_default = timeZoneDataUtils;

// node_modules/devextreme/esm/__internal/scheduler/timezones/timezone_list.js
var timezone_list_default = {
  value: ["Etc/GMT+12", "Etc/GMT+11", "Pacific/Midway", "Pacific/Niue", "Pacific/Pago_Pago", "Pacific/Samoa", "US/Samoa", "Etc/GMT+10", "HST", "Pacific/Honolulu", "Pacific/Johnston", "Pacific/Rarotonga", "Pacific/Tahiti", "US/Hawaii", "Pacific/Marquesas", "America/Adak", "America/Atka", "Etc/GMT+9", "Pacific/Gambier", "US/Aleutian", "America/Anchorage", "America/Juneau", "America/Metlakatla", "America/Nome", "America/Sitka", "America/Yakutat", "Etc/GMT+8", "Pacific/Pitcairn", "US/Alaska", "America/Creston", "America/Dawson_Creek", "America/Dawson", "America/Ensenada", "America/Fort_Nelson", "America/Hermosillo", "America/Los_Angeles", "America/Phoenix", "America/Santa_Isabel", "America/Tijuana", "America/Vancouver", "America/Whitehorse", "Canada/Pacific", "Canada/Yukon", "Etc/GMT+7", "Mexico/BajaNorte", "MST", "PST8PDT", "US/Arizona", "US/Pacific", "America/Belize", "America/Boise", "America/Cambridge_Bay", "America/Chihuahua", "America/Costa_Rica", "America/Denver", "America/Edmonton", "America/El_Salvador", "America/Guatemala", "America/Inuvik", "America/Managua", "America/Mazatlan", "America/Monterrey", "America/Ojinaga", "America/Regina", "America/Shiprock", "America/Swift_Current", "America/Tegucigalpa", "America/Yellowknife", "Canada/Mountain", "Canada/Saskatchewan", "Chile/EasterIsland", "Etc/GMT+6", "Mexico/BajaSur", "MST7MDT", "Navajo", "Pacific/Easter", "Pacific/Galapagos", "US/Mountain", "America/Atikokan", "America/Bahia_Banderas", "America/Bogota", "America/Cancun", "America/Cayman", "America/Chicago", "America/Coral_Harbour", "America/Eirunepe", "America/Guayaquil", "America/Indiana/Knox", "America/Indiana/Tell_City", "America/Jamaica", "America/Knox_IN", "America/Lima", "America/Matamoros", "America/Menominee", "America/Merida", "America/Mexico_City", "America/North_Dakota/Beulah", "America/North_Dakota/Center", "America/North_Dakota/New_Salem", "America/Panama", "America/Porto_Acre", "America/Rainy_River", "America/Rankin_Inlet", "America/Resolute", "America/Rio_Branco", "America/Winnipeg", "Brazil/Acre", "Canada/Central", "CST6CDT", "EST", "Etc/GMT+5", "Jamaica", "Mexico/General", "US/Central", "US/Indiana-Starke", "America/Anguilla", "America/Antigua", "America/Aruba", "America/Asuncion", "America/Barbados", "America/Blanc-Sablon", "America/Boa_Vista", "America/Campo_Grande", "America/Caracas", "America/Cuiaba", "America/Curacao", "America/Detroit", "America/Dominica", "America/Fort_Wayne", "America/Grand_Turk", "America/Grenada", "America/Guadeloupe", "America/Guyana", "America/Havana", "America/Indiana/Indianapolis", "America/Indiana/Marengo", "America/Indiana/Petersburg", "America/Indiana/Vevay", "America/Indiana/Vincennes", "America/Indiana/Winamac", "America/Indianapolis", "America/Iqaluit", "America/Kentucky/Louisville", "America/Kentucky/Monticello", "America/Kralendijk", "America/La_Paz", "America/Louisville", "America/Lower_Princes", "America/Manaus", "America/Marigot", "America/Martinique", "America/Montreal", "America/Montserrat", "America/Nassau", "America/New_York", "America/Nipigon", "America/Pangnirtung", "America/Port_of_Spain", "America/Port-au-Prince", "America/Porto_Velho", "America/Puerto_Rico", "America/Santiago", "America/Santo_Domingo", "America/St_Barthelemy", "America/St_Kitts", "America/St_Lucia", "America/St_Thomas", "America/St_Vincent", "America/Thunder_Bay", "America/Toronto", "America/Tortola", "America/Virgin", "Brazil/West", "Canada/Eastern", "Chile/Continental", "Cuba", "EST5EDT", "Etc/GMT+4", "US/East-Indiana", "US/Eastern", "US/Michigan", "America/Araguaina", "America/Argentina/Buenos_Aires", "America/Argentina/Catamarca", "America/Argentina/ComodRivadavia", "America/Argentina/Cordoba", "America/Argentina/Jujuy", "America/Argentina/La_Rioja", "America/Argentina/Mendoza", "America/Argentina/Rio_Gallegos", "America/Argentina/Salta", "America/Argentina/San_Juan", "America/Argentina/San_Luis", "America/Argentina/Tucuman", "America/Argentina/Ushuaia", "America/Bahia", "America/Belem", "America/Buenos_Aires", "America/Catamarca", "America/Cayenne", "America/Cordoba", "America/Fortaleza", "America/Glace_Bay", "America/Goose_Bay", "America/Halifax", "America/Jujuy", "America/Maceio", "America/Mendoza", "America/Moncton", "America/Montevideo", "America/Paramaribo", "America/Punta_Arenas", "America/Recife", "America/Rosario", "America/Santarem", "America/Sao_Paulo", "America/Thule", "Antarctica/Palmer", "Antarctica/Rothera", "Atlantic/Bermuda", "Atlantic/Stanley", "Brazil/East", "Canada/Atlantic", "Etc/GMT+3", "America/St_Johns", "Canada/Newfoundland", "America/Godthab", "America/Miquelon", "America/Noronha", "America/Nuuk", "Atlantic/South_Georgia", "Brazil/DeNoronha", "Etc/GMT+2", "Atlantic/Cape_Verde", "Etc/GMT+1", "Africa/Abidjan", "Africa/Accra", "Africa/Bamako", "Africa/Banjul", "Africa/Bissau", "Africa/Conakry", "Africa/Dakar", "Africa/Freetown", "Africa/Lome", "Africa/Monrovia", "Africa/Nouakchott", "Africa/Ouagadougou", "Africa/Sao_Tome", "Africa/Timbuktu", "America/Danmarkshavn", "America/Scoresbysund", "Atlantic/Azores", "Atlantic/Reykjavik", "Atlantic/St_Helena", "Etc/GMT-0", "Etc/GMT", "Etc/GMT+0", "Etc/GMT0", "Etc/Greenwich", "Etc/UCT", "Etc/Universal", "Etc/UTC", "Etc/Zulu", "GMT-0", "GMT", "GMT+0", "GMT0", "Greenwich", "Iceland", "UCT", "Universal", "UTC", "Zulu", "Africa/Algiers", "Africa/Bangui", "Africa/Brazzaville", "Africa/Casablanca", "Africa/Douala", "Africa/El_Aaiun", "Africa/Kinshasa", "Africa/Lagos", "Africa/Libreville", "Africa/Luanda", "Africa/Malabo", "Africa/Ndjamena", "Africa/Niamey", "Africa/Porto-Novo", "Africa/Tunis", "Atlantic/Canary", "Atlantic/Faeroe", "Atlantic/Faroe", "Atlantic/Madeira", "Eire", "Etc/GMT-1", "Europe/Belfast", "Europe/Dublin", "Europe/Guernsey", "Europe/Isle_of_Man", "Europe/Jersey", "Europe/Lisbon", "Europe/London", "GB-Eire", "GB", "Portugal", "WET", "Africa/Blantyre", "Africa/Bujumbura", "Africa/Cairo", "Africa/Ceuta", "Africa/Gaborone", "Africa/Harare", "Africa/Johannesburg", "Africa/Khartoum", "Africa/Kigali", "Africa/Lubumbashi", "Africa/Lusaka", "Africa/Maputo", "Africa/Maseru", "Africa/Mbabane", "Africa/Tripoli", "Africa/Windhoek", "Antarctica/Troll", "Arctic/Longyearbyen", "Atlantic/Jan_Mayen", "CET", "Egypt", "Etc/GMT-2", "Europe/Amsterdam", "Europe/Andorra", "Europe/Belgrade", "Europe/Berlin", "Europe/Bratislava", "Europe/Brussels", "Europe/Budapest", "Europe/Busingen", "Europe/Copenhagen", "Europe/Gibraltar", "Europe/Kaliningrad", "Europe/Ljubljana", "Europe/Luxembourg", "Europe/Madrid", "Europe/Malta", "Europe/Monaco", "Europe/Oslo", "Europe/Paris", "Europe/Podgorica", "Europe/Prague", "Europe/Rome", "Europe/San_Marino", "Europe/Sarajevo", "Europe/Skopje", "Europe/Stockholm", "Europe/Tirane", "Europe/Vaduz", "Europe/Vatican", "Europe/Vienna", "Europe/Warsaw", "Europe/Zagreb", "Europe/Zurich", "Libya", "MET", "Poland", "Africa/Addis_Ababa", "Africa/Asmara", "Africa/Asmera", "Africa/Dar_es_Salaam", "Africa/Djibouti", "Africa/Juba", "Africa/Kampala", "Africa/Mogadishu", "Africa/Nairobi", "Antarctica/Syowa", "Asia/Aden", "Asia/Amman", "Asia/Baghdad", "Asia/Bahrain", "Asia/Beirut", "Asia/Damascus", "Asia/Famagusta", "Asia/Gaza", "Asia/Hebron", "Asia/Istanbul", "Asia/Jerusalem", "Asia/Kuwait", "Asia/Nicosia", "Asia/Qatar", "Asia/Riyadh", "Asia/Tel_Aviv", "EET", "Etc/GMT-3", "Europe/Athens", "Europe/Bucharest", "Europe/Chisinau", "Europe/Helsinki", "Europe/Istanbul", "Europe/Kiev", "Europe/Kirov", "Europe/Mariehamn", "Europe/Minsk", "Europe/Moscow", "Europe/Nicosia", "Europe/Riga", "Europe/Simferopol", "Europe/Sofia", "Europe/Tallinn", "Europe/Tiraspol", "Europe/Uzhgorod", "Europe/Vilnius", "Europe/Zaporozhye", "Indian/Antananarivo", "Indian/Comoro", "Indian/Mayotte", "Israel", "Turkey", "W-SU", "Asia/Baku", "Asia/Dubai", "Asia/Muscat", "Asia/Tbilisi", "Asia/Yerevan", "Etc/GMT-4", "Europe/Astrakhan", "Europe/Samara", "Europe/Saratov", "Europe/Ulyanovsk", "Europe/Volgograd", "Indian/Mahe", "Indian/Mauritius", "Indian/Reunion", "Asia/Kabul", "Asia/Tehran", "Iran", "Antarctica/Mawson", "Asia/Aqtau", "Asia/Aqtobe", "Asia/Ashgabat", "Asia/Ashkhabad", "Asia/Atyrau", "Asia/Dushanbe", "Asia/Karachi", "Asia/Oral", "Asia/Qyzylorda", "Asia/Samarkand", "Asia/Tashkent", "Asia/Yekaterinburg", "Etc/GMT-5", "Indian/Kerguelen", "Indian/Maldives", "Asia/Calcutta", "Asia/Colombo", "Asia/Kolkata", "Asia/Kathmandu", "Asia/Katmandu", "Antarctica/Vostok", "Asia/Almaty", "Asia/Bishkek", "Asia/Dacca", "Asia/Dhaka", "Asia/Kashgar", "Asia/Omsk", "Asia/Qostanay", "Asia/Thimbu", "Asia/Thimphu", "Asia/Urumqi", "Etc/GMT-6", "Indian/Chagos", "Asia/Rangoon", "Asia/Yangon", "Indian/Cocos", "Antarctica/Davis", "Asia/Bangkok", "Asia/Barnaul", "Asia/Ho_Chi_Minh", "Asia/Hovd", "Asia/Jakarta", "Asia/Krasnoyarsk", "Asia/Novokuznetsk", "Asia/Novosibirsk", "Asia/Phnom_Penh", "Asia/Pontianak", "Asia/Saigon", "Asia/Tomsk", "Asia/Vientiane", "Etc/GMT-7", "Indian/Christmas", "Antarctica/Casey", "Asia/Brunei", "Asia/Choibalsan", "Asia/Chongqing", "Asia/Chungking", "Asia/Harbin", "Asia/Hong_Kong", "Asia/Irkutsk", "Asia/Kuala_Lumpur", "Asia/Kuching", "Asia/Macao", "Asia/Macau", "Asia/Makassar", "Asia/Manila", "Asia/Shanghai", "Asia/Singapore", "Asia/Taipei", "Asia/Ujung_Pandang", "Asia/Ulaanbaatar", "Asia/Ulan_Bator", "Australia/Perth", "Australia/West", "Etc/GMT-8", "Hongkong", "PRC", "ROC", "Singapore", "Australia/Eucla", "Asia/Chita", "Asia/Dili", "Asia/Jayapura", "Asia/Khandyga", "Asia/Pyongyang", "Asia/Seoul", "Asia/Tokyo", "Asia/Yakutsk", "Etc/GMT-9", "Japan", "Pacific/Palau", "ROK", "Australia/Adelaide", "Australia/Broken_Hill", "Australia/Darwin", "Australia/North", "Australia/South", "Australia/Yancowinna", "Antarctica/DumontDUrville", "Asia/Ust-Nera", "Asia/Vladivostok", "Australia/ACT", "Australia/Brisbane", "Australia/Canberra", "Australia/Currie", "Australia/Hobart", "Australia/Lindeman", "Australia/Melbourne", "Australia/NSW", "Australia/Queensland", "Australia/Sydney", "Australia/Tasmania", "Australia/Victoria", "Etc/GMT-10", "Pacific/Chuuk", "Pacific/Guam", "Pacific/Port_Moresby", "Pacific/Saipan", "Pacific/Truk", "Pacific/Yap", "Australia/LHI", "Australia/Lord_Howe", "Antarctica/Macquarie", "Asia/Magadan", "Asia/Sakhalin", "Asia/Srednekolymsk", "Etc/GMT-11", "Pacific/Bougainville", "Pacific/Efate", "Pacific/Guadalcanal", "Pacific/Kosrae", "Pacific/Norfolk", "Pacific/Noumea", "Pacific/Pohnpei", "Pacific/Ponape", "Antarctica/McMurdo", "Antarctica/South_Pole", "Asia/Anadyr", "Asia/Kamchatka", "Etc/GMT-12", "Kwajalein", "NZ", "Pacific/Auckland", "Pacific/Fiji", "Pacific/Funafuti", "Pacific/Kwajalein", "Pacific/Majuro", "Pacific/Nauru", "Pacific/Tarawa", "Pacific/Wake", "Pacific/Wallis", "NZ-CHAT", "Pacific/Chatham", "Etc/GMT-13", "Pacific/Apia", "Pacific/Enderbury", "Pacific/Fakaofo", "Pacific/Tongatapu", "Etc/GMT-14", "Pacific/Kiritimati"]
};

// node_modules/devextreme/esm/__internal/scheduler/m_utils_time_zone.js
var toMs2 = date_default.dateToMilliseconds;
var GMT = "GMT";
var offsetFormatRegexp = /^GMT(?:[+-]\d{2}:\d{2})?$/;
var createUTCDateWithLocalOffset = (date) => {
  if (!date) {
    return null;
  }
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
};
var createDateFromUTCWithLocalOffset = (date) => {
  const result2 = m_date_adapter_default(date);
  const timezoneOffsetBeforeInMin = result2.getTimezoneOffset();
  result2.addTime(result2.getTimezoneOffset("minute"));
  result2.subtractMinutes(timezoneOffsetBeforeInMin - result2.getTimezoneOffset());
  return result2.source;
};
var createUTCDate = (date) => new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()));
var getTimezoneOffsetChangeInMinutes = (startDate, endDate, updatedStartDate, updatedEndDate) => getDaylightOffset(updatedStartDate, updatedEndDate) - getDaylightOffset(startDate, endDate);
var getTimezoneOffsetChangeInMs = (startDate, endDate, updatedStartDate, updatedEndDate) => getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) * toMs2("minute");
var getDaylightOffset = (startDate, endDate) => new Date(startDate).getTimezoneOffset() - new Date(endDate).getTimezoneOffset();
var getDaylightOffsetInMs = (startDate, endDate) => getDaylightOffset(startDate, endDate) * toMs2("minute");
var calculateTimezoneByValueOld = function(timezone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  const customTimezones = m_utils_timezones_data_default.getTimeZonesOld();
  if (0 === customTimezones.length) {
    return;
  }
  const dateUtc = createUTCDate(date);
  return m_utils_timezones_data_default.getTimeZoneOffsetById(timezone, dateUtc.getTime());
};
var calculateTimezoneByValueCore = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  const offset2 = getStringOffset(timeZone, date);
  if (void 0 === offset2) {
    return;
  }
  if (offset2 === GMT) {
    return 0;
  }
  const isMinus = "-" === offset2.substring(3, 4);
  const hours = offset2.substring(4, 6);
  const minutes = offset2.substring(7, 9);
  const result2 = parseInt(hours, 10) + parseInt(minutes, 10) / 60;
  return isMinus ? -result2 : result2;
};
var calculateTimezoneByValue = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (!timeZone) {
    return;
  }
  const isValidTimezone = timezone_list_default.value.includes(timeZone);
  if (!isValidTimezone) {
    errors_default.log("W0009", timeZone);
    return;
  }
  if (!dateUtilsTs.isValidDate(date)) {
    return;
  }
  let result2 = calculateTimezoneByValueOld(timeZone, date);
  if (void 0 === result2) {
    result2 = calculateTimezoneByValueCore(timeZone, date);
  }
  return result2;
};
var getStringOffset = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  let result2 = "";
  try {
    var _dateTimeFormat$forma;
    const dateTimeFormat = new Intl.DateTimeFormat("en-US", {
      timeZone,
      timeZoneName: "longOffset"
    });
    result2 = (null === (_dateTimeFormat$forma = dateTimeFormat.formatToParts(date).find((_ref) => {
      let {
        type: type2
      } = _ref;
      return "timeZoneName" === type2;
    })) || void 0 === _dateTimeFormat$forma ? void 0 : _dateTimeFormat$forma.value) ?? "";
  } catch (e) {
    errors_default.log("W0009", timeZone);
    return;
  }
  const isSupportedFormat = offsetFormatRegexp.test(result2);
  if (!isSupportedFormat) {
    errors_default.log("W0009", timeZone);
    return;
  }
  return result2;
};
var getOffsetNamePart = (offset2) => {
  if (offset2 === GMT) {
    return `${offset2} +00:00`;
  }
  return offset2.replace(GMT, `${GMT} `);
};
var getTimezoneTitle = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (!dateUtilsTs.isValidDate(date)) {
    return "";
  }
  const tzNamePart = timeZone.replace(/\//g, " - ").replace(/_/g, " ");
  const offset2 = getStringOffset(timeZone, date);
  if (void 0 === offset2) {
    return;
  }
  const offsetNamePart = getOffsetNamePart(offset2);
  return `(${offsetNamePart}) ${tzNamePart}`;
};
var _getDaylightOffsetByTimezone = (startDate, endDate, timeZone) => {
  const startDayOffset = calculateTimezoneByValue(timeZone, startDate);
  const endDayOffset = calculateTimezoneByValue(timeZone, endDate);
  if (void 0 === startDayOffset || void 0 === endDayOffset) {
    return 0;
  }
  return startDayOffset - endDayOffset;
};
var getCorrectedDateByDaylightOffsets = (convertedOriginalStartDate, convertedDate, date, timeZone, startDateTimezone) => {
  const daylightOffsetByCommonTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, timeZone);
  const daylightOffsetByAppointmentTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, startDateTimezone);
  const diff = daylightOffsetByCommonTimezone - daylightOffsetByAppointmentTimezone;
  return new Date(date.getTime() - diff * toMs2("hour"));
};
var correctRecurrenceExceptionByTimezone = function(exception, exceptionByStartDate, timeZone, startDateTimeZone) {
  let isBackConversion = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let timezoneOffset = (exception.getTimezoneOffset() - exceptionByStartDate.getTimezoneOffset()) / 60;
  if (startDateTimeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, startDateTimeZone);
  } else if (timeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, timeZone);
  }
  return new Date(exception.getTime() + (isBackConversion ? -1 : 1) * timezoneOffset * toMs2("hour"));
};
var isTimezoneChangeInDate = (date) => {
  const startDayDate = new Date(new Date(date).setHours(0, 0, 0, 0));
  const endDayDate = new Date(new Date(date).setHours(23, 59, 59, 0));
  return startDayDate.getTimezoneOffset() - endDayDate.getTimezoneOffset() !== 0;
};
var getDateWithoutTimezoneChange = (date) => {
  const clonedDate = new Date(date);
  if (isTimezoneChangeInDate(clonedDate)) {
    const result2 = new Date(clonedDate);
    return new Date(result2.setDate(result2.getDate() + 1));
  }
  return clonedDate;
};
var isSameAppointmentDates = (startDate, endDate) => {
  endDate = new Date(endDate.getTime() - 1);
  return date_default.sameDate(startDate, endDate);
};
var getClientTimezoneOffset = function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  return 6e4 * date.getTimezoneOffset();
};
var getDiffBetweenClientTimezoneOffsets = function() {
  let firstDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  let secondDate = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  return getClientTimezoneOffset(firstDate) - getClientTimezoneOffset(secondDate);
};
var isEqualLocalTimeZone = function(timeZoneName) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (Intl) {
    const localTimeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
    if (localTimeZoneName === timeZoneName) {
      return true;
    }
  }
  return isEqualLocalTimeZoneByDeclaration(timeZoneName, date);
};
var hasDSTInLocalTimeZone = () => {
  const [startDate, endDate] = getExtremeDates();
  return startDate.getTimezoneOffset() !== endDate.getTimezoneOffset();
};
var getOffset2 = (date) => -date.getTimezoneOffset() / 60;
var getDateAndMoveHourBack = (dateStamp) => new Date(dateStamp - toMs2("hour"));
var isEqualLocalTimeZoneByDeclarationOld = (timeZoneName, date) => {
  const year = date.getFullYear();
  const configTuple = m_utils_timezones_data_default.getTimeZoneDeclarationTuple(timeZoneName, year);
  const [summerTime, winterTime] = configTuple;
  const noDSTInTargetTimeZone = configTuple.length < 2;
  if (noDSTInTargetTimeZone) {
    const targetTimeZoneOffset = m_utils_timezones_data_default.getTimeZoneOffsetById(timeZoneName, date);
    const localTimeZoneOffset = getOffset2(date);
    if (targetTimeZoneOffset !== localTimeZoneOffset) {
      return false;
    }
    return !hasDSTInLocalTimeZone();
  }
  const localSummerOffset = getOffset2(new Date(summerTime.date));
  const localWinterOffset = getOffset2(new Date(winterTime.date));
  if (localSummerOffset !== summerTime.offset) {
    return false;
  }
  if (localSummerOffset === getOffset2(getDateAndMoveHourBack(summerTime.date))) {
    return false;
  }
  if (localWinterOffset !== winterTime.offset) {
    return false;
  }
  if (localWinterOffset === getOffset2(getDateAndMoveHourBack(winterTime.date))) {
    return false;
  }
  return true;
};
var isEqualLocalTimeZoneByDeclaration = (timeZoneName, date) => {
  const customTimezones = m_utils_timezones_data_default.getTimeZonesOld();
  const targetTimezoneData = customTimezones.filter((tz) => tz.id === timeZoneName);
  if (1 === targetTimezoneData.length) {
    return isEqualLocalTimeZoneByDeclarationOld(timeZoneName, date);
  }
  return false;
};
var getExtremeDates = () => {
  const nowDate = new Date(Date.now());
  const startDate = /* @__PURE__ */ new Date();
  const endDate = /* @__PURE__ */ new Date();
  startDate.setFullYear(nowDate.getFullYear(), 0, 1);
  endDate.setFullYear(nowDate.getFullYear(), 6, 1);
  return [startDate, endDate];
};
var setOffsetsToDate = (targetDate, offsetsArray) => {
  const newDateMs = offsetsArray.reduce((result2, offset2) => result2 + offset2, targetDate.getTime());
  return new Date(newDateMs);
};
var addOffsetsWithoutDST = function(date) {
  for (var _len = arguments.length, offsets = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    offsets[_key - 1] = arguments[_key];
  }
  const newDate = dateUtilsTs.addOffsets(date, offsets);
  const daylightShift = getDaylightOffsetInMs(date, newDate);
  if (!daylightShift) {
    return newDate;
  }
  const correctLocalDate = dateUtilsTs.addOffsets(newDate, [-daylightShift]);
  const daylightSecondShift = getDaylightOffsetInMs(newDate, correctLocalDate);
  return !daylightSecondShift ? correctLocalDate : newDate;
};
var getTimeZones = function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  let timeZones = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : timezone_list_default.value;
  return timeZones.map((timezoneId) => ({
    id: timezoneId,
    title: getTimezoneTitle(timezoneId, date),
    offset: calculateTimezoneByValue(timezoneId, date)
  }));
};
var timeZoneDataCache = [];
var timeZoneDataCachePromise;
var cacheTimeZones = async function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  if (timeZoneDataCachePromise) {
    return timeZoneDataCachePromise;
  }
  timeZoneDataCachePromise = macro_task_array_default.map(timezone_list_default.value, (timezoneId) => ({
    id: timezoneId,
    title: getTimezoneTitle(timezoneId, date)
  }), 10);
  timeZoneDataCache = await timeZoneDataCachePromise;
  return timeZoneDataCache;
};
var getTimeZonesCache = () => timeZoneDataCache;
var utils = {
  getDaylightOffset,
  getDaylightOffsetInMs,
  getTimezoneOffsetChangeInMinutes,
  getTimezoneOffsetChangeInMs,
  calculateTimezoneByValue,
  getCorrectedDateByDaylightOffsets,
  isSameAppointmentDates,
  correctRecurrenceExceptionByTimezone,
  getClientTimezoneOffset,
  getDiffBetweenClientTimezoneOffsets,
  createUTCDateWithLocalOffset,
  createDateFromUTCWithLocalOffset,
  createUTCDate,
  isTimezoneChangeInDate,
  getDateWithoutTimezoneChange,
  hasDSTInLocalTimeZone,
  isEqualLocalTimeZone,
  isEqualLocalTimeZoneByDeclaration,
  setOffsetsToDate,
  addOffsetsWithoutDST,
  getTimeZones,
  getTimeZonesCache,
  cacheTimeZones
};
var m_utils_time_zone_default = utils;

// node_modules/devextreme/esm/common/core/environment/time_zone_utils.js
var getTimeZones2 = m_utils_time_zone_default.getTimeZones;

// node_modules/devextreme/esm/core/devices.js
var devices_default = m_devices_default;

// node_modules/devextreme/esm/common/core/animation/position.js
var window8 = getWindow();
var horzRe = /left|right/;
var vertRe = /top|bottom/;
var collisionRe = /fit|flip|none/;
var scaleRe = /scale\(.+?\)/;
var IS_SAFARI = browser_default.safari;
var normalizeAlign = function(raw) {
  const result2 = {
    h: "center",
    v: "center"
  };
  const pair = splitPair(raw);
  if (pair) {
    each(pair, function() {
      const w = String(this).toLowerCase();
      if (horzRe.test(w)) {
        result2.h = w;
      } else if (vertRe.test(w)) {
        result2.v = w;
      }
    });
  }
  return result2;
};
var normalizeOffset = function(raw, preventRound) {
  return pairToObject(raw, preventRound);
};
var normalizeCollision = function(raw) {
  const pair = splitPair(raw);
  let h = String(pair && pair[0]).toLowerCase();
  let v = String(pair && pair[1]).toLowerCase();
  if (!collisionRe.test(h)) {
    h = "none";
  }
  if (!collisionRe.test(v)) {
    v = h;
  }
  return {
    h,
    v
  };
};
var getAlignFactor = function(align) {
  switch (align) {
    case "center":
      return 0.5;
    case "right":
    case "bottom":
      return 1;
    default:
      return 0;
  }
};
var inverseAlign = function(align) {
  switch (align) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    default:
      return align;
  }
};
var calculateOversize = function(data2, bounds) {
  let oversize = 0;
  if (data2.myLocation < bounds.min) {
    oversize += bounds.min - data2.myLocation;
  }
  if (data2.myLocation > bounds.max) {
    oversize += data2.myLocation - bounds.max;
  }
  return oversize;
};
var collisionSide = function(direction, data2, bounds) {
  if (data2.myLocation < bounds.min) {
    return "h" === direction ? "left" : "top";
  }
  if (data2.myLocation > bounds.max) {
    return "h" === direction ? "right" : "bottom";
  }
  return "none";
};
var initMyLocation = function(data2) {
  data2.myLocation = data2.atLocation + getAlignFactor(data2.atAlign) * data2.atSize - getAlignFactor(data2.myAlign) * data2.mySize + data2.offset;
};
var collisionResolvers = {
  fit: function(data2, bounds) {
    let result2 = false;
    if (data2.myLocation > bounds.max) {
      data2.myLocation = bounds.max;
      result2 = true;
    }
    if (data2.myLocation < bounds.min) {
      data2.myLocation = bounds.min;
      result2 = true;
    }
    data2.fit = result2;
  },
  flip: function(data2, bounds) {
    data2.flip = false;
    if ("center" === data2.myAlign && "center" === data2.atAlign) {
      return;
    }
    if (data2.myLocation < bounds.min || data2.myLocation > bounds.max) {
      const inverseData = extend({}, data2, {
        myAlign: inverseAlign(data2.myAlign),
        atAlign: inverseAlign(data2.atAlign),
        offset: -data2.offset
      });
      initMyLocation(inverseData);
      inverseData.oversize = calculateOversize(inverseData, bounds);
      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data2.oversize > inverseData.oversize) {
        data2.myLocation = inverseData.myLocation;
        data2.oversize = inverseData.oversize;
        data2.flip = true;
      }
    }
  },
  flipfit: function(data2, bounds) {
    this.flip(data2, bounds);
    this.fit(data2, bounds);
  },
  none: function(data2) {
    data2.oversize = 0;
  }
};
var scrollbarWidth;
var calculateScrollbarWidth = function() {
  const $scrollDiv = renderer_default("<div>").css({
    width: 100,
    height: 100,
    overflow: "scroll",
    position: "absolute",
    top: -9999
  }).appendTo(renderer_default("body"));
  const result2 = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
  $scrollDiv.remove();
  scrollbarWidth = result2;
};
var defaultPositionResult = {
  h: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  },
  v: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  }
};
var calculatePosition = function(what, options2) {
  const $what = renderer_default(what);
  const currentOffset = $what.offset();
  const result2 = extend(true, {}, defaultPositionResult, {
    h: {
      location: currentOffset.left
    },
    v: {
      location: currentOffset.top
    }
  });
  if (!options2) {
    return result2;
  }
  const my = normalizeAlign(options2.my);
  const at = normalizeAlign(options2.at);
  let of = renderer_default(options2.of).length && options2.of || window8;
  const offset2 = normalizeOffset(options2.offset, options2.precise);
  const collision = normalizeCollision(options2.collision);
  const boundary = options2.boundary;
  const boundaryOffset = normalizeOffset(options2.boundaryOffset, options2.precise);
  const h = {
    mySize: getOuterWidth($what),
    myAlign: my.h,
    atAlign: at.h,
    offset: offset2.h,
    collision: collision.h,
    boundaryOffset: boundaryOffset.h
  };
  const v = {
    mySize: getOuterHeight($what),
    myAlign: my.v,
    atAlign: at.v,
    offset: offset2.v,
    collision: collision.v,
    boundaryOffset: boundaryOffset.v
  };
  if (of.preventDefault) {
    h.atLocation = of.pageX;
    v.atLocation = of.pageY;
    h.atSize = 0;
    v.atSize = 0;
  } else {
    of = renderer_default(of);
    if (isWindow(of[0])) {
      h.atLocation = of.scrollLeft();
      v.atLocation = of.scrollTop();
      if ("phone" === devices_default.real().deviceType && of[0].visualViewport) {
        h.atLocation = Math.max(h.atLocation, of[0].visualViewport.offsetLeft);
        v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);
        h.atSize = of[0].visualViewport.width;
        v.atSize = of[0].visualViewport.height;
      } else {
        h.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : getWidth(of);
        v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : getHeight(of);
      }
    } else if (9 === of[0].nodeType) {
      h.atLocation = 0;
      v.atLocation = 0;
      h.atSize = getWidth(of);
      v.atSize = getHeight(of);
    } else {
      const ofRect = getBoundingRect(of.get(0));
      const o = getOffsetWithoutScale(of);
      h.atLocation = o.left;
      v.atLocation = o.top;
      h.atSize = Math.max(ofRect.width, getOuterWidth(of));
      v.atSize = Math.max(ofRect.height, getOuterHeight(of));
    }
  }
  initMyLocation(h);
  initMyLocation(v);
  const bounds = function() {
    const win = renderer_default(window8);
    const windowWidth = getWidth(win);
    const windowHeight = getHeight(win);
    let left = win.scrollLeft();
    let top = win.scrollTop();
    const documentElement = dom_adapter_default.getDocumentElement();
    const hZoomLevel = touch ? documentElement.clientWidth / windowWidth : 1;
    const vZoomLevel = touch ? documentElement.clientHeight / windowHeight : 1;
    if (void 0 === scrollbarWidth) {
      calculateScrollbarWidth();
    }
    let boundaryWidth = windowWidth;
    let boundaryHeight = windowHeight;
    if (boundary && !isWindow(boundary)) {
      const $boundary = renderer_default(boundary);
      const boundaryPosition = $boundary.offset();
      left = boundaryPosition.left;
      top = boundaryPosition.top;
      boundaryWidth = getWidth($boundary);
      boundaryHeight = getHeight($boundary);
    }
    return {
      h: {
        min: left + h.boundaryOffset,
        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
      },
      v: {
        min: top + v.boundaryOffset,
        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
      }
    };
  }();
  h.oversize = calculateOversize(h, bounds.h);
  v.oversize = calculateOversize(v, bounds.v);
  h.collisionSide = collisionSide("h", h, bounds.h);
  v.collisionSide = collisionSide("v", v, bounds.v);
  if (collisionResolvers[h.collision]) {
    collisionResolvers[h.collision](h, bounds.h);
  }
  if (collisionResolvers[v.collision]) {
    collisionResolvers[v.collision](v, bounds.v);
  }
  const preciser = function(number) {
    return options2.precise ? number : Math.round(number);
  };
  extend(true, result2, {
    h: {
      location: preciser(h.myLocation),
      oversize: preciser(h.oversize),
      fit: h.fit,
      flip: h.flip,
      collisionSide: h.collisionSide
    },
    v: {
      location: preciser(v.myLocation),
      oversize: preciser(v.oversize),
      fit: v.fit,
      flip: v.flip,
      collisionSide: v.collisionSide
    },
    precise: options2.precise
  });
  return result2;
};
var setScaleProperty = function(element, scale, styleAttr, isEmpty2) {
  const stylePropIsValid = isDefined(element.style) && !dom_adapter_default.isNode(element.style);
  const newStyleValue = isEmpty2 ? styleAttr.replace(scale, "") : styleAttr;
  if (stylePropIsValid) {
    setStyle(element, newStyleValue, false);
  } else {
    const styleAttributeNode = dom_adapter_default.createAttribute("style");
    styleAttributeNode.value = newStyleValue;
    element.setAttributeNode(styleAttributeNode);
  }
};
var getOffsetWithoutScale = function($startElement) {
  var _currentElement$getAt, _style$match;
  let $currentElement = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : $startElement;
  const currentElement = $currentElement.get(0);
  if (!currentElement) {
    return $startElement.offset();
  }
  const style = (null === (_currentElement$getAt = currentElement.getAttribute) || void 0 === _currentElement$getAt ? void 0 : _currentElement$getAt.call(currentElement, "style")) || "";
  const scale = null === (_style$match = style.match(scaleRe)) || void 0 === _style$match ? void 0 : _style$match[0];
  let offset2;
  if (scale) {
    setScaleProperty(currentElement, scale, style, true);
    offset2 = getOffsetWithoutScale($startElement, $currentElement.parent());
    setScaleProperty(currentElement, scale, style, false);
  } else {
    offset2 = getOffsetWithoutScale($startElement, $currentElement.parent());
  }
  return offset2;
};
var position = function(what, options2) {
  const $what = renderer_default(what);
  if (!options2) {
    return $what.offset();
  }
  resetPosition($what, true);
  const offset2 = getOffsetWithoutScale($what);
  const targetPosition = options2.h && options2.v ? options2 : calculatePosition($what, options2);
  const preciser = function(number) {
    return options2.precise ? number : Math.round(number);
  };
  move($what, {
    left: targetPosition.h.location - preciser(offset2.left),
    top: targetPosition.v.location - preciser(offset2.top)
  });
  return targetPosition;
};
var offset = function(element) {
  element = renderer_default(element).get(0);
  if (isWindow(element)) {
    return null;
  } else if (element && "pageY" in element && "pageX" in element) {
    return {
      top: element.pageY,
      left: element.pageX
    };
  }
  return renderer_default(element).offset();
};
if (!position.inverseAlign) {
  position.inverseAlign = inverseAlign;
}
if (!position.normalizeAlign) {
  position.normalizeAlign = normalizeAlign;
}
var position_default = {
  calculateScrollbarWidth,
  calculate: calculatePosition,
  setup: position,
  offset
};

// node_modules/devextreme/esm/ui/widget/selectors.js
var focusableFn = function(element, tabIndex) {
  if (!visible(element)) {
    return false;
  }
  const nodeName = element.nodeName.toLowerCase();
  const isTabIndexNotNaN = !isNaN(tabIndex);
  const isDisabled = element.disabled;
  const isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
  const isHyperlink = "a" === nodeName;
  let isFocusable;
  const isContentEditable = element.isContentEditable;
  if (isDefaultFocus || isContentEditable) {
    isFocusable = !isDisabled;
  } else if (isHyperlink) {
    isFocusable = element.href || isTabIndexNotNaN;
  } else {
    isFocusable = isTabIndexNotNaN;
  }
  return isFocusable;
};
function visible(element) {
  const $element = renderer_default(element);
  return $element.is(":visible") && "hidden" !== $element.css("visibility") && "hidden" !== $element.parents().css("visibility");
}
var focusable = function(index2, element) {
  return focusableFn(element, renderer_default(element).attr("tabIndex"));
};
var tabbable = function(index2, element) {
  const tabIndex = renderer_default(element).attr("tabIndex");
  return (isNaN(tabIndex) || tabIndex >= 0) && focusableFn(element, tabIndex);
};
var focused = function($element) {
  const element = renderer_default($element).get(0);
  return dom_adapter_default.getActiveElement(element) === element;
};

// node_modules/devextreme/esm/__internal/events/utils/m_add_namespace.js
var addNamespace = (eventNames, namespace) => {
  if (!namespace) {
    throw errors_default.Error("E0017");
  }
  if (Array.isArray(eventNames)) {
    return eventNames.map((eventName) => addNamespace(eventName, namespace)).join(" ");
  }
  if (-1 !== eventNames.indexOf(" ")) {
    return addNamespace(eventNames.split(/\s+/g), namespace);
  }
  return `${eventNames}.${namespace}`;
};
var m_add_namespace_default = addNamespace;

// node_modules/devextreme/esm/__internal/events/utils/index.js
var KEY_MAP = {
  backspace: "backspace",
  tab: "tab",
  enter: "enter",
  escape: "escape",
  pageup: "pageUp",
  pagedown: "pageDown",
  end: "end",
  home: "home",
  arrowleft: "leftArrow",
  arrowup: "upArrow",
  arrowright: "rightArrow",
  arrowdown: "downArrow",
  delete: "del",
  " ": "space",
  f: "F",
  a: "A",
  "*": "asterisk",
  "-": "minus",
  alt: "alt",
  control: "control",
  shift: "shift"
};
var LEGACY_KEY_CODES = {
  8: "backspace",
  9: "tab",
  13: "enter",
  27: "escape",
  33: "pageUp",
  34: "pageDown",
  35: "end",
  36: "home",
  37: "leftArrow",
  38: "upArrow",
  39: "rightArrow",
  40: "downArrow",
  46: "del",
  32: "space",
  70: "F",
  65: "A",
  106: "asterisk",
  109: "minus",
  189: "minus",
  173: "minus",
  16: "shift",
  17: "control",
  18: "alt"
};
var EVENT_SOURCES_REGEX = {
  dx: /^dx/i,
  mouse: /(mouse|wheel)/i,
  touch: /^touch/i,
  keyboard: /^key/i,
  pointer: /^(ms)?pointer/i
};
var eventSource = (_ref) => {
  let {
    type: type2
  } = _ref;
  let result2 = "other";
  each(EVENT_SOURCES_REGEX, function(key) {
    if (this.test(type2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
};
var fixMethod = (e) => e;
var getEvent = (originalEvent) => m_events_engine_default.Event(originalEvent, originalEvent);
var copyEvent = (originalEvent) => fixMethod(getEvent(originalEvent), originalEvent);
var isDxEvent = (e) => "dx" === eventSource(e);
var isNativeMouseEvent = (e) => "mouse" === eventSource(e);
var isNativeTouchEvent = (e) => "touch" === eventSource(e);
var isPointerEvent = (e) => "pointer" === eventSource(e);
var isMouseEvent = (e) => isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "mouse" === e.pointerType;
var isDxMouseWheelEvent = (e) => e && "dxmousewheel" === e.type;
var isTouchEvent = (e) => isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "touch" === e.pointerType;
var eventData = (_ref3) => {
  let {
    pageX,
    pageY,
    timeStamp
  } = _ref3;
  return {
    x: pageX,
    y: pageY,
    time: timeStamp
  };
};
var eventDelta = (from, to) => ({
  x: to.x - from.x,
  y: to.y - from.y,
  time: to.time - from.time || 1
});
var hasTouches = (e) => {
  const {
    originalEvent,
    pointers
  } = e;
  if (isNativeTouchEvent(e)) {
    return (originalEvent.touches || []).length;
  }
  if (isDxEvent(e)) {
    return (pointers || []).length;
  }
  return 0;
};
var skipEvents = false;
var needSkipEvent = (e) => {
  if (skipEvents) {
    return true;
  }
  const {
    target
  } = e;
  const $target = renderer_default(target);
  const isContentEditable = (null === target || void 0 === target ? void 0 : target.isContentEditable) || (null === target || void 0 === target ? void 0 : target.hasAttribute("contenteditable"));
  const touchInEditable = $target.is("input, textarea, select") || isContentEditable;
  if (isDxMouseWheelEvent(e)) {
    const isTextArea = $target.is("textarea") && $target.hasClass("dx-texteditor-input");
    if (isTextArea || isContentEditable) {
      return false;
    }
    const isInputFocused = $target.is("input[type='number'], textarea, select") && $target.is(":focus");
    return isInputFocused;
  }
  if (isMouseEvent(e)) {
    return touchInEditable || e.which > 1;
  }
  if (isTouchEvent(e)) {
    return touchInEditable && focused($target);
  }
};
var createEvent = (originalEvent, args) => {
  const event = copyEvent(originalEvent);
  if (args) {
    extend(event, args);
  }
  return event;
};
var fireEvent = (props) => {
  const {
    originalEvent,
    delegateTarget
  } = props;
  const event = createEvent(originalEvent, props);
  m_events_engine_default.trigger(delegateTarget || event.target, event);
  return event;
};
var normalizeKeyName = (_ref4) => {
  let {
    key,
    which
  } = _ref4;
  const normalizedKey = KEY_MAP[null === key || void 0 === key ? void 0 : key.toLowerCase()] || key;
  const normalizedKeyFromWhich = LEGACY_KEY_CODES[which];
  if (normalizedKeyFromWhich && normalizedKey === key) {
    return normalizedKeyFromWhich;
  }
  if (!normalizedKey && which) {
    return String.fromCharCode(which);
  }
  return normalizedKey;
};
var addNamespace2 = m_add_namespace_default;
var isCommandKeyPressed = (_ref6) => {
  let {
    ctrlKey,
    metaKey
  } = _ref6;
  return ctrlKey || metaKey;
};

// node_modules/devextreme/esm/__internal/core/m_element.js
function getPublicElementNonJquery(element) {
  if (element && element.get) {
    return element.get(0);
  }
  return element;
}
var strategy2 = getPublicElementNonJquery;
function getPublicElement(element) {
  return strategy2(element);
}

// node_modules/devextreme/esm/ui/themes_callback.js
var themeReadyCallback = callbacks_default();

// node_modules/devextreme/esm/ui/widget/ui.errors.js
var ui_errors_default = error_default(errors_default.ERROR_MESSAGES, {
  E1001: "Module '{0}'. Controller '{1}' is already registered",
  E1002: "Module '{0}'. Controller '{1}' does not inherit from DevExpress.ui.dxDataGrid.Controller",
  E1003: "Module '{0}'. View '{1}' is already registered",
  E1004: "Module '{0}'. View '{1}' does not inherit from DevExpress.ui.dxDataGrid.View",
  E1005: "Public method '{0}' is already registered",
  E1006: "Public method '{0}.{1}' does not exist",
  E1007: "State storing cannot be provided due to the restrictions of the browser",
  E1010: "The template does not contain the TextBox widget",
  E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
  E1012: "Editing type '{0}' with the name '{1}' is unsupported",
  E1016: "Unexpected type of data source is provided for a lookup column",
  E1018: "The 'collapseAll' method cannot be called if you use a remote data source",
  E1019: "Search mode '{0}' is unavailable",
  E1020: "The type cannot be changed after initialization",
  E1021: "{0} '{1}' you are trying to remove does not exist",
  E1022: 'The "markers" option is given an invalid value. Assign an array instead',
  E1023: 'The "routes" option is given an invalid value. Assign an array instead',
  E1025: "This layout is too complex to render",
  E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
  E1031: "Unknown subscription in the Scheduler widget: '{0}'",
  E1032: "Unknown start date in an appointment: '{0}'",
  E1033: "Unknown step in the date navigator: '{0}'",
  E1034: "The browser does not implement an API for saving files",
  E1035: "The editor cannot be created: {0}",
  E1037: "Invalid structure of grouped data",
  E1038: "The browser does not support local storages for local web pages",
  E1039: "A cell's position cannot be calculated",
  E1040: "The '{0}' key value is not unique within the data array",
  E1041: "The '{0}' script is referenced after the DevExtreme scripts or not referenced at all",
  E1042: "{0} requires the key field to be specified",
  E1043: "Changes cannot be processed due to the incorrectly set key",
  E1044: "The key field specified by the keyExpr option does not match the key field specified in the data store",
  E1045: "Editing requires the key field to be specified in the data store",
  E1046: "The '{0}' key field is not found in data objects",
  E1047: 'The "{0}" field is not found in the fields array',
  E1048: 'The "{0}" operation is not found in the filterOperations array',
  E1049: "Column '{0}': filtering is allowed but the 'dataField' or 'name' option is not specified",
  E1050: "The validationRules option does not apply to third-party editors defined in the editCellTemplate",
  E1052: '{0} should have the "dataSource" option specified',
  E1053: 'The "buttons" option accepts an array that contains only objects or string values',
  E1054: "All text editor buttons must have names",
  E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
  E1056: 'The {0} widget does not support buttons of the "{1}" type',
  E1058: 'The "startDayHour" and "endDayHour" options must be integers in the [0, 24] range, with "endDayHour" being greater than "startDayHour".',
  E1059: "The following column names are not unique: {0}",
  E1060: "All editable columns must have names",
  E1061: 'The "offset" option must be an integer in the [-1440, 1440] range, divisible by 5 without a remainder.',
  E1062: 'The "cellDuration" must be a positive integer, evenly dividing the ("endDayHour" - "startDayHour") interval into minutes.',
  W1001: 'The "key" option cannot be modified after initialization',
  W1002: "An item with the key '{0}' does not exist",
  W1003: "A group with the key '{0}' in which you are trying to select items does not exist",
  W1004: "The item '{0}' you are trying to select in the group '{1}' does not exist",
  W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.",
  W1006: "The map service returned the following error: '{0}'",
  W1007: "No item with key {0} was found in the data source, but this key was used as the parent key for item {1}",
  W1008: "Cannot scroll to the '{0}' date because it does not exist on the current view",
  W1009: "Searching works only if data is specified using the dataSource option",
  W1010: "The capability to select all items works with source data of plain structure only",
  W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
  W1012: "The '{0}' key field is not found in data objects",
  W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
  W1014: "The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.",
  W1017: "The 'key' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.",
  W1018: "Infinite scrolling may not work properly with multiple selection. To use these features together, set 'selection.deferred' to true or set 'selection.selectAllMode' to 'page'.",
  W1019: "Filter query string exceeds maximum length limit of {0} characters.",
  W1020: "hideEvent is ignored when the shading property is true",
  W1021: `The '{0}' is not rendered because none of the DOM elements match the value of the "container" property.`,
  W1022: "{0} JSON parsing error: '{1}'",
  W1023: "Appointments require unique keys. Otherwise, the agenda view may not work correctly.",
  W1024: "The client-side export is enabled. Implement the 'onExporting' function.",
  W1025: "'scrolling.mode' is set to 'virtual' or 'infinite'. Specify the height of the component.",
  W1026: "The 'ai' toolbar item is defined, but aiIntegration is missing.",
  W1027: "A prompt should be specified for a custom command."
});

// node_modules/devextreme/esm/ui/themes.js
var window9 = getWindow();
var ready2 = ready_callbacks_default.add;
var viewPort = value;
var viewPortChanged = changeCallback;
var initDeferred = new Deferred();
var DX_LINK_SELECTOR = "link[rel=dx-theme]";
var THEME_ATTR = "data-theme";
var ACTIVE_ATTR = "data-active";
var context;
var $activeThemeLink;
var knownThemes;
var currentThemeName;
var pendingThemeName;
var defaultTimeout = 15e3;
function readThemeMarker() {
  if (!hasWindow()) {
    return null;
  }
  const element = renderer_default("<div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
  let result2;
  try {
    result2 = window9.getComputedStyle(element.get(0)).fontFamily;
    if (!result2) {
      return null;
    }
    result2 = result2.replace(/["']/g, "");
    if ("dx." !== result2.substr(0, 3)) {
      return null;
    }
    return result2.substr(3);
  } finally {
    element.remove();
  }
}
function waitForThemeLoad(themeName) {
  let waitStartTime;
  let timerId;
  let intervalCleared = true;
  pendingThemeName = themeName;
  function handleLoaded() {
    pendingThemeName = null;
    clearInterval(timerId);
    intervalCleared = true;
    themeReadyCallback.fire();
    themeReadyCallback.empty();
    initDeferred.resolve();
  }
  if (isPendingThemeLoaded() || !defaultTimeout) {
    handleLoaded();
  } else {
    if (!intervalCleared) {
      if (pendingThemeName) {
        pendingThemeName = themeName;
      }
      return;
    }
    waitStartTime = Date.now();
    intervalCleared = false;
    timerId = setInterval(function() {
      const isLoaded = isPendingThemeLoaded();
      const isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;
      if (isTimeout) {
        ui_errors_default.log("W0004", pendingThemeName);
      }
      if (isLoaded || isTimeout) {
        handleLoaded();
      }
    }, 10);
  }
}
function isPendingThemeLoaded() {
  if (!pendingThemeName) {
    return true;
  }
  const anyThemePending = "any" === pendingThemeName;
  if ("resolved" === initDeferred.state() && anyThemePending) {
    return true;
  }
  const themeMarker = readThemeMarker();
  if (themeMarker && anyThemePending) {
    return true;
  }
  return themeMarker === pendingThemeName;
}
function processMarkup() {
  const $allThemeLinks = renderer_default(DX_LINK_SELECTOR, context);
  if (!$allThemeLinks.length) {
    return;
  }
  knownThemes = {};
  $activeThemeLink = renderer_default(parseHTML("<link rel=stylesheet>"), context);
  $allThemeLinks.each(function() {
    const link = renderer_default(this, context);
    const fullThemeName = link.attr(THEME_ATTR);
    const url = link.attr("href");
    const isActive = "true" === link.attr(ACTIVE_ATTR);
    knownThemes[fullThemeName] = {
      url,
      isActive
    };
  });
  $allThemeLinks.last().after($activeThemeLink);
  $allThemeLinks.remove();
}
function resolveFullThemeName(desiredThemeName) {
  const desiredThemeParts = desiredThemeName ? desiredThemeName.split(".") : [];
  let result2 = null;
  if (knownThemes) {
    if (desiredThemeName in knownThemes) {
      return desiredThemeName;
    }
    each(knownThemes, function(knownThemeName, themeData) {
      const knownThemeParts = knownThemeName.split(".");
      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
        return;
      }
      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
        return;
      }
      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
        return;
      }
      if (!result2 || themeData.isActive) {
        result2 = knownThemeName;
      }
      if (themeData.isActive) {
        return false;
      }
    });
  }
  return result2;
}
function initContext(newContext) {
  try {
    if (newContext !== context) {
      knownThemes = null;
    }
  } catch (x) {
    knownThemes = null;
  }
  context = newContext;
}
function init(options2) {
  options2 = options2 || {};
  initContext(options2.context || dom_adapter_default.getDocument());
  if (!context) {
    return;
  }
  processMarkup();
  currentThemeName = void 0;
  current(options2);
}
function current(options2) {
  if (!arguments.length) {
    currentThemeName = currentThemeName || readThemeMarker();
    return currentThemeName;
  }
  detachCssClasses(viewPort());
  options2 = options2 || {};
  if ("string" === typeof options2) {
    options2 = {
      theme: options2
    };
  }
  const isAutoInit = options2._autoInit;
  const loadCallback = options2.loadCallback;
  let currentThemeData;
  currentThemeName = resolveFullThemeName(options2.theme || currentThemeName);
  if (currentThemeName) {
    currentThemeData = knownThemes[currentThemeName];
  }
  if (loadCallback) {
    themeReadyCallback.add(loadCallback);
  }
  if (currentThemeData) {
    $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
    if (themeReadyCallback.has() || "resolved" !== initDeferred.state() || options2._forceTimeout) {
      waitForThemeLoad(currentThemeName);
    }
  } else if (isAutoInit) {
    if (hasWindow()) {
      waitForThemeLoad("any");
    }
    themeReadyCallback.fire();
    themeReadyCallback.empty();
  } else {
    throw ui_errors_default.Error("E0021", currentThemeName);
  }
  initDeferred.done(() => attachCssClasses(originalViewPort(), currentThemeName));
}
function getCssClasses(themeName) {
  themeName = themeName || current();
  const result2 = [];
  const themeNameParts = themeName && themeName.split(".");
  if (themeNameParts) {
    result2.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
    if (themeNameParts.length > 1) {
      result2.push("dx-color-scheme-" + themeNameParts[1] + (isMaterialBased(themeName) ? "-" + themeNameParts[2] : ""));
    }
  }
  return result2;
}
var themeClasses;
function _attachCssClasses(element, themeName) {
  themeClasses = getCssClasses(themeName).join(" ");
  renderer_default(element).addClass(themeClasses);
  !function() {
    const pixelRatio = hasWindow() && window9.devicePixelRatio;
    if (!pixelRatio || pixelRatio < 2) {
      return;
    }
    const $tester = renderer_default("<div>");
    $tester.css("border", ".5px solid transparent");
    renderer_default("body").append($tester);
    if (1 === getOuterHeight($tester)) {
      renderer_default(element).addClass("dx-hairlines");
      themeClasses += " dx-hairlines";
    }
    $tester.remove();
  }();
}
function attachCssClasses(element, themeName) {
  when(uiLayerInitialized).done(() => {
    _attachCssClasses(element, themeName);
  });
}
function detachCssClasses(element) {
  when(uiLayerInitialized).done(() => {
    renderer_default(element).removeClass(themeClasses);
  });
}
function isTheme(themeRegExp, themeName) {
  if (!themeName) {
    themeName = currentThemeName || readThemeMarker();
  }
  return new RegExp(themeRegExp).test(themeName);
}
function isMaterialBased(themeName) {
  return isMaterial(themeName) || isFluent(themeName);
}
function isMaterial(themeName) {
  return isTheme("material", themeName);
}
function isFluent(themeName) {
  return isTheme("fluent", themeName);
}
function isWebFontLoaded(text, fontWeight) {
  const document2 = dom_adapter_default.getDocument();
  const testElement = document2.createElement("span");
  testElement.style.position = "absolute";
  testElement.style.top = "-9999px";
  testElement.style.left = "-9999px";
  testElement.style.visibility = "hidden";
  testElement.style.fontFamily = "Arial";
  testElement.style.fontSize = "250px";
  testElement.style.fontWeight = fontWeight;
  testElement.innerHTML = text;
  document2.body.appendChild(testElement);
  const etalonFontWidth = testElement.offsetWidth;
  testElement.style.fontFamily = "Roboto, RobotoFallback, Arial";
  const testedFontWidth = testElement.offsetWidth;
  testElement.parentNode.removeChild(testElement);
  return etalonFontWidth !== testedFontWidth;
}
function waitWebFont(text, fontWeight) {
  return new Promise((resolve) => {
    const clear = () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      resolve();
    };
    const intervalId = setInterval(() => {
      if (isWebFontLoaded(text, fontWeight)) {
        clear();
      }
    }, 15);
    const timeoutId = setTimeout(clear, 2e3);
  });
}
function autoInit() {
  init({
    _autoInit: true,
    _forceTimeout: true
  });
  if (renderer_default(DX_LINK_SELECTOR, context).length) {
    throw ui_errors_default.Error("E0022");
  }
}
if (hasWindow()) {
  autoInit();
} else {
  ready2(autoInit);
}
viewPortChanged.add(function(viewPort2, prevViewPort) {
  initDeferred.done(function() {
    detachCssClasses(prevViewPort);
    attachCssClasses(viewPort2);
  });
});
devices_default.changed.add(function() {
  init({
    _autoInit: true
  });
});

// node_modules/devextreme/esm/common/core/animation/frame.js
var window10 = hasWindow() ? getWindow() : {};
var FRAME_ANIMATION_STEP_TIME = 1e3 / 60;
var request = function(callback) {
  return setTimeout(callback, 16.666666666666668);
};
var cancel = function(requestID) {
  clearTimeout(requestID);
};
var setAnimationFrameMethods = call_once_default(function() {
  const nativeRequest = window10.requestAnimationFrame || window10.webkitRequestAnimationFrame || window10.mozRequestAnimationFrame || window10.oRequestAnimationFrame || window10.msRequestAnimationFrame;
  const nativeCancel = window10.cancelAnimationFrame || window10.webkitCancelAnimationFrame || window10.mozCancelAnimationFrame || window10.oCancelAnimationFrame || window10.msCancelAnimationFrame;
  if (nativeRequest && nativeCancel) {
    request = nativeRequest;
    cancel = nativeCancel;
  }
});
function requestAnimationFrame() {
  setAnimationFrameMethods();
  return request.apply(window10, arguments);
}
function cancelAnimationFrame() {
  setAnimationFrameMethods();
  cancel.apply(window10, arguments);
}

// node_modules/devextreme/esm/common/core/animation/easing.js
var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
var TransitionTimingFuncMap = {
  linear: "cubic-bezier(0, 0, 1, 1)",
  swing: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
  "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
  "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
};
var polynomBezier = function(x1, y1, x2, y2) {
  const Cx = 3 * x1;
  const Bx = 3 * (x2 - x1) - Cx;
  const Ax = 1 - Cx - Bx;
  const Cy = 3 * y1;
  const By = 3 * (y2 - y1) - Cy;
  const Ay = 1 - Cy - By;
  const bezierX = function(t) {
    return t * (Cx + t * (Bx + t * Ax));
  };
  const derivativeX = function(t) {
    return Cx + t * (2 * Bx + 3 * t * Ax);
  };
  return function(t) {
    return function(t2) {
      return t2 * (Cy + t2 * (By + t2 * Ay));
    }(function(t2) {
      let x = t2;
      let i = 0;
      let z;
      while (i < 14) {
        z = bezierX(x) - t2;
        if (Math.abs(z) < 1e-3) {
          break;
        }
        x -= z / derivativeX(x);
        i++;
      }
      return x;
    }(t));
  };
};
var easing = {};
var convertTransitionTimingFuncToEasing = function(cssTransitionEasing) {
  cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
  let coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
  let forceName;
  if (!coeffs) {
    forceName = "linear";
    coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX);
  }
  coeffs = coeffs.slice(1, 5);
  for (let i = 0; i < coeffs.length; i++) {
    coeffs[i] = parseFloat(coeffs[i]);
  }
  const easingName = forceName || "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
  if (!isFunction(easing[easingName])) {
    easing[easingName] = function(x, t, b, c, d) {
      return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b;
    };
  }
  return easingName;
};
function getEasing(name2) {
  return easing[name2];
}

// node_modules/devextreme/esm/common/core/animation/fx.js
var window11 = getWindow();
var removeEventName = addNamespace2(removeEvent, "dxFX");
var RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
var TransitionAnimationStrategy = {
  initAnimation: function($element, config3) {
    $element.css({
      transitionProperty: "none"
    });
    if ("string" === typeof config3.from) {
      $element.addClass(config3.from);
    } else {
      setProps($element, config3.from);
    }
    const that = this;
    const deferred = new Deferred();
    const cleanupWhen = config3.cleanupWhen;
    config3.transitionAnimation = {
      deferred,
      finish: function() {
        that._finishTransition($element);
        if (cleanupWhen) {
          when(deferred, cleanupWhen).always(function() {
            that._cleanup($element, config3);
          });
        } else {
          that._cleanup($element, config3);
        }
        deferred.resolveWith($element, [config3, $element]);
      }
    };
    this._completeAnimationCallback($element, config3).done(function() {
      config3.transitionAnimation.finish();
    }).fail(function() {
      deferred.rejectWith($element, [config3, $element]);
    });
    if (!config3.duration) {
      config3.transitionAnimation.finish();
    }
    $element.css("transform");
  },
  animate: function($element, config3) {
    this._startAnimation($element, config3);
    return config3.transitionAnimation.deferred.promise();
  },
  _completeAnimationCallback: function($element, config3) {
    const that = this;
    const startTime = Date.now() + config3.delay;
    const deferred = new Deferred();
    const transitionEndFired = new Deferred();
    const simulatedTransitionEndFired = new Deferred();
    let simulatedEndEventTimer;
    const transitionEndEventFullName = m_support_default.transitionEndEventName() + ".dxFX";
    config3.transitionAnimation.cleanup = function() {
      clearTimeout(simulatedEndEventTimer);
      clearTimeout(waitForJSCompleteTimer);
      m_events_engine_default.off($element, transitionEndEventFullName);
      m_events_engine_default.off($element, removeEventName);
    };
    m_events_engine_default.one($element, transitionEndEventFullName, function() {
      if (Date.now() - startTime >= config3.duration) {
        transitionEndFired.reject();
      }
    });
    m_events_engine_default.off($element, removeEventName);
    m_events_engine_default.on($element, removeEventName, function() {
      that.stop($element, config3);
      deferred.reject();
    });
    const waitForJSCompleteTimer = setTimeout(function() {
      simulatedEndEventTimer = setTimeout(function() {
        simulatedTransitionEndFired.reject();
      }, config3.duration + config3.delay + fx._simulatedTransitionEndDelay);
      when(transitionEndFired, simulatedTransitionEndFired).fail((function() {
        deferred.resolve();
      }).bind(this));
    });
    return deferred.promise();
  },
  _startAnimation: function($element, config3) {
    $element.css({
      transitionProperty: "all",
      transitionDelay: config3.delay + "ms",
      transitionDuration: config3.duration + "ms",
      transitionTimingFunction: config3.easing
    });
    if ("string" === typeof config3.to) {
      $element[0].className += " " + config3.to;
    } else if (config3.to) {
      setProps($element, config3.to);
    }
  },
  _finishTransition: function($element) {
    $element.css("transition", "none");
  },
  _cleanup: function($element, config3) {
    config3.transitionAnimation.cleanup();
    if ("string" === typeof config3.from) {
      $element.removeClass(config3.from);
      $element.removeClass(config3.to);
    }
  },
  stop: function($element, config3, jumpToEnd) {
    if (!config3) {
      return;
    }
    if (jumpToEnd) {
      config3.transitionAnimation.finish();
    } else {
      if (isPlainObject(config3.to)) {
        each(config3.to, function(key) {
          $element.css(key, $element.css(key));
        });
      }
      this._finishTransition($element);
      this._cleanup($element, config3);
    }
  }
};
var FrameAnimationStrategy = {
  initAnimation: function($element, config3) {
    setProps($element, config3.from);
  },
  animate: function($element, config3) {
    const deferred = new Deferred();
    const that = this;
    if (!config3) {
      return deferred.reject().promise();
    }
    each(config3.to, function(prop) {
      if (void 0 === config3.from[prop]) {
        config3.from[prop] = that._normalizeValue($element.css(prop));
      }
    });
    if (config3.to.transform) {
      config3.from.transform = that._parseTransform(config3.from.transform);
      config3.to.transform = that._parseTransform(config3.to.transform);
    }
    config3.frameAnimation = {
      to: config3.to,
      from: config3.from,
      currentValue: config3.from,
      easing: convertTransitionTimingFuncToEasing(config3.easing),
      duration: config3.duration,
      startTime: (/* @__PURE__ */ new Date()).valueOf(),
      finish: function() {
        this.currentValue = this.to;
        this.draw();
        cancelAnimationFrame(config3.frameAnimation.animationFrameId);
        deferred.resolve();
      },
      draw: function() {
        if (config3.draw) {
          config3.draw(this.currentValue);
          return;
        }
        const currentValue = extend({}, this.currentValue);
        if (currentValue.transform) {
          currentValue.transform = map(currentValue.transform, function(value2, prop) {
            if ("translate" === prop) {
              return getTranslateCss(value2);
            } else if ("scale" === prop) {
              return "scale(" + value2 + ")";
            } else if ("rotate" === prop.substr(0, prop.length - 1)) {
              return prop + "(" + value2 + "deg)";
            }
          }).join(" ");
        }
        $element.css(currentValue);
      }
    };
    if (config3.delay) {
      config3.frameAnimation.startTime += config3.delay;
      config3.frameAnimation.delayTimeout = setTimeout(function() {
        that._startAnimation($element, config3);
      }, config3.delay);
    } else {
      that._startAnimation($element, config3);
    }
    return deferred.promise();
  },
  _startAnimation: function($element, config3) {
    m_events_engine_default.off($element, removeEventName);
    m_events_engine_default.on($element, removeEventName, function() {
      if (config3.frameAnimation) {
        cancelAnimationFrame(config3.frameAnimation.animationFrameId);
      }
    });
    this._animationStep($element, config3);
  },
  _parseTransform: function(transformString) {
    const result2 = {};
    each(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function(i, part) {
      const translateData = parseTranslate(part);
      const scaleData = part.match(/scale\((.+?)\)/);
      const rotateData = part.match(/(rotate.)\((.+)deg\)/);
      if (translateData) {
        result2.translate = translateData;
      }
      if (scaleData && scaleData[1]) {
        result2.scale = parseFloat(scaleData[1]);
      }
      if (rotateData && rotateData[1]) {
        result2[rotateData[1]] = parseFloat(rotateData[2]);
      }
    });
    return result2;
  },
  stop: function($element, config3, jumpToEnd) {
    const frameAnimation = config3 && config3.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    cancelAnimationFrame(frameAnimation.animationFrameId);
    clearTimeout(frameAnimation.delayTimeout);
    if (jumpToEnd) {
      frameAnimation.finish();
    }
    delete config3.frameAnimation;
  },
  _animationStep: function($element, config3) {
    const frameAnimation = config3 && config3.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    const now = (/* @__PURE__ */ new Date()).valueOf();
    if (now >= frameAnimation.startTime + frameAnimation.duration) {
      frameAnimation.finish();
      return;
    }
    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
    frameAnimation.draw();
    const that = this;
    frameAnimation.animationFrameId = requestAnimationFrame(function() {
      that._animationStep($element, config3);
    });
  },
  _calcStepValue: function(frameAnimation, currentDuration) {
    const calcValueRecursively = function(from, to) {
      const result2 = Array.isArray(to) ? [] : {};
      each(to, function(propName, endPropValue) {
        if ("string" === typeof endPropValue && false === parseFloat(endPropValue)) {
          return true;
        }
        result2[propName] = "object" === typeof endPropValue ? calcValueRecursively(from[propName], endPropValue) : function(propName2) {
          const x = currentDuration / frameAnimation.duration;
          const t = currentDuration;
          const b = 1 * from[propName2];
          const c = to[propName2] - from[propName2];
          const d = frameAnimation.duration;
          return getEasing(frameAnimation.easing)(x, t, b, c, d);
        }(propName);
      });
      return result2;
    };
    return calcValueRecursively(frameAnimation.from, frameAnimation.to);
  },
  _normalizeValue: function(value2) {
    const numericValue = parseFloat(value2);
    if (false === numericValue) {
      return value2;
    }
    return numericValue;
  }
};
var FallbackToNoAnimationStrategy = {
  initAnimation: function() {
  },
  animate: function() {
    return new Deferred().resolve().promise();
  },
  stop: noop2,
  isSynchronous: true
};
var getAnimationStrategy = function(config3) {
  config3 = config3 || {};
  const animationStrategies = {
    transition: m_support_default.transition() ? TransitionAnimationStrategy : FrameAnimationStrategy,
    frame: FrameAnimationStrategy,
    noAnimation: FallbackToNoAnimationStrategy
  };
  let strategy3 = config3.strategy || "transition";
  if ("css" === config3.type && !m_support_default.transition()) {
    strategy3 = "noAnimation";
  }
  return animationStrategies[strategy3];
};
var baseConfigValidator = function(config3, animationType, validate, typeMessage) {
  each(["from", "to"], function() {
    if (!validate(config3[this])) {
      throw errors_default.Error("E0010", animationType, this, typeMessage);
    }
  });
};
var isObjectConfigValidator = function(config3, animationType) {
  return baseConfigValidator(config3, animationType, function(target) {
    return isPlainObject(target);
  }, "a plain object");
};
var isStringConfigValidator = function(config3, animationType) {
  return baseConfigValidator(config3, animationType, function(target) {
    return "string" === typeof target;
  }, "a string");
};
var CustomAnimationConfigurator = {
  setup: function() {
  }
};
var CssAnimationConfigurator = {
  validateConfig: function(config3) {
    isStringConfigValidator(config3, "css");
  },
  setup: function() {
  }
};
var positionAliases = {
  top: {
    my: "bottom center",
    at: "top center"
  },
  bottom: {
    my: "top center",
    at: "bottom center"
  },
  right: {
    my: "left center",
    at: "right center"
  },
  left: {
    my: "right center",
    at: "left center"
  }
};
var SlideAnimationConfigurator = {
  validateConfig: function(config3) {
    isObjectConfigValidator(config3, "slide");
  },
  setup: function($element, config3) {
    const location = locate($element);
    if ("slide" !== config3.type) {
      const positioningConfig = "slideIn" === config3.type ? config3.from : config3.to;
      positioningConfig.position = extend({
        of: window11
      }, positionAliases[config3.direction]);
      setupPosition($element, positioningConfig);
    }
    this._setUpConfig(location, config3.from);
    this._setUpConfig(location, config3.to);
    clearCache($element);
  },
  _setUpConfig: function(location, config3) {
    config3.left = "left" in config3 ? config3.left : "+=0";
    config3.top = "top" in config3 ? config3.top : "+=0";
    this._initNewPosition(location, config3);
  },
  _initNewPosition: function(location, config3) {
    const position2 = {
      left: config3.left,
      top: config3.top
    };
    delete config3.left;
    delete config3.top;
    let relativeValue = this._getRelativeValue(position2.left);
    if (void 0 !== relativeValue) {
      position2.left = relativeValue + location.left;
    } else {
      config3.left = 0;
    }
    relativeValue = this._getRelativeValue(position2.top);
    if (void 0 !== relativeValue) {
      position2.top = relativeValue + location.top;
    } else {
      config3.top = 0;
    }
    config3.transform = getTranslateCss({
      x: position2.left,
      y: position2.top
    });
  },
  _getRelativeValue: function(value2) {
    let relativeValue;
    if ("string" === typeof value2 && (relativeValue = RELATIVE_VALUE_REGEX.exec(value2))) {
      return parseInt(relativeValue[1] + "1") * relativeValue[2];
    }
  }
};
var FadeAnimationConfigurator = {
  setup: function($element, config3) {
    const from = config3.from;
    const to = config3.to;
    const defaultFromOpacity = "fadeOut" === config3.type ? 1 : 0;
    const defaultToOpacity = "fadeOut" === config3.type ? 0 : 1;
    let fromOpacity = isPlainObject(from) ? String(from.opacity ?? defaultFromOpacity) : String(from);
    let toOpacity = isPlainObject(to) ? String(to.opacity ?? defaultToOpacity) : String(to);
    if (!config3.skipElementInitialStyles) {
      fromOpacity = $element.css("opacity");
    }
    switch (config3.type) {
      case "fadeIn":
        toOpacity = 1;
        break;
      case "fadeOut":
        toOpacity = 0;
    }
    config3.from = {
      visibility: "visible",
      opacity: fromOpacity
    };
    config3.to = {
      opacity: toOpacity
    };
  }
};
var PopAnimationConfigurator = {
  validateConfig: function(config3) {
    isObjectConfigValidator(config3, "pop");
  },
  setup: function($element, config3) {
    const from = config3.from;
    const to = config3.to;
    const fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity");
    const toOpacity = "opacity" in to ? to.opacity : 1;
    const fromScale = "scale" in from ? from.scale : 0;
    const toScale = "scale" in to ? to.scale : 1;
    config3.from = {
      opacity: fromOpacity
    };
    const translate = getTranslate($element);
    config3.from.transform = this._getCssTransform(translate, fromScale);
    config3.to = {
      opacity: toOpacity
    };
    config3.to.transform = this._getCssTransform(translate, toScale);
  },
  _getCssTransform: function(translate, scale) {
    return getTranslateCss(translate) + "scale(" + scale + ")";
  }
};
var animationConfigurators = {
  custom: CustomAnimationConfigurator,
  slide: SlideAnimationConfigurator,
  slideIn: SlideAnimationConfigurator,
  slideOut: SlideAnimationConfigurator,
  fade: FadeAnimationConfigurator,
  fadeIn: FadeAnimationConfigurator,
  fadeOut: FadeAnimationConfigurator,
  pop: PopAnimationConfigurator,
  css: CssAnimationConfigurator
};
var getAnimationConfigurator = function(config3) {
  const result2 = animationConfigurators[config3.type];
  if (!result2) {
    throw errors_default.Error("E0011", config3.type);
  }
  return result2;
};
var defaultJSConfig = {
  type: "custom",
  from: {},
  to: {},
  duration: 400,
  start: noop2,
  complete: noop2,
  easing: "ease",
  delay: 0
};
var defaultCssConfig = {
  duration: 400,
  easing: "ease",
  delay: 0
};
function setupAnimationOnElement() {
  const $element = this.element;
  const config3 = this.config;
  setupPosition($element, config3.from);
  setupPosition($element, config3.to);
  this.configurator.setup($element, config3);
  $element.data("dxAnimData", this);
  if (fx.off) {
    config3.duration = 0;
    config3.delay = 0;
  }
  this.strategy.initAnimation($element, config3);
  if (config3.start) {
    const element = getPublicElement($element);
    config3.start.apply(this, [element, config3]);
  }
}
var onElementAnimationComplete = function(animation2) {
  const $element = animation2.element;
  const config3 = animation2.config;
  $element.removeData("dxAnimData");
  if (config3.complete) {
    const element = getPublicElement($element);
    config3.complete.apply(this, [element, config3]);
  }
  animation2.deferred.resolveWith(this, [$element, config3]);
};
var startAnimationOnElement = function() {
  const animation2 = this;
  const $element = animation2.element;
  const config3 = animation2.config;
  animation2.isStarted = true;
  return animation2.strategy.animate($element, config3).done(function() {
    onElementAnimationComplete(animation2);
  }).fail(function() {
    animation2.deferred.rejectWith(this, [$element, config3]);
  });
};
var stopAnimationOnElement = function(jumpToEnd) {
  const animation2 = this;
  const $element = animation2.element;
  const config3 = animation2.config;
  clearTimeout(animation2.startTimeout);
  if (!animation2.isStarted) {
    animation2.start();
  }
  animation2.strategy.stop($element, config3, jumpToEnd);
};
var scopedRemoveEvent = addNamespace2(removeEvent, "dxFXStartAnimation");
var subscribeToRemoveEvent = function(animation2) {
  m_events_engine_default.off(animation2.element, scopedRemoveEvent);
  m_events_engine_default.on(animation2.element, scopedRemoveEvent, function() {
    fx.stop(animation2.element);
  });
  animation2.deferred.always(function() {
    m_events_engine_default.off(animation2.element, scopedRemoveEvent);
  });
};
var createAnimation = function(element, initialConfig) {
  const defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig;
  const config3 = extend(true, {}, defaultConfig, initialConfig);
  const configurator = getAnimationConfigurator(config3);
  const strategy3 = getAnimationStrategy(config3);
  const animation2 = {
    element: renderer_default(element),
    config: config3,
    configurator,
    strategy: strategy3,
    isSynchronous: strategy3.isSynchronous,
    setup: setupAnimationOnElement,
    start: startAnimationOnElement,
    stop: stopAnimationOnElement,
    deferred: new Deferred()
  };
  if (isFunction(configurator.validateConfig)) {
    configurator.validateConfig(config3);
  }
  subscribeToRemoveEvent(animation2);
  return animation2;
};
var animate = function(element, config3) {
  const $element = renderer_default(element);
  if (!$element.length) {
    return new Deferred().resolve().promise();
  }
  const animation2 = createAnimation($element, config3);
  pushInAnimationQueue($element, animation2);
  return animation2.deferred.promise();
};
function pushInAnimationQueue($element, animation2) {
  const queueData = getAnimQueueData($element);
  writeAnimQueueData($element, queueData);
  queueData.push(animation2);
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
}
function getAnimQueueData($element) {
  return $element.data("dxAnimQueue") || [];
}
function writeAnimQueueData($element, queueData) {
  $element.data("dxAnimQueue", queueData);
}
var destroyAnimQueueData = function($element) {
  $element.removeData("dxAnimQueue");
};
function isAnimating($element) {
  return !!$element.data("dxAnimData");
}
function shiftFromAnimationQueue($element, queueData) {
  queueData = getAnimQueueData($element);
  if (!queueData.length) {
    return;
  }
  const animation2 = queueData.shift();
  if (0 === queueData.length) {
    destroyAnimQueueData($element);
  }
  executeAnimation(animation2).done(function() {
    if (!isAnimating($element)) {
      shiftFromAnimationQueue($element);
    }
  });
}
function executeAnimation(animation2) {
  animation2.setup();
  if (fx.off || animation2.isSynchronous) {
    animation2.start();
  } else {
    animation2.startTimeout = setTimeout(function() {
      animation2.start();
    });
  }
  return animation2.deferred.promise();
}
function setupPosition($element, config3) {
  if (!config3 || !config3.position) {
    return;
  }
  const win = renderer_default(window11);
  let left = 0;
  let top = 0;
  const position2 = position_default.calculate($element, config3.position);
  const offset2 = $element.offset();
  const currentPosition = $element.position();
  if (currentPosition.top > offset2.top) {
    top = win.scrollTop();
  }
  if (currentPosition.left > offset2.left) {
    left = win.scrollLeft();
  }
  extend(config3, {
    left: position2.h.location - offset2.left + currentPosition.left - left,
    top: position2.v.location - offset2.top + currentPosition.top - top
  });
  delete config3.position;
}
function setProps($element, props) {
  each(props, function(key, value2) {
    try {
      $element.css(key, isFunction(value2) ? value2() : value2);
    } catch (e) {
    }
  });
}
var stop = function(element, jumpToEnd) {
  const $element = renderer_default(element);
  const queueData = getAnimQueueData($element);
  each(queueData, function(_, animation3) {
    animation3.config.delay = 0;
    animation3.config.duration = 0;
    animation3.isSynchronous = true;
  });
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
  const animation2 = $element.data("dxAnimData");
  if (animation2) {
    animation2.stop(jumpToEnd);
  }
  $element.removeData("dxAnimData");
  destroyAnimQueueData($element);
};
var fx = {
  off: false,
  animationTypes: animationConfigurators,
  animate,
  createAnimation,
  isAnimating,
  stop,
  _simulatedTransitionEndDelay: 100
};
var fx_default = fx;

// node_modules/devextreme/esm/__internal/core/m_action.js
var Action = class _Action {
  constructor(action, config3) {
    config3 = config3 || {};
    this._action = action;
    this._context = config3.context || getWindow();
    this._beforeExecute = config3.beforeExecute;
    this._afterExecute = config3.afterExecute;
    this._component = config3.component;
    this._validatingTargetName = config3.validatingTargetName;
    const excludeValidators = this._excludeValidators = {};
    if (config3.excludeValidators) {
      for (let i = 0; i < config3.excludeValidators.length; i++) {
        excludeValidators[config3.excludeValidators[i]] = true;
      }
    }
  }
  execute() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const e = {
      action: this._action,
      args: Array.prototype.slice.call(args),
      context: this._context,
      component: this._component,
      validatingTargetName: this._validatingTargetName,
      cancel: false,
      handled: false
    };
    const beforeExecute = this._beforeExecute;
    const afterExecute = this._afterExecute;
    const argsBag = e.args[0] || {};
    if (!this._validateAction(e)) {
      return;
    }
    null === beforeExecute || void 0 === beforeExecute || beforeExecute.call(this._context, e);
    if (e.cancel) {
      return;
    }
    const result2 = this._executeAction(e);
    if (argsBag.cancel) {
      return;
    }
    null === afterExecute || void 0 === afterExecute || afterExecute.call(this._context, e);
    return result2;
  }
  _validateAction(e) {
    const excludeValidators = this._excludeValidators;
    const {
      executors
    } = _Action;
    for (const name2 in executors) {
      if (!excludeValidators[name2]) {
        var _executor$validate;
        const executor = executors[name2];
        null === (_executor$validate = executor.validate) || void 0 === _executor$validate || _executor$validate.call(executor, e);
        if (e.cancel) {
          return false;
        }
      }
    }
    return true;
  }
  _executeAction(e) {
    let result2;
    const {
      executors
    } = _Action;
    for (const name2 in executors) {
      var _executor$execute;
      const executor = executors[name2];
      null === (_executor$execute = executor.execute) || void 0 === _executor$execute || _executor$execute.call(executor, e);
      if (e.handled) {
        result2 = e.result;
        break;
      }
    }
    return result2;
  }
  static registerExecutor(name2, executor) {
    if (isPlainObject(name2)) {
      each(name2, _Action.registerExecutor);
      return;
    }
    _Action.executors[name2] = executor;
  }
  static unregisterExecutor() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    each(args, function() {
      delete _Action.executors[this];
    });
  }
};
Action.executors = {};
var createValidatorByTargetElement = (condition) => (e) => {
  if (!e.args.length) {
    return;
  }
  const args = e.args[0];
  const element = args[e.validatingTargetName] || args.element;
  if (element && condition(renderer_default(element))) {
    e.cancel = true;
  }
};
Action.registerExecutor({
  disabled: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-disabled, .dx-state-disabled *"))
  },
  readOnly: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)"))
  },
  undefined: {
    execute: (e) => {
      if (!e.action) {
        e.result = void 0;
        e.handled = true;
      }
    }
  },
  func: {
    execute: (e) => {
      if (isFunction(e.action)) {
        e.result = e.action.call(e.context, e.args[0]);
        e.handled = true;
      }
    }
  }
});

// node_modules/devextreme/esm/core/action.js
var action_default = Action;

// node_modules/devextreme/esm/__internal/core/options/m_utils.js
var cachedGetters = {};
var convertRulesToOptions = (rules) => {
  const currentDevice = devices_default.current();
  return rules.reduce((options2, _ref) => {
    let {
      device,
      options: ruleOptions
    } = _ref;
    const deviceFilter = device || {};
    const match2 = isFunction(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);
    if (match2) {
      extend(true, options2, ruleOptions);
    }
    return options2;
  }, {});
};
var normalizeOptions = (options2, value2) => "string" !== typeof options2 ? options2 : {
  [options2]: value2
};
var deviceMatch = (device, filter) => isEmptyObject(filter) || findBestMatches(device, [filter]).length > 0;
var getFieldName = (fullName) => fullName.substr(fullName.lastIndexOf(".") + 1);
var getParentName = (fullName) => fullName.substr(0, fullName.lastIndexOf("."));
var getNestedOptionValue = function(optionsObject, name2) {
  cachedGetters[name2] = cachedGetters[name2] || compileGetter(name2);
  return cachedGetters[name2](optionsObject, {
    functionsAsIs: true
  });
};
var createDefaultOptionRules = function() {
  let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  return options2;
};

// node_modules/devextreme/esm/__internal/core/utils/m_comparator.js
var hasNegation = function(oldValue, newValue) {
  return 1 / oldValue === 1 / newValue;
};
var equals = function(oldValue, newValue) {
  oldValue = toComparable(oldValue, true);
  newValue = toComparable(newValue, true);
  if (oldValue && newValue && isRenderer(oldValue) && isRenderer(newValue)) {
    return newValue.is(oldValue);
  }
  const oldValueIsNaN = oldValue !== oldValue;
  const newValueIsNaN = newValue !== newValue;
  if (oldValueIsNaN && newValueIsNaN) {
    return true;
  }
  if (0 === oldValue && 0 === newValue) {
    return hasNegation(oldValue, newValue);
  }
  if (null === oldValue || "object" !== typeof oldValue || dom_adapter_default.isElementNode(oldValue)) {
    return oldValue === newValue;
  }
  return false;
};

// node_modules/devextreme/esm/__internal/core/options/m_option_manager.js
var cachedGetters2 = {};
var cachedSetters = {};
var OptionManager = class {
  constructor(options2, optionsByReference) {
    this._options = options2;
    this._optionsByReference = optionsByReference;
    this._changingCallback;
    this._changedCallback;
    this._namePreparedCallbacks;
    this._validateOptionsCallback;
  }
  _setByReference(options2, rulesOptions) {
    extend(true, options2, rulesOptions);
    for (const fieldName in this._optionsByReference) {
      if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
        options2[fieldName] = rulesOptions[fieldName];
      }
    }
  }
  _setPreparedValue(name2, value2, merge, silent) {
    const previousValue = this.get(this._options, name2, false);
    if (!equals(previousValue, value2)) {
      const path = getPathParts(name2);
      !silent && this._changingCallback(name2, previousValue, value2);
      cachedSetters[name2] = cachedSetters[name2] || compileSetter(name2);
      cachedSetters[name2](this._options, value2, {
        functionsAsIs: true,
        merge: isDefined(merge) ? merge : !this._optionsByReference[name2],
        unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
      });
      !silent && this._changedCallback(name2, value2, previousValue);
    }
  }
  _prepareRelevantNames(options2, name2, value2, silent) {
    if (isPlainObject(value2)) {
      for (const valueName in value2) {
        this._prepareRelevantNames(options2, `${name2}.${valueName}`, value2[valueName]);
      }
    }
    this._namePreparedCallbacks(options2, name2, value2, silent);
  }
  get() {
    let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._options;
    let name2 = arguments.length > 1 ? arguments[1] : void 0;
    let unwrapObservables = arguments.length > 2 ? arguments[2] : void 0;
    cachedGetters2[name2] = cachedGetters2[name2] || compileGetter(name2);
    return cachedGetters2[name2](options2, {
      functionsAsIs: true,
      unwrapObservables
    });
  }
  set(options2, value2, merge, silent) {
    options2 = normalizeOptions(options2, value2);
    for (const name2 in options2) {
      this._prepareRelevantNames(options2, name2, options2[name2], silent);
    }
    if (this._validateOptionsCallback) {
      options2 = this._validateOptionsCallback(options2);
    }
    for (const name2 in options2) {
      this._setPreparedValue(name2, options2[name2], merge, silent);
    }
  }
  onRelevantNamesPrepared(callBack) {
    this._namePreparedCallbacks = callBack;
  }
  onChanging(callBack) {
    this._changingCallback = callBack;
  }
  onChanged(callBack) {
    this._changedCallback = callBack;
  }
  onValidateOptions(callback) {
    this._validateOptionsCallback = callback;
  }
  dispose() {
    this._changingCallback = noop2;
    this._changedCallback = noop2;
  }
};

// node_modules/devextreme/esm/__internal/core/options/m_index.js
var Options = class {
  constructor(options2, defaultOptions2, optionsByReference, deprecatedOptions) {
    this._deprecatedCallback;
    this._startChangeCallback;
    this._endChangeCallback;
    this._validateOptionsCallback;
    this._default = defaultOptions2;
    this._deprecated = deprecatedOptions;
    this._deprecatedNames = [];
    this._initDeprecatedNames();
    this._optionManager = new OptionManager(options2, optionsByReference);
    this._optionManager.onRelevantNamesPrepared((options3, name2, value2, silent) => this._setRelevantNames(options3, name2, value2, silent));
    this._cachedOptions = {};
    this._rules = [];
  }
  set _initial(value2) {
    this._initialOptions = value2;
  }
  get _initial() {
    if (!this._initialOptions) {
      const rulesOptions = this._getByRules(this.silent("defaultOptionsRules"));
      this._initialOptions = this._default;
      this._optionManager._setByReference(this._initialOptions, rulesOptions);
    }
    return this._initialOptions;
  }
  _initDeprecatedNames() {
    for (const optionName in this._deprecated) {
      this._deprecatedNames.push(optionName);
    }
  }
  _getByRules(rules) {
    rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
    return convertRulesToOptions(rules);
  }
  _notifyDeprecated(option) {
    const info = this._deprecated[option];
    if (info) {
      this._deprecatedCallback(option, info);
    }
  }
  _setRelevantNames(options2, name2, value2, silent) {
    if (name2) {
      const normalizedName = this._normalizeName(name2, silent);
      if (normalizedName && normalizedName !== name2) {
        this._setField(options2, normalizedName, value2);
        this._clearField(options2, name2);
      }
    }
  }
  _setField(options2, fullName, value2) {
    let fieldName = "";
    let fieldObject = null;
    do {
      fieldName = fieldName ? `.${fieldName}` : "";
      fieldName = getFieldName(fullName) + fieldName;
      fullName = getParentName(fullName);
      fieldObject = fullName ? this._optionManager.get(options2, fullName, false) : options2;
    } while (!fieldObject);
    fieldObject[fieldName] = value2;
  }
  _clearField(options2, name2) {
    delete options2[name2];
    const previousFieldName = getParentName(name2);
    const fieldObject = previousFieldName ? this._optionManager.get(options2, previousFieldName, false) : options2;
    if (fieldObject) {
      delete fieldObject[getFieldName(name2)];
    }
  }
  _normalizeName(name2, silent) {
    if (this._deprecatedNames.length && name2) {
      for (let i = 0; i < this._deprecatedNames.length; i++) {
        if (this._deprecatedNames[i] === name2) {
          const deprecate = this._deprecated[name2];
          if (deprecate) {
            !silent && this._notifyDeprecated(name2);
            return deprecate.alias || name2;
          }
        }
      }
    }
    return name2;
  }
  addRules(rules) {
    this._rules = rules.concat(this._rules);
  }
  applyRules(rules) {
    const options2 = this._getByRules(rules);
    this.silent(options2);
  }
  dispose() {
    this._deprecatedCallback = noop2;
    this._startChangeCallback = noop2;
    this._endChangeCallback = noop2;
    this._optionManager.dispose();
  }
  onChanging(callBack) {
    this._optionManager.onChanging(callBack);
  }
  onChanged(callBack) {
    this._optionManager.onChanged(callBack);
  }
  validateOptions(callBack) {
    this._optionManager.onValidateOptions(callBack);
  }
  onDeprecated(callBack) {
    this._deprecatedCallback = callBack;
  }
  onStartChange(callBack) {
    this._startChangeCallback = callBack;
  }
  onEndChange(callBack) {
    this._endChangeCallback = callBack;
  }
  isInitial(name2) {
    const value2 = this.silent(name2);
    const initialValue = this.initial(name2);
    const areFunctions = isFunction(value2) && isFunction(initialValue);
    return areFunctions ? value2.toString() === initialValue.toString() : equalByValue(value2, initialValue);
  }
  initial(name2) {
    return getNestedOptionValue(this._initial, name2);
  }
  option(options2, value2) {
    const isGetter = arguments.length < 2 && "object" !== type(options2);
    if (isGetter) {
      return this._optionManager.get(void 0, this._normalizeName(options2));
    }
    this._startChangeCallback();
    try {
      this._optionManager.set(options2, value2);
    } finally {
      this._endChangeCallback();
    }
  }
  silent(options2, value2) {
    const isGetter = arguments.length < 2 && "object" !== type(options2);
    if (isGetter) {
      return this._optionManager.get(void 0, options2, void 0, true);
    }
    this._optionManager.set(options2, value2, void 0, true);
  }
  reset(name2) {
    if (name2) {
      const fullPath = getPathParts(name2);
      const value2 = fullPath.reduce((value3, field) => value3 ? value3[field] : this.initial(field), null);
      const defaultValue = isObject(value2) ? _extends({}, value2) : value2;
      this._optionManager.set(name2, defaultValue, false);
    }
  }
  getAliasesByName(name2) {
    return Object.keys(this._deprecated).filter((aliasName) => name2 === this._deprecated[aliasName].alias);
  }
  isDeprecated(name2) {
    return Object.prototype.hasOwnProperty.call(this._deprecated, name2);
  }
  cache(name2, options2) {
    const isGetter = arguments.length < 2;
    if (isGetter) {
      return this._cachedOptions[name2];
    }
    this._cachedOptions[name2] = extend(this._cachedOptions[name2], options2);
  }
};

// node_modules/devextreme/esm/__internal/core/m_postponed_operations.js
var PostponedOperations = class {
  constructor() {
    this._postponedOperations = {};
  }
  add(key, fn, postponedPromise) {
    if (key in this._postponedOperations) {
      postponedPromise && this._postponedOperations[key].promises.push(postponedPromise);
    } else {
      const completePromise = new Deferred();
      this._postponedOperations[key] = {
        fn,
        completePromise,
        promises: postponedPromise ? [postponedPromise] : []
      };
    }
    return this._postponedOperations[key].completePromise.promise();
  }
  callPostponedOperations() {
    for (const key in this._postponedOperations) {
      const operation = this._postponedOperations[key];
      if (isDefined(operation)) {
        if (operation.promises && operation.promises.length) {
          when(...operation.promises).done(operation.fn).then(operation.completePromise.resolve);
        } else {
          operation.fn().done(operation.completePromise.resolve);
        }
      }
    }
    this._postponedOperations = {};
  }
};

// node_modules/devextreme/esm/__internal/core/widget/component.js
var getEventName = (actionName) => actionName.charAt(2).toLowerCase() + actionName.substr(3);
var isInnerOption = (optionName) => 0 === optionName.indexOf("_", 0);
var Component = class extends class_default.inherit({}) {
  _setDeprecatedOptions() {
    this._deprecatedOptions = {};
  }
  _getDeprecatedOptions() {
    return this._deprecatedOptions;
  }
  _getDefaultOptions() {
    return {
      onInitialized: null,
      onOptionChanged: null,
      onDisposing: null,
      defaultOptionsRules: null
    };
  }
  _defaultOptionsRules() {
    return [];
  }
  _setOptionsByDevice(rules) {
    this._options.applyRules(rules);
  }
  _convertRulesToOptions(rules) {
    return convertRulesToOptions(rules);
  }
  _isInitialOptionValue(name2) {
    return this._options.isInitial(name2);
  }
  _setOptionsByReference() {
    this._optionsByReference = {};
  }
  _getOptionsByReference() {
    return this._optionsByReference;
  }
  ctor() {
    let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const {
      _optionChangedCallbacks,
      _disposingCallbacks
    } = options2;
    this.NAME = getName(this.constructor);
    this._eventsStrategy = EventsStrategy.create(this, options2.eventsStrategy);
    this._updateLockCount = 0;
    this._optionChangedCallbacks = _optionChangedCallbacks || callbacks_default();
    this._disposingCallbacks = _disposingCallbacks || callbacks_default();
    this.postponedOperations = new PostponedOperations();
    this._createOptions(options2);
  }
  _createOptions(options2) {
    this.beginUpdate();
    try {
      this._setOptionsByReference();
      this._setDeprecatedOptions();
      this._options = new Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());
      this._options.onChanging((name2, previousValue, value2) => this._initialized && this._optionChanging(name2, previousValue, value2));
      this._options.onDeprecated((option, info) => this._logDeprecatedOptionWarning(option, info));
      this._options.onChanged((name2, value2, previousValue) => this._notifyOptionChanged(name2, value2, previousValue));
      this._options.onStartChange(() => this.beginUpdate());
      this._options.onEndChange(() => this.endUpdate());
      this._options.addRules(this._defaultOptionsRules());
      this._options.validateOptions((o) => this._validateOptions(o));
      if (options2 && options2.onInitializing) {
        options2.onInitializing.apply(this, [options2]);
      }
      this._setOptionsByDevice(options2.defaultOptionsRules);
      this._initOptions(options2);
    } finally {
      this.endUpdate();
    }
  }
  _initOptions(options2) {
    this.option(options2);
  }
  _init() {
    this._createOptionChangedAction();
    this.on("disposing", (args) => {
      this._disposingCallbacks.fireWith(this, [args]);
    });
  }
  _logDeprecatedOptionWarning(option, info) {
    const message = info.message || `Use the '${info.alias}' option instead`;
    errors_default.log("W0001", this.NAME, option, info.since, message);
  }
  _logDeprecatedComponentWarning(since, alias) {
    errors_default.log("W0000", this.NAME, since, `Use the '${alias}' widget instead`);
  }
  _createOptionChangedAction() {
    this._optionChangedAction = this._createActionByOption("onOptionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _createDisposingAction() {
    this._disposingAction = this._createActionByOption("onDisposing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "onDisposing":
      case "onInitialized":
      case "defaultOptionsRules":
      default:
        break;
      case "onOptionChanged":
        this._createOptionChangedAction();
    }
  }
  _dispose() {
    var _this$_disposingActio;
    this._optionChangedCallbacks.empty();
    this._createDisposingAction();
    null === (_this$_disposingActio = this._disposingAction) || void 0 === _this$_disposingActio || _this$_disposingActio.call(this);
    this._eventsStrategy.dispose();
    this._options.dispose();
    this._disposed = true;
  }
  _lockUpdate() {
    this._updateLockCount++;
  }
  _unlockUpdate() {
    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
  }
  _isUpdateAllowed() {
    return 0 === this._updateLockCount;
  }
  _isInitializingRequired() {
    return !this._initializing && !this._initialized;
  }
  isInitialized() {
    return this._initialized;
  }
  _commitUpdate() {
    this.postponedOperations.callPostponedOperations();
    this._isInitializingRequired() && this._initializeComponent();
  }
  _initializeComponent() {
    this._initializing = true;
    try {
      this._init();
    } finally {
      this._initializing = false;
      this._lockUpdate();
      this._createActionByOption("onInitialized", {
        excludeValidators: ["disabled", "readOnly"]
      })();
      this._unlockUpdate();
      this._initialized = true;
    }
  }
  instance() {
    return this;
  }
  beginUpdate() {
    this._lockUpdate();
  }
  endUpdate() {
    this._unlockUpdate();
    this._isUpdateAllowed() && this._commitUpdate();
  }
  _optionChanging() {
  }
  _notifyOptionChanged(option, value2, previousValue) {
    if (this._initialized) {
      const optionNames = [option].concat(this._options.getAliasesByName(option));
      for (let i = 0; i < optionNames.length; i++) {
        const name2 = optionNames[i];
        const args = {
          name: getPathParts(name2)[0],
          fullName: name2,
          value: value2,
          previousValue
        };
        if (!isInnerOption(name2)) {
          var _this$_optionChangedA;
          this._optionChangedCallbacks.fireWith(this, [extend(this._defaultActionArgs(), args)]);
          null === (_this$_optionChangedA = this._optionChangedAction) || void 0 === _this$_optionChangedA || _this$_optionChangedA.call(this, extend({}, args));
        }
        if (!this._disposed && this._cancelOptionChange !== name2) {
          this._optionChanged(args);
        }
      }
    }
  }
  initialOption(name2) {
    return this._options.initial(name2);
  }
  _defaultActionConfig() {
    return {
      context: this,
      component: this
    };
  }
  _defaultActionArgs() {
    return {
      component: this
    };
  }
  _createAction(actionSource, config3) {
    let action;
    return (e) => {
      if (!isDefined(e)) {
        e = {};
      }
      if (!isPlainObject(e)) {
        e = {
          actionValue: e
        };
      }
      action = action || new action_default(actionSource, extend({}, config3, this._defaultActionConfig()));
      return action.execute.call(action, extend(e, this._defaultActionArgs()));
    };
  }
  _createActionByOption(optionName, config3) {
    var _this = this;
    let action;
    let eventName;
    let actionFunc;
    config3 = extend({}, config3);
    const result2 = function() {
      var _config, _config2;
      if (!eventName) {
        config3 = config3 || {};
        if ("string" !== typeof optionName) {
          throw errors_default.Error("E0008");
        }
        if (optionName.startsWith("on")) {
          eventName = getEventName(optionName);
        }
        actionFunc = _this.option(optionName);
      }
      if (!action && !actionFunc && !(null !== (_config = config3) && void 0 !== _config && _config.beforeExecute) && !(null !== (_config2 = config3) && void 0 !== _config2 && _config2.afterExecute) && !_this._eventsStrategy.hasEvent(eventName)) {
        return;
      }
      if (!action) {
        const {
          beforeExecute
        } = config3;
        config3.beforeExecute = function() {
          for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            props[_key2] = arguments[_key2];
          }
          beforeExecute && beforeExecute.apply(_this, props);
          _this._eventsStrategy.fireEvent(eventName, props[0].args);
        };
        action = _this._createAction(actionFunc, config3);
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (config_default2().wrapActionsBeforeExecute) {
        const beforeActionExecute = _this.option("beforeActionExecute") || noop2;
        const wrappedAction = beforeActionExecute(_this, action, config3) || action;
        return wrappedAction.apply(_this, args);
      }
      return action.apply(_this, args);
    };
    if (config_default2().wrapActionsBeforeExecute) {
      return result2;
    }
    const onActionCreated = this.option("onActionCreated") || noop2;
    return onActionCreated(this, result2, config3) || result2;
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
  hasActionSubscription(actionName) {
    return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName(actionName));
  }
  isOptionDeprecated(name2) {
    return this._options.isDeprecated(name2);
  }
  _setOptionWithoutOptionChange(name2, value2) {
    this._cancelOptionChange = name2;
    this.option(name2, value2);
    this._cancelOptionChange = false;
  }
  _getOptionValue(name2, context2) {
    const value2 = this.option(name2);
    if (isFunction(value2)) {
      return value2.bind(context2)();
    }
    return value2;
  }
  option() {
    return this._options.option(...arguments);
  }
  resetOption(name2) {
    this.beginUpdate();
    this._options.reset(name2);
    this.endUpdate();
  }
  _validateOptions(options2) {
    return options2;
  }
};

// node_modules/devextreme/esm/common/core/animation/presets/presets.js
var directionPostfixes = {
  forward: " dx-forward",
  backward: " dx-backward",
  none: " dx-no-direction",
  undefined: " dx-no-direction"
};
var AnimationPresetCollection = Component.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    this._registeredPresets = [];
    this.resetToDefaults();
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      defaultAnimationDuration: 400,
      defaultAnimationDelay: 0,
      defaultStaggerAnimationDuration: 300,
      defaultStaggerAnimationDelay: 40,
      defaultStaggerAnimationStartDelay: 500
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function(device) {
        return device.phone;
      },
      options: {
        defaultStaggerAnimationDuration: 350,
        defaultStaggerAnimationDelay: 50,
        defaultStaggerAnimationStartDelay: 0
      }
    }, {
      device: function() {
        return m_devices_default.current().android || m_devices_default.real.android;
      },
      options: {
        defaultAnimationDelay: 100
      }
    }]);
  },
  _getPresetOptionName: function(animationName) {
    return "preset_" + animationName;
  },
  _createAndroidSlideAnimationConfig: function(throughOpacity, widthMultiplier) {
    const that = this;
    const createBaseConfig = function(configModifier) {
      return {
        type: "slide",
        delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
        duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
      };
    };
    return {
      enter: function($element, configModifier) {
        const width = getWidth($element.parent()) * widthMultiplier;
        const direction = configModifier.direction;
        const config3 = createBaseConfig(configModifier);
        config3.to = {
          left: 0,
          opacity: 1
        };
        if ("forward" === direction) {
          config3.from = {
            left: width,
            opacity: throughOpacity
          };
        } else if ("backward" === direction) {
          config3.from = {
            left: -width,
            opacity: throughOpacity
          };
        } else {
          config3.from = {
            left: 0,
            opacity: 0
          };
        }
        return fx_default.createAnimation($element, config3);
      },
      leave: function($element, configModifier) {
        const width = getWidth($element.parent()) * widthMultiplier;
        const direction = configModifier.direction;
        const config3 = createBaseConfig(configModifier);
        config3.from = {
          left: 0,
          opacity: 1
        };
        if ("forward" === direction) {
          config3.to = {
            left: -width,
            opacity: throughOpacity
          };
        } else if ("backward" === direction) {
          config3.to = {
            left: width,
            opacity: throughOpacity
          };
        } else {
          config3.to = {
            left: 0,
            opacity: 0
          };
        }
        return fx_default.createAnimation($element, config3);
      }
    };
  },
  _createOpenDoorConfig: function() {
    const that = this;
    const createBaseConfig = function(configModifier) {
      return {
        type: "css",
        extraCssClasses: "dx-opendoor-animation",
        delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
        duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
      };
    };
    return {
      enter: function($element, configModifier) {
        const direction = configModifier.direction;
        const config3 = createBaseConfig(configModifier);
        config3.delay = "none" === direction ? config3.delay : config3.duration;
        config3.from = "dx-enter dx-opendoor-animation" + directionPostfixes[direction];
        config3.to = "dx-enter-active";
        return fx_default.createAnimation($element, config3);
      },
      leave: function($element, configModifier) {
        const direction = configModifier.direction;
        const config3 = createBaseConfig(configModifier);
        config3.from = "dx-leave dx-opendoor-animation" + directionPostfixes[direction];
        config3.to = "dx-leave-active";
        return fx_default.createAnimation($element, config3);
      }
    };
  },
  _createWinPopConfig: function() {
    const that = this;
    const baseConfig = {
      type: "css",
      extraCssClasses: "dx-win-pop-animation",
      duration: that.option("defaultAnimationDuration")
    };
    return {
      enter: function($element, configModifier) {
        const config3 = baseConfig;
        const direction = configModifier.direction;
        config3.delay = "none" === direction ? that.option("defaultAnimationDelay") : that.option("defaultAnimationDuration") / 2;
        config3.from = "dx-enter dx-win-pop-animation" + directionPostfixes[direction];
        config3.to = "dx-enter-active";
        return fx_default.createAnimation($element, config3);
      },
      leave: function($element, configModifier) {
        const config3 = baseConfig;
        const direction = configModifier.direction;
        config3.delay = that.option("defaultAnimationDelay");
        config3.from = "dx-leave dx-win-pop-animation" + directionPostfixes[direction];
        config3.to = "dx-leave-active";
        return fx_default.createAnimation($element, config3);
      }
    };
  },
  resetToDefaults: function() {
    this.clear();
    this.registerDefaultPresets();
    this.applyChanges();
  },
  clear: function(name2) {
    const that = this;
    const newRegisteredPresets = [];
    each(this._registeredPresets, function(index2, preset) {
      if (!name2 || name2 === preset.name) {
        that.option(that._getPresetOptionName(preset.name), void 0);
      } else {
        newRegisteredPresets.push(preset);
      }
    });
    this._registeredPresets = newRegisteredPresets;
    this.applyChanges();
  },
  registerPreset: function(name2, config3) {
    this._registeredPresets.push({
      name: name2,
      config: config3
    });
  },
  applyChanges: function() {
    const that = this;
    const customRules = [];
    each(this._registeredPresets, function(index2, preset) {
      const rule = {
        device: preset.config.device,
        options: {}
      };
      rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
      customRules.push(rule);
    });
    this._setOptionsByDevice(customRules);
  },
  getPreset: function(name2) {
    let result2 = name2;
    while ("string" === typeof result2) {
      result2 = this.option(this._getPresetOptionName(result2));
    }
    return result2;
  },
  registerDefaultPresets: function() {
    this.registerPreset("pop", {
      animation: {
        extraCssClasses: "dx-android-pop-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("openDoor", {
      animation: this._createOpenDoorConfig()
    });
    this.registerPreset("win-pop", {
      animation: this._createWinPopConfig()
    });
    this.registerPreset("fade", {
      animation: {
        extraCssClasses: "dx-fade-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("slide", {
      device: function() {
        return m_devices_default.current().android || m_devices_default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(1, 1)
    });
    this.registerPreset("slide", {
      device: function() {
        return !m_devices_default.current().android && !m_devices_default.real.android;
      },
      animation: {
        extraCssClasses: "dx-slide-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("ios7-slide", {
      animation: {
        extraCssClasses: "dx-ios7-slide-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("overflow", {
      animation: {
        extraCssClasses: "dx-overflow-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("ios7-toolbar", {
      device: function() {
        return !m_devices_default.current().android && !m_devices_default.real.android;
      },
      animation: {
        extraCssClasses: "dx-ios7-toolbar-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("ios7-toolbar", {
      device: function() {
        return m_devices_default.current().android || m_devices_default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(0, 0.4)
    });
    this.registerPreset("stagger-fade", {
      animation: {
        extraCssClasses: "dx-fade-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-slide", {
      animation: {
        extraCssClasses: "dx-slide-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-fade-slide", {
      animation: {
        extraCssClasses: "dx-fade-slide-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-drop", {
      animation: {
        extraCssClasses: "dx-drop-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-fade-drop", {
      animation: {
        extraCssClasses: "dx-fade-drop-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-fade-rise", {
      animation: {
        extraCssClasses: "dx-fade-rise-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-3d-drop", {
      animation: {
        extraCssClasses: "dx-3d-drop-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-fade-zoom", {
      animation: {
        extraCssClasses: "dx-fade-zoom-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
  }
});
var animationPresets = new AnimationPresetCollection();

// node_modules/devextreme/esm/common/core/animation/transition_executor/transition_executor.js
var directionPostfixes2 = {
  forward: " dx-forward",
  backward: " dx-backward",
  none: " dx-no-direction",
  undefined: " dx-no-direction"
};
var TransitionExecutor = class_default.inherit({
  ctor: function() {
    this._accumulatedDelays = {
      enter: 0,
      leave: 0
    };
    this._animations = [];
    this.reset();
  },
  _createAnimations: function($elements, initialConfig, configModifier, type2) {
    $elements = renderer_default($elements);
    const that = this;
    const result2 = [];
    configModifier = configModifier || {};
    const animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type2);
    if (animationConfig) {
      $elements.each(function() {
        const animation2 = that._createAnimation(renderer_default(this), animationConfig, configModifier);
        if (animation2) {
          animation2.element.addClass("dx-animating");
          animation2.setup();
          result2.push(animation2);
        }
      });
    }
    return result2;
  },
  _prepareElementAnimationConfig: function(config3, configModifier, type2) {
    let result2;
    if ("string" === typeof config3) {
      const presetName = config3;
      config3 = animationPresets.getPreset(presetName);
    }
    if (!config3) {
      result2 = void 0;
    } else if (isFunction(config3[type2])) {
      result2 = config3[type2];
    } else {
      result2 = extend({
        skipElementInitialStyles: true,
        cleanupWhen: this._completePromise
      }, config3, configModifier);
      if (!result2.type || "css" === result2.type) {
        const cssClass = "dx-" + type2;
        const extraCssClasses = (result2.extraCssClasses ? " " + result2.extraCssClasses : "") + directionPostfixes2[result2.direction];
        result2.type = "css";
        result2.from = (result2.from || cssClass) + extraCssClasses;
        result2.to = result2.to || cssClass + "-active";
      }
      result2.staggerDelay = result2.staggerDelay || 0;
      result2.delay = result2.delay || 0;
      if (result2.staggerDelay) {
        result2.delay += this._accumulatedDelays[type2];
        this._accumulatedDelays[type2] += result2.staggerDelay;
      }
    }
    return result2;
  },
  _createAnimation: function($element, animationConfig, configModifier) {
    let result2;
    if (isPlainObject(animationConfig)) {
      result2 = fx_default.createAnimation($element, animationConfig);
    } else if (isFunction(animationConfig)) {
      result2 = animationConfig($element, configModifier);
    }
    return result2;
  },
  _startAnimations: function() {
    const animations = this._animations;
    for (let i = 0; i < animations.length; i++) {
      animations[i].start();
    }
  },
  _stopAnimations: function(jumpToEnd) {
    const animations = this._animations;
    for (let i = 0; i < animations.length; i++) {
      animations[i].stop(jumpToEnd);
    }
  },
  _clearAnimations: function() {
    const animations = this._animations;
    for (let i = 0; i < animations.length; i++) {
      animations[i].element.removeClass("dx-animating");
    }
    this._animations.length = 0;
  },
  reset: function() {
    this._accumulatedDelays.enter = 0;
    this._accumulatedDelays.leave = 0;
    this._clearAnimations();
    this._completeDeferred = new Deferred();
    this._completePromise = this._completeDeferred.promise();
  },
  enter: function($elements, animationConfig, configModifier) {
    const animations = this._createAnimations($elements, animationConfig, configModifier, "enter");
    this._animations.push.apply(this._animations, animations);
  },
  leave: function($elements, animationConfig, configModifier) {
    const animations = this._createAnimations($elements, animationConfig, configModifier, "leave");
    this._animations.push.apply(this._animations, animations);
  },
  start: function() {
    const that = this;
    let result2;
    if (!this._animations.length) {
      that.reset();
      result2 = new Deferred().resolve().promise();
    } else {
      const animationDeferreds = map(this._animations, function(animation2) {
        const result3 = new Deferred();
        animation2.deferred.always(function() {
          result3.resolve();
        });
        return result3.promise();
      });
      result2 = when.apply(renderer_default, animationDeferreds).always(function() {
        that._completeDeferred.resolve();
        that.reset();
      });
      m_common_default.executeAsync(function() {
        that._startAnimations();
      });
    }
    return result2;
  },
  stop: function(jumpToEnd) {
    this._stopAnimations(jumpToEnd);
  }
});

// node_modules/devextreme/esm/__internal/events/m_visibility_change.js
var triggerVisibilityChangeEvent = function(eventName) {
  return function(element) {
    const $element = renderer_default(element || "body");
    const changeHandlers = $element.filter(".dx-visibility-change-handler").add($element.find(".dx-visibility-change-handler"));
    for (let i = 0; i < changeHandlers.length; i++) {
      m_events_engine_default.triggerHandler(changeHandlers[i], eventName);
    }
  };
};
var triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
var triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
var triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");
var m_visibility_change_default = {
  triggerHidingEvent,
  triggerResizeEvent,
  triggerShownEvent
};

// node_modules/devextreme/esm/common/core/events/visibility_change.js
var triggerShownEvent2 = m_visibility_change_default.triggerShownEvent;
var triggerHidingEvent2 = m_visibility_change_default.triggerHidingEvent;
var triggerResizeEvent2 = m_visibility_change_default.triggerResizeEvent;

// node_modules/devextreme/esm/__internal/core/utils/m_dom.js
var window12 = getWindow();
var getRootNodeHost = (element) => {
  if (!element.getRootNode) {
    return;
  }
  const {
    host
  } = element.getRootNode();
  if (isString(host)) {
    return;
  }
  return host;
};
var resetActiveElement = () => {
  const activeElement = dom_adapter_default.getActiveElement();
  if (activeElement && activeElement !== dom_adapter_default.getBody()) {
    var _activeElement$blur;
    null === (_activeElement$blur = activeElement.blur) || void 0 === _activeElement$blur || _activeElement$blur.call(activeElement);
  }
};
var clearSelection = () => {
  const selection = window12.getSelection();
  if (!selection) {
    return;
  }
  if ("Caret" === selection.type) {
    return;
  }
  if (selection.empty) {
    selection.empty();
  } else if (selection.removeAllRanges) {
    try {
      selection.removeAllRanges();
    } catch (e) {
    }
  }
};
var closestCommonParent = (startTarget, endTarget) => {
  const $startTarget = renderer_default(startTarget);
  const $endTarget = renderer_default(endTarget);
  if ($startTarget[0] === $endTarget[0]) {
    return $startTarget[0];
  }
  const $startParents = $startTarget.parents();
  const $endParents = $endTarget.parents();
  const startingParent = Math.min($startParents.length, $endParents.length);
  for (let i = -startingParent; i < 0; i++) {
    if ($startParents.get(i) === $endParents.get(i)) {
      return $startParents.get(i);
    }
  }
};
var extractTemplateMarkup = (element) => {
  element = renderer_default(element);
  const templateTag = element.length && element.filter(function() {
    const $node = renderer_default(this);
    return $node.is("script[type]") && !$node.attr("type").includes("script");
  });
  if (templateTag.length) {
    return templateTag.eq(0).html();
  }
  element = renderer_default("<div>").append(element);
  return element.html();
};
var normalizeTemplateElement = (element) => {
  let $element = renderer_default();
  if (isDefined(element) && (element.nodeType || isRenderer(element))) {
    $element = renderer_default(element);
  } else if ("object" !== typeof element) {
    $element = renderer_default("<div>").html(element).contents();
  }
  if (1 === $element.length) {
    if ($element.is("script")) {
      $element = normalizeTemplateElement($element.html().trim());
    } else if ($element.is("table")) {
      $element = $element.children("tbody").contents();
    }
  }
  return $element;
};
var clipboardText = (event, text) => {
  const clipboard = event.originalEvent && event.originalEvent.clipboardData || window12.clipboardData;
  if (!text) {
    return clipboard && clipboard.getData("Text");
  }
  clipboard && clipboard.setData("Text", text);
};
var contains2 = (container, element) => {
  if (!element) {
    return false;
  }
  if (isWindow(container)) {
    return contains2(container.document, element);
  }
  return container.contains(element) || contains2(container, getRootNodeHost(element));
};
var createTextElementHiddenCopy = (element, text, options2) => {
  const elementStyles = window12.getComputedStyle(renderer_default(element).get(0));
  const includePaddings = options2 && options2.includePaddings;
  return renderer_default("<div>").text(text).css({
    fontStyle: elementStyles.fontStyle,
    fontVariant: elementStyles.fontVariant,
    fontWeight: elementStyles.fontWeight,
    fontSize: elementStyles.fontSize,
    fontFamily: elementStyles.fontFamily,
    letterSpacing: elementStyles.letterSpacing,
    border: elementStyles.border,
    paddingTop: includePaddings ? elementStyles.paddingTop : "",
    paddingRight: includePaddings ? elementStyles.paddingRight : "",
    paddingBottom: includePaddings ? elementStyles.paddingBottom : "",
    paddingLeft: includePaddings ? elementStyles.paddingLeft : "",
    visibility: "hidden",
    whiteSpace: "pre",
    position: "absolute",
    float: "left"
  });
};
var insertBefore = (element, newElement) => {
  if (newElement) {
    dom_adapter_default.insertElement(element.parentNode, newElement, element);
  }
  return element;
};
var replaceWith = (element, newElement) => {
  if (!(newElement && newElement[0])) {
    return;
  }
  if (newElement.is(element)) {
    return element;
  }
  each(newElement, (_, currentElement) => {
    insertBefore(element[0], currentElement);
  });
  element.remove();
  return newElement;
};
var isElementInDom = ($element) => {
  const element = null === $element || void 0 === $element ? void 0 : $element.get(0);
  const shadowHost = null === element || void 0 === element ? void 0 : element.getRootNode().host;
  return !!renderer_default(shadowHost || element).closest(getWindow().document).length;
};
var m_dom_default = {
  resetActiveElement,
  clearSelection,
  closestCommonParent,
  extractTemplateMarkup,
  normalizeTemplateElement,
  clipboardText,
  contains: contains2,
  createTextElementHiddenCopy,
  insertBefore,
  replaceWith,
  isElementInDom
};

// node_modules/devextreme/esm/__internal/core/templates/m_template_base.js
var renderedCallbacks = callbacks_default({
  syncStrategy: true
});
var TemplateBase = class {
  render(options2) {
    options2 = options2 || {};
    const {
      onRendered
    } = options2;
    delete options2.onRendered;
    let $result;
    if (options2.renovated && options2.transclude && this._element) {
      $result = renderer_default("<div>").append(this._element).contents();
    } else {
      $result = this._renderCore(options2);
    }
    this._ensureResultInContainer($result, options2.container);
    renderedCallbacks.fire($result, options2.container);
    onRendered && onRendered();
    return $result;
  }
  _ensureResultInContainer($result, container) {
    if (!container) {
      return;
    }
    const $container = renderer_default(container);
    const resultInContainer = contains2($container.get(0), $result.get(0));
    $container.append($result);
    if (resultInContainer) {
      return;
    }
    const resultInBody = contains2(dom_adapter_default.getBody(), $container.get(0));
    if (!resultInBody) {
      return;
    }
    triggerShownEvent2($result);
  }
  _renderCore() {
    throw errors_default.Error("E0001");
  }
};

// node_modules/devextreme/esm/__internal/core/templates/m_bindable_template.js
var watchChanges = function(rawData, watchMethod, fields, fieldsMap, callback) {
  let fieldsDispose;
  const globalDispose = ((data2, watchMethod2, callback2) => watchMethod2(() => data2, callback2))(rawData, watchMethod, (dataWithRawFields) => {
    fieldsDispose && fieldsDispose();
    if (isPrimitive(dataWithRawFields)) {
      callback(dataWithRawFields);
      return;
    }
    fieldsDispose = function(data2, watchMethod2, fields2, fieldsMap2, callback2) {
      const resolvedData = {};
      const missedFields = fields2.slice();
      const watchHandlers = fields2.map((name2) => {
        const fieldGetter = fieldsMap2[name2];
        return watchMethod2(fieldGetter ? () => fieldGetter(data2) : () => data2[name2], (value2) => {
          resolvedData[name2] = value2;
          if (missedFields.length) {
            const index2 = missedFields.indexOf(name2);
            if (index2 >= 0) {
              missedFields.splice(index2, 1);
            }
          }
          if (!missedFields.length) {
            callback2(resolvedData);
          }
        });
      });
      return function() {
        watchHandlers.forEach((dispose2) => dispose2());
      };
    }(dataWithRawFields, watchMethod, fields, fieldsMap, callback);
  });
  return function() {
    fieldsDispose && fieldsDispose();
    globalDispose && globalDispose();
  };
};
var BindableTemplate = class extends TemplateBase {
  constructor(render2, fields, watchMethod, fieldsMap) {
    super();
    this._render = render2;
    this._fields = fields;
    this._fieldsMap = fieldsMap || {};
    this._watchMethod = watchMethod;
  }
  _renderCore(options2) {
    const $container = renderer_default(options2.container);
    const dispose2 = watchChanges(options2.model, this._watchMethod, this._fields, this._fieldsMap, (data2) => {
      $container.empty();
      this._render($container, data2, options2.model);
    });
    m_events_engine_default.on($container, removeEvent, dispose2);
    return $container.contents();
  }
};

// node_modules/devextreme/esm/__internal/data/m_errors.js
var errors = error_default(errors_default.ERROR_MESSAGES, {
  E4000: "[DevExpress.data]: {0}",
  E4001: "Unknown aggregating function is detected: '{0}'",
  E4002: "Unsupported OData protocol version is used",
  E4003: "Unknown filter operation is used: {0}",
  E4004: "The thenby() method is called before the sortby() method",
  E4005: "Store requires a key expression for this operation",
  E4006: "ArrayStore 'data' option must be an array",
  E4007: "Compound keys cannot be auto-generated",
  E4008: "Attempt to insert an item with a duplicated key",
  E4009: "Data item cannot be found",
  E4010: "CustomStore does not support creating queries",
  E4011: "Custom Store method is not implemented or is not a function: {0}",
  E4012: "Custom Store method returns an invalid value: {0}",
  E4013: "Local Store requires the 'name' configuration option is specified",
  E4014: "Unknown data type is specified for ODataStore: {0}",
  E4015: "Unknown entity name or alias is used: {0}",
  E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
  E4017: "Keys cannot be modified",
  E4018: "The server has returned a non-numeric value in a response to an item count request",
  E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
  E4020: "Unknown store type is detected: {0}",
  E4021: "The server response does not provide the totalCount value",
  E4022: "The server response does not provide the groupCount value",
  E4023: "Could not parse the following XML: {0}",
  E4024: "String function {0} cannot be used with the data field {1} of type {2}.",
  W4000: "Data returned from the server has an incorrect structure",
  W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
  W4002: "Data loading has failed for some cells due to the following error: {0}"
});
var errorHandler = null;
var handleError = function(error2) {
  var _errorHandler;
  null === (_errorHandler = errorHandler) || void 0 === _errorHandler || _errorHandler(error2);
};

// node_modules/devextreme/esm/__internal/data/m_utils.js
var ready3 = ready_callbacks_default.add;
var XHR_ERROR_UNLOAD = "DEVEXTREME_XHR_ERROR_UNLOAD";
var normalizeBinaryCriterion = function(crit) {
  return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]];
};
var normalizeSortingInfo = function(info) {
  if (!Array.isArray(info)) {
    info = [info];
  }
  return map(info, (i) => {
    const result2 = {
      selector: isFunction(i) || "string" === typeof i ? i : i.getter || i.field || i.selector,
      desc: !!(i.desc || "d" === String(i.dir).charAt(0).toLowerCase())
    };
    if (i.compare) {
      result2.compare = i.compare;
    }
    return result2;
  });
};
var errorMessageFromXhr = function() {
  const textStatusMessages = {
    timeout: "Network connection timeout",
    error: "Unspecified network error",
    parsererror: "Unexpected server response"
  };
  let unloading;
  ready3(() => {
    const window21 = getWindow();
    dom_adapter_default.listen(window21, "beforeunload", () => {
      unloading = true;
    });
  });
  return function(xhr, textStatus) {
    if (unloading) {
      return XHR_ERROR_UNLOAD;
    }
    if (xhr.status < 400) {
      return function(textStatus2) {
        let result2 = textStatusMessages[textStatus2];
        if (!result2) {
          return textStatus2;
        }
        return result2;
      }(textStatus);
    }
    return xhr.statusText;
  };
}();
var aggregators = {
  count: {
    seed: 0,
    step: (count) => 1 + count
  },
  sum: {
    seed: 0,
    step: (sum, item) => sum + item
  },
  min: {
    step: (min, item) => item < min ? item : min
  },
  max: {
    step: (max, item) => item > max ? item : max
  },
  avg: {
    seed: [0, 0],
    step: (pair, value2) => [pair[0] + value2, pair[1] + 1],
    finalize: (pair) => pair[1] ? pair[0] / pair[1] : NaN
  }
};
var processRequestResultLock = /* @__PURE__ */ function() {
  let lockCount = 0;
  let lockDeferred;
  return {
    obtain: function() {
      if (0 === lockCount) {
        lockDeferred = new Deferred();
      }
      lockCount++;
    },
    release: function() {
      lockCount--;
      if (lockCount < 1) {
        lockDeferred.resolve();
      }
    },
    promise: function() {
      const deferred = 0 === lockCount ? new Deferred().resolve() : lockDeferred;
      return deferred.promise();
    },
    reset: function() {
      lockCount = 0;
      if (lockDeferred) {
        lockDeferred.resolve();
      }
    }
  };
}();
function isConjunctiveOperator(condition) {
  return /^(and|&&|&)$/i.test(condition);
}
var keysEqual = function(keyExpr, key1, key2) {
  if (Array.isArray(keyExpr)) {
    const names = map(key1, (v, k) => k);
    let name2;
    for (let i = 0; i < names.length; i++) {
      name2 = names[i];
      if (!equalByValue(key1[name2], key2[name2], {
        strict: false
      })) {
        return false;
      }
    }
    return true;
  }
  return equalByValue(key1, key2, {
    strict: false
  });
};
var isUnaryOperation = function(crit) {
  return "!" === crit[0] && Array.isArray(crit[1]);
};
var isGroupOperator = function(value2) {
  return "and" === value2 || "or" === value2;
};
var isUniformEqualsByOr = function(crit) {
  if (crit.length > 2 && Array.isArray(crit[0]) && "or" === crit[1] && "string" === typeof crit[0][0] && "=" === crit[0][1]) {
    const [prop] = crit[0];
    return !crit.find((el, i) => i % 2 !== 0 ? "or" !== el : !Array.isArray(el) || 3 !== el.length || el[0] !== prop || "=" !== el[1]);
  }
  return false;
};
var isGroupCriterion = function(crit) {
  const first = crit[0];
  const second = crit[1];
  if (Array.isArray(first)) {
    return true;
  }
  if (isFunction(first)) {
    if (Array.isArray(second) || isFunction(second) || isGroupOperator(second)) {
      return true;
    }
  }
  return false;
};
var trivialPromise = function() {
  const d = new Deferred();
  return d.resolve.apply(d, arguments).promise();
};
var rejectedPromise = function() {
  const d = new Deferred();
  return d.reject.apply(d, arguments).promise();
};
function throttle(func, timeout) {
  let timeoutId;
  return function() {
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        timeoutId = void 0;
        func.call(this);
      }, isFunction(timeout) ? timeout() : timeout);
    }
    return timeoutId;
  };
}
function throttleChanges(func, timeout) {
  let cache = [];
  const throttled = throttle(function() {
    func.call(this, cache);
    cache = [];
  }, timeout);
  return function(changes) {
    if (Array.isArray(changes)) {
      cache.push(...changes);
    }
    return throttled.call(this, cache);
  };
}

// node_modules/devextreme/esm/__internal/data/m_array_utils.js
function hasKey(target, keyOrKeys) {
  let key;
  const keys = "string" === typeof keyOrKeys ? keyOrKeys.split() : keyOrKeys.slice();
  while (keys.length) {
    key = keys.shift();
    if (key in target) {
      return true;
    }
  }
  return false;
}
function findItems(keyInfo, items, key, groupCount) {
  let childItems;
  let result2;
  if (groupCount) {
    for (let i = 0; i < items.length; i++) {
      childItems = items[i].items || items[i].collapsedItems || [];
      result2 = findItems(keyInfo, childItems || [], key, groupCount - 1);
      if (result2) {
        return result2;
      }
    }
  } else if (indexByKey(keyInfo, items, key) >= 0) {
    return items;
  }
}
function getItems(keyInfo, items, key, groupCount) {
  if (groupCount) {
    return findItems(keyInfo, items, key, groupCount) || [];
  }
  return items;
}
function generateDataByKeyMap(keyInfo, array) {
  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
    const dataByKeyMap = {};
    const arrayLength = array.length;
    for (let i = 0; i < arrayLength; i++) {
      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];
    }
    array._dataByKeyMap = dataByKeyMap;
    array._dataByKeyMapLength = arrayLength;
  }
}
function getCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
}
function getHasKeyCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
  return true;
}
function setDataByKeyMapValue(array, key, data2) {
  if (array._dataByKeyMap) {
    array._dataByKeyMap[JSON.stringify(key)] = data2;
    array._dataByKeyMapLength += data2 ? 1 : -1;
  }
}
function cloneInstanceWithChangedPaths(instance, changes, clonedInstances) {
  clonedInstances = clonedInstances || /* @__PURE__ */ new WeakMap();
  const result2 = instance ? Object.create(Object.getPrototypeOf(instance)) : {};
  if (instance) {
    clonedInstances.set(instance, result2);
  }
  const instanceWithoutPrototype = _extends({}, instance);
  deepExtendArraySafe(result2, instanceWithoutPrototype, true, true, true);
  for (const name2 in instanceWithoutPrototype) {
    const value2 = instanceWithoutPrototype[name2];
    const change = null === changes || void 0 === changes ? void 0 : changes[name2];
    if (isObject(value2) && !isPlainObject(value2) && isObject(change) && !clonedInstances.has(value2)) {
      result2[name2] = cloneInstanceWithChangedPaths(value2, change, clonedInstances);
    }
  }
  for (const name2 in result2) {
    const prop = result2[name2];
    if (isObject(prop) && clonedInstances.has(prop)) {
      result2[name2] = clonedInstances.get(prop);
    }
  }
  return result2;
}
function createObjectWithChanges(target, changes) {
  const result2 = cloneInstanceWithChangedPaths(target, changes);
  return deepExtendArraySafe(result2, changes, true, true, true);
}
function applyBatch(_ref) {
  let {
    keyInfo,
    data: data2,
    changes,
    groupCount,
    useInsertIndex,
    immutable,
    disableCache,
    logError,
    skipCopying
  } = _ref;
  const resultItems = true === immutable ? [...data2] : data2;
  changes.forEach((item) => {
    const items = "insert" === item.type ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);
    !disableCache && generateDataByKeyMap(keyInfo, items);
    switch (item.type) {
      case "update":
        update(keyInfo, items, item.key, item.data, true, immutable, logError);
        break;
      case "insert":
        insert(keyInfo, items, item.data, useInsertIndex && isDefined(item.index) ? item.index : -1, true, logError, skipCopying);
        break;
      case "remove":
        remove(keyInfo, items, item.key, true, logError);
    }
  });
  return resultItems;
}
function getErrorResult(isBatch, logError, errorCode) {
  return !isBatch ? rejectedPromise(errors.Error(errorCode)) : logError && errors.log(errorCode);
}
function update(keyInfo, array, key, data2, isBatch, immutable, logError) {
  let target;
  const keyExpr = keyInfo.key();
  if (keyExpr) {
    if (hasKey(data2, keyExpr) && !keysEqual(keyExpr, key, keyInfo.keyOf(data2))) {
      return getErrorResult(isBatch, logError, "E4017");
    }
    target = getCacheValue(array, key);
    if (!target) {
      const index2 = indexByKey(keyInfo, array, key);
      if (index2 < 0) {
        return getErrorResult(isBatch, logError, "E4009");
      }
      target = array[index2];
      if (true === immutable && isDefined(target)) {
        const newTarget = createObjectWithChanges(target, data2);
        array[index2] = newTarget;
        return !isBatch && trivialPromise(newTarget, key);
      }
    }
  } else {
    target = key;
  }
  deepExtendArraySafe(target, data2, true, false, true, true);
  if (!isBatch) {
    if (config_default2().useLegacyStoreResult) {
      return trivialPromise(key, data2);
    }
    return trivialPromise(target, key);
  }
}
function insert(keyInfo, array, data2, index2, isBatch, logError, skipCopying) {
  let keyValue;
  const keyExpr = keyInfo.key();
  const obj = isPlainObject(data2) && !skipCopying ? extend({}, data2) : data2;
  if (keyExpr) {
    keyValue = keyInfo.keyOf(obj);
    if (void 0 === keyValue || "object" === typeof keyValue && isEmptyObject(keyValue)) {
      if (Array.isArray(keyExpr)) {
        throw errors.Error("E4007");
      }
      keyValue = obj[keyExpr] = String(new guid_default2());
    } else if (void 0 !== array[indexByKey(keyInfo, array, keyValue)]) {
      return getErrorResult(isBatch, logError, "E4008");
    }
  } else {
    keyValue = obj;
  }
  if (index2 >= 0) {
    array.splice(index2, 0, obj);
  } else {
    array.push(obj);
  }
  setDataByKeyMapValue(array, keyValue, obj);
  if (!isBatch) {
    return trivialPromise(config_default2().useLegacyStoreResult ? data2 : obj, keyValue);
  }
}
function remove(keyInfo, array, key, isBatch, logError) {
  const index2 = indexByKey(keyInfo, array, key);
  if (index2 > -1) {
    array.splice(index2, 1);
    setDataByKeyMapValue(array, key, null);
  }
  if (!isBatch) {
    return trivialPromise(key);
  }
  if (index2 < 0) {
    return getErrorResult(isBatch, logError, "E4009");
  }
}
function indexByKey(keyInfo, array, key) {
  const keyExpr = keyInfo.key();
  if (!getHasKeyCacheValue(array, key)) {
    return -1;
  }
  for (let i = 0, arrayLength = array.length; i < arrayLength; i++) {
    if (keysEqual(keyExpr, keyInfo.keyOf(array[i]), key)) {
      return i;
    }
  }
  return -1;
}

// node_modules/devextreme/esm/__internal/data/m_array_query.js
var Iterator = class_default.inherit({
  toArray() {
    const result2 = [];
    this.reset();
    while (this.next()) {
      result2.push(this.current());
    }
    return result2;
  },
  countable: () => false
});
var ArrayIterator = Iterator.inherit({
  ctor(array) {
    this.array = array;
    this.index = -1;
  },
  next() {
    if (this.index + 1 < this.array.length) {
      this.index++;
      return true;
    }
    return false;
  },
  current() {
    return this.array[this.index];
  },
  reset() {
    this.index = -1;
  },
  toArray() {
    return this.array.slice(0);
  },
  countable: () => true,
  count() {
    return this.array.length;
  }
});
var WrappedIterator = Iterator.inherit({
  ctor(iter) {
    this.iter = iter;
  },
  next() {
    return this.iter.next();
  },
  current() {
    return this.iter.current();
  },
  reset() {
    return this.iter.reset();
  }
});
var MapIterator = WrappedIterator.inherit({
  ctor(iter, mapper) {
    this.callBase(iter);
    this.index = -1;
    this.mapper = mapper;
  },
  current() {
    return this.mapper(this.callBase(), this.index);
  },
  next() {
    const hasNext = this.callBase();
    if (hasNext) {
      this.index++;
    }
    return hasNext;
  }
});
var defaultCompare = function(xValue, yValue, options2) {
  if (isString(xValue) && isString(yValue) && (null !== options2 && void 0 !== options2 && options2.locale || null !== options2 && void 0 !== options2 && options2.collatorOptions)) {
    return new Intl.Collator((null === options2 || void 0 === options2 ? void 0 : options2.locale) || void 0, (null === options2 || void 0 === options2 ? void 0 : options2.collatorOptions) || void 0).compare(xValue, yValue);
  }
  xValue = toComparable(xValue, false, options2);
  yValue = toComparable(yValue, false, options2);
  if (null === xValue && null !== yValue) {
    return -1;
  }
  if (null !== xValue && null === yValue) {
    return 1;
  }
  if (void 0 === xValue && void 0 !== yValue) {
    return 1;
  }
  if (void 0 !== xValue && void 0 === yValue) {
    return -1;
  }
  if (xValue < yValue) {
    return -1;
  }
  if (xValue > yValue) {
    return 1;
  }
  return 0;
};
var SortIterator = Iterator.inherit({
  ctor(iter, getter, desc, compare3) {
    this.langParams = iter.langParams;
    if (!(iter instanceof MapIterator)) {
      iter = new MapIterator(iter, this._wrap);
      iter.langParams = this.langParams;
    }
    this.iter = iter;
    this.rules = [{
      getter,
      desc,
      compare: compare3,
      langParams: this.langParams
    }];
  },
  thenBy(getter, desc, compare3) {
    const result2 = new SortIterator(this.sortedIter || this.iter, getter, desc, compare3);
    if (!this.sortedIter) {
      result2.rules = this.rules.concat(result2.rules);
    }
    return result2;
  },
  next() {
    this._ensureSorted();
    return this.sortedIter.next();
  },
  current() {
    this._ensureSorted();
    return this.sortedIter.current();
  },
  reset() {
    delete this.sortedIter;
  },
  countable() {
    return this.sortedIter || this.iter.countable();
  },
  count() {
    if (this.sortedIter) {
      return this.sortedIter.count();
    }
    return this.iter.count();
  },
  _ensureSorted() {
    const that = this;
    if (that.sortedIter) {
      return;
    }
    each(that.rules, function() {
      this.getter = compileGetter(this.getter);
    });
    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort((x, y) => that._compare(x, y))), that._unwrap);
  },
  _wrap: (record, index2) => ({
    index: index2,
    value: record
  }),
  _unwrap: (wrappedItem) => wrappedItem.value,
  _getDefaultCompare: (langParams) => (xValue, yValue) => defaultCompare(xValue, yValue, langParams),
  _compare(x, y) {
    const xIndex = x.index;
    const yIndex = y.index;
    x = x.value;
    y = y.value;
    if (x === y) {
      return xIndex - yIndex;
    }
    for (let i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
      const rule = this.rules[i];
      const xValue = rule.getter(x);
      const yValue = rule.getter(y);
      const compare3 = rule.compare || this._getDefaultCompare(rule.langParams);
      const compareResult = compare3(xValue, yValue);
      if (compareResult) {
        return rule.desc ? -compareResult : compareResult;
      }
    }
    return xIndex - yIndex;
  }
});
var compileCriteria = /* @__PURE__ */ function() {
  let langParams = {};
  const _toComparable = (value2) => toComparable(value2, false, langParams);
  const compileGroup = function(crit) {
    if (isUniformEqualsByOr(crit)) {
      return ((crit2) => {
        const getter = compileGetter(crit2[0][0]);
        const filterValues = crit2.reduce((acc, item, i) => {
          if (i % 2 === 0) {
            acc.push(_toComparable(item[2]));
          }
          return acc;
        }, []);
        return (obj) => {
          const value2 = _toComparable(getter(obj));
          return filterValues.some((filterValue) => useStrictComparison(filterValue) ? value2 === filterValue : value2 == filterValue);
        };
      })(crit);
    }
    const ops = [];
    let isConjunctiveOperator2 = false;
    let isConjunctiveNextOperator = false;
    each(crit, function() {
      if (Array.isArray(this) || isFunction(this)) {
        if (ops.length > 1 && isConjunctiveOperator2 !== isConjunctiveNextOperator) {
          throw errors.Error("E4019");
        }
        ops.push(compileCriteria(this, langParams));
        isConjunctiveOperator2 = isConjunctiveNextOperator;
        isConjunctiveNextOperator = true;
      } else {
        isConjunctiveNextOperator = isConjunctiveOperator(this);
      }
    });
    return function(d) {
      let result2 = isConjunctiveOperator2;
      for (let i = 0; i < ops.length; i++) {
        if (ops[i](d) !== isConjunctiveOperator2) {
          result2 = !isConjunctiveOperator2;
          break;
        }
      }
      return result2;
    };
  };
  const toString = function(value2) {
    var _langParams;
    return isDefined(value2) ? null !== (_langParams = langParams) && void 0 !== _langParams && _langParams.locale ? value2.toLocaleString(langParams.locale) : value2.toString() : "";
  };
  function compileEquals(getter, value2, negate) {
    return function(obj) {
      obj = _toComparable(getter(obj));
      let result2 = useStrictComparison(value2) ? obj === value2 : obj == value2;
      if (negate) {
        result2 = !result2;
      }
      return result2;
    };
  }
  function useStrictComparison(value2) {
    return "" === value2 || 0 === value2 || false === value2;
  }
  return function(crit, options2) {
    langParams = options2 || {};
    if (isFunction(crit)) {
      return crit;
    }
    if (isGroupCriterion(crit)) {
      return compileGroup(crit);
    }
    if (isUnaryOperation(crit)) {
      return function(crit2) {
        const op = crit2[0];
        const criteria = compileCriteria(crit2[1], langParams);
        if ("!" === op) {
          return function(obj) {
            return !criteria(obj);
          };
        }
        throw errors.Error("E4003", op);
      }(crit);
    }
    return function(crit2) {
      crit2 = normalizeBinaryCriterion(crit2);
      const getter = compileGetter(crit2[0]);
      const op = crit2[1];
      let value2 = crit2[2];
      value2 = _toComparable(value2);
      const compare3 = (obj, operatorFn) => {
        obj = _toComparable(getter(obj));
        return (null == value2 || null == obj) && value2 !== obj ? false : operatorFn(obj, value2);
      };
      switch (op.toLowerCase()) {
        case "=":
          return compileEquals(getter, value2);
        case "<>":
          return compileEquals(getter, value2, true);
        case ">":
          return (obj) => compare3(obj, (a, b) => a > b);
        case "<":
          return (obj) => compare3(obj, (a, b) => a < b);
        case ">=":
          return (obj) => compare3(obj, (a, b) => a >= b);
        case "<=":
          return (obj) => compare3(obj, (a, b) => a <= b);
        case "startswith":
          return (obj) => _toComparable(toString(getter(obj))).startsWith(value2);
        case "endswith":
          return (obj) => _toComparable(toString(getter(obj))).endsWith(value2);
        case "contains":
          return (obj) => _toComparable(toString(getter(obj))).includes(value2);
        case "notcontains":
          return (obj) => !_toComparable(toString(getter(obj))).includes(value2);
      }
      throw errors.Error("E4003", op);
    }(crit);
  };
}();
var FilterIterator = WrappedIterator.inherit({
  ctor(iter, criteria) {
    this.callBase(iter);
    this.langParams = iter.langParams;
    this.criteria = compileCriteria(criteria, this.langParams);
  },
  next() {
    while (this.iter.next()) {
      if (this.criteria(this.current())) {
        return true;
      }
    }
    return false;
  }
});
var GroupIterator = Iterator.inherit({
  ctor(iter, getter) {
    this.iter = iter;
    this.getter = getter;
  },
  next() {
    this._ensureGrouped();
    return this.groupedIter.next();
  },
  current() {
    this._ensureGrouped();
    return this.groupedIter.current();
  },
  reset() {
    delete this.groupedIter;
  },
  countable() {
    return !!this.groupedIter;
  },
  count() {
    return this.groupedIter.count();
  },
  _ensureGrouped() {
    if (this.groupedIter) {
      return;
    }
    const hash = {};
    const keys = [];
    const {
      iter
    } = this;
    const getter = compileGetter(this.getter);
    iter.reset();
    while (iter.next()) {
      const current2 = iter.current();
      const key = getter(current2);
      if (key in hash) {
        hash[key].push(current2);
      } else {
        hash[key] = [current2];
        keys.push(key);
      }
    }
    this.groupedIter = new ArrayIterator(map(keys, (key) => ({
      key,
      items: hash[key]
    })));
  }
});
var SelectIterator = WrappedIterator.inherit({
  ctor(iter, getter) {
    this.callBase(iter);
    this.getter = compileGetter(getter);
  },
  current() {
    return this.getter(this.callBase());
  },
  countable() {
    return this.iter.countable();
  },
  count() {
    return this.iter.count();
  }
});
var SliceIterator = WrappedIterator.inherit({
  ctor(iter, skip, take) {
    this.callBase(iter);
    this.skip = Math.max(0, skip);
    this.take = Math.max(0, take);
    this.pos = 0;
  },
  next() {
    if (this.pos >= this.skip + this.take) {
      return false;
    }
    while (this.pos < this.skip && this.iter.next()) {
      this.pos++;
    }
    this.pos++;
    return this.iter.next();
  },
  reset() {
    this.callBase();
    this.pos = 0;
  },
  countable() {
    return this.iter.countable();
  },
  count() {
    return Math.min(this.iter.count() - this.skip, this.take);
  }
});
var arrayQueryImpl = function(iter, queryOptions) {
  queryOptions = queryOptions || {};
  if (!(iter instanceof Iterator)) {
    iter = new ArrayIterator(iter);
  }
  if (queryOptions.langParams) {
    iter.langParams = queryOptions.langParams;
  }
  const handleError2 = function(error2) {
    const handler = queryOptions.errorHandler;
    if (handler) {
      handler(error2);
    }
    handleError(error2);
  };
  const aggregateCore = function(aggregator) {
    const d = new Deferred().fail(handleError2);
    let seed;
    const {
      step
    } = aggregator;
    const {
      finalize
    } = aggregator;
    try {
      iter.reset();
      if ("seed" in aggregator) {
        seed = aggregator.seed;
      } else {
        seed = iter.next() ? iter.current() : NaN;
      }
      let accumulator = seed;
      while (iter.next()) {
        accumulator = step(accumulator, iter.current());
      }
      d.resolve(finalize ? finalize(accumulator) : accumulator);
    } catch (x) {
      d.reject(x);
    }
    return d.promise();
  };
  const standardAggregate = function(name2) {
    return aggregateCore(aggregators[name2]);
  };
  const select = function(getter) {
    if (!isFunction(getter) && !Array.isArray(getter)) {
      getter = [].slice.call(arguments);
    }
    return chainQuery(new SelectIterator(iter, getter));
  };
  const selectProp = function(name2) {
    return select(compileGetter(name2));
  };
  function chainQuery(iter2) {
    return arrayQueryImpl(iter2, queryOptions);
  }
  return {
    toArray: () => iter.toArray(),
    enumerate() {
      const d = new Deferred().fail(handleError2);
      try {
        d.resolve(iter.toArray());
      } catch (x) {
        d.reject(x);
      }
      return d.promise();
    },
    setLangParams(options2) {
      iter.langParams = options2;
    },
    sortBy: (getter, desc, compare3) => chainQuery(new SortIterator(iter, getter, desc, compare3)),
    thenBy(getter, desc, compare3) {
      if (iter instanceof SortIterator) {
        return chainQuery(iter.thenBy(getter, desc, compare3));
      }
      throw errors.Error("E4004");
    },
    filter(criteria) {
      if (!Array.isArray(criteria)) {
        criteria = [].slice.call(arguments);
      }
      return chainQuery(new FilterIterator(iter, criteria));
    },
    slice(skip, take) {
      if (void 0 === take) {
        take = Number.MAX_VALUE;
      }
      return chainQuery(new SliceIterator(iter, skip, take));
    },
    select,
    groupBy: (getter) => chainQuery(new GroupIterator(iter, getter)),
    aggregate: function(seed, step, finalize) {
      if (arguments.length < 2) {
        return aggregateCore({
          step: arguments[0]
        });
      }
      return aggregateCore({
        seed,
        step,
        finalize
      });
    },
    count() {
      if (iter.countable()) {
        const d = new Deferred().fail(handleError2);
        try {
          d.resolve(iter.count());
        } catch (x) {
          d.reject(x);
        }
        return d.promise();
      }
      return standardAggregate("count");
    },
    sum(getter) {
      if (getter) {
        return selectProp(getter).sum();
      }
      return standardAggregate("sum");
    },
    min(getter) {
      if (getter) {
        return selectProp(getter).min();
      }
      return standardAggregate("min");
    },
    max(getter) {
      if (getter) {
        return selectProp(getter).max();
      }
      return standardAggregate("max");
    },
    avg(getter) {
      if (getter) {
        return selectProp(getter).avg();
      }
      return standardAggregate("avg");
    }
  };
};
var m_array_query_default = arrayQueryImpl;

// node_modules/devextreme/esm/__internal/data/m_store_helper.js
function multiLevelGroup(query2, groupInfo) {
  query2 = query2.groupBy(groupInfo[0].selector);
  if (groupInfo.length > 1) {
    query2 = query2.select((g) => extend({}, g, {
      items: multiLevelGroup(m_array_query_default(g.items), groupInfo.slice(1)).toArray()
    }));
  }
  return query2;
}
function arrangeSortingInfo(groupInfo, sortInfo) {
  const filteredGroup = [];
  each(groupInfo, (_, group) => {
    const collision = grep(sortInfo, (sort) => group.selector === sort.selector);
    if (collision.length < 1) {
      filteredGroup.push(group);
    }
  });
  return filteredGroup.concat(sortInfo);
}
function queryByOptions(query2, options2, isCountQuery) {
  var _options;
  options2 = options2 || {};
  const {
    filter
  } = options2;
  if (null !== (_options = options2) && void 0 !== _options && _options.langParams) {
    var _query$setLangParams, _query;
    null === (_query$setLangParams = (_query = query2).setLangParams) || void 0 === _query$setLangParams || _query$setLangParams.call(_query, options2.langParams);
  }
  if (filter) {
    query2 = query2.filter(filter);
  }
  if (isCountQuery) {
    return query2;
  }
  let {
    sort
  } = options2;
  const {
    select
  } = options2;
  let {
    group
  } = options2;
  const {
    skip
  } = options2;
  const {
    take
  } = options2;
  if (group) {
    group = normalizeSortingInfo(group);
    group.keepInitialKeyOrder = !!options2.group.keepInitialKeyOrder;
  }
  if (sort || group) {
    sort = normalizeSortingInfo(sort || []);
    if (group && !group.keepInitialKeyOrder) {
      sort = arrangeSortingInfo(group, sort);
    }
    each(sort, function(index2) {
      query2 = query2[index2 ? "thenBy" : "sortBy"](this.selector, this.desc, this.compare);
    });
  }
  if (select) {
    query2 = query2.select(select);
  }
  if (group) {
    query2 = multiLevelGroup(query2, group);
  }
  if (take || skip) {
    query2 = query2.slice(skip || 0, take);
  }
  return query2;
}
var m_store_helper_default = {
  multiLevelGroup,
  arrangeSortingInfo,
  queryByOptions
};

// node_modules/devextreme/esm/__internal/data/m_abstract_store.js
var {
  abstract: abstract2
} = class_default;
var {
  queryByOptions: queryByOptions2
} = m_store_helper_default;
var storeImpl = {};
var Store = class_default.inherit({
  _langParams: {},
  ctor(options2) {
    const that = this;
    options2 = options2 || {};
    this._eventsStrategy = new EventsStrategy(this);
    each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onPush", "onRemoved", "onRemoving", "onModified", "onModifying"], (_, optionName) => {
      if (optionName in options2) {
        that.on(optionName.slice(2).toLowerCase(), options2[optionName]);
      }
    });
    this._key = options2.key;
    this._errorHandler = options2.errorHandler;
    this._useDefaultSearch = true;
  },
  _clearCache: noop2,
  _customLoadOptions: () => null,
  key() {
    return this._key;
  },
  keyOf(obj) {
    if (!this._keyGetter) {
      this._keyGetter = compileGetter(this.key());
    }
    return this._keyGetter(obj);
  },
  _requireKey() {
    if (!this.key()) {
      throw errors.Error("E4005");
    }
  },
  load(options2) {
    const that = this;
    options2 = options2 || {};
    this._eventsStrategy.fireEvent("loading", [options2]);
    return this._withLock(this._loadImpl(options2)).done((result2) => {
      that._eventsStrategy.fireEvent("loaded", [result2, options2]);
    });
  },
  _loadImpl(options2) {
    if (!isEmptyObject(this._langParams)) {
      options2 = options2 || {};
      options2._langParams = _extends({}, this._langParams, options2._langParams);
    }
    return queryByOptions2(this.createQuery(options2), options2).enumerate();
  },
  _withLock(task) {
    const result2 = new Deferred();
    task.done(function() {
      const that = this;
      const args = arguments;
      processRequestResultLock.promise().done(() => {
        result2.resolveWith(that, args);
      });
    }).fail(function() {
      result2.rejectWith(this, arguments);
    });
    return result2;
  },
  createQuery: abstract2,
  totalCount(options2) {
    return this._totalCountImpl(options2);
  },
  _totalCountImpl(options2) {
    return queryByOptions2(this.createQuery(options2), options2, true).count();
  },
  byKey(key, extraOptions) {
    return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)));
  },
  _byKeyImpl: abstract2,
  insert(values) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("inserting", [values]);
    return that._addFailHandlers(that._insertImpl(values).done((callbackValues, callbackKey) => {
      that._eventsStrategy.fireEvent("inserted", [callbackValues, callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _insertImpl: abstract2,
  update(key, values) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("updating", [key, values]);
    return that._addFailHandlers(that._updateImpl(key, values).done(() => {
      that._eventsStrategy.fireEvent("updated", [key, values]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _updateImpl: abstract2,
  push(changes) {
    const beforePushArgs = {
      changes,
      waitFor: []
    };
    this._eventsStrategy.fireEvent("beforePushAggregation", [beforePushArgs]);
    when(...beforePushArgs.waitFor).done(() => {
      this._pushImpl(changes);
      this._eventsStrategy.fireEvent("beforePush", [{
        changes
      }]);
      this._eventsStrategy.fireEvent("push", [changes]);
    });
  },
  _pushImpl: noop2,
  remove(key) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("removing", [key]);
    return that._addFailHandlers(that._removeImpl(key).done((callbackKey) => {
      that._eventsStrategy.fireEvent("removed", [callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _removeImpl: abstract2,
  _addFailHandlers(deferred) {
    return deferred.fail(this._errorHandler).fail(handleError);
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
Store.create = function(alias, options2) {
  if (!(alias in storeImpl)) {
    throw errors.Error("E4020", alias);
  }
  return new storeImpl[alias](options2);
};
Store.registerClass = function(type2, alias) {
  if (alias) {
    storeImpl[alias] = type2;
  }
  return type2;
};
Store.inherit = /* @__PURE__ */ function(inheritor) {
  return function(members, alias) {
    const type2 = inheritor.apply(this, [members]);
    Store.registerClass(type2, alias);
    return type2;
  };
}(Store.inherit);
var m_abstract_store_default = Store;

// node_modules/devextreme/esm/__internal/data/m_custom_store.js
var TOTAL_COUNT = "totalCount";
var LOAD = "load";
var BY_KEY = "byKey";
var INSERT = "insert";
var UPDATE = "update";
var REMOVE = "remove";
function isPromise2(obj) {
  return obj && isFunction(obj.then);
}
function trivialPromise2(value2) {
  return new Deferred().resolve(value2).promise();
}
function ensureRequiredFuncOption(name2, obj) {
  if (!isFunction(obj)) {
    throw errors.Error("E4011", name2);
  }
}
function throwInvalidUserFuncResult(name2) {
  throw errors.Error("E4012", name2);
}
function createUserFuncFailureHandler(pendingDeferred) {
  return function(arg) {
    let error2;
    if (arg instanceof Error) {
      error2 = arg;
    } else {
      error2 = new Error(function(promiseArguments) {
        const xhr = promiseArguments[0];
        const textStatus = promiseArguments[1];
        if (!xhr || !xhr.getResponseHeader) {
          return null;
        }
        return errorMessageFromXhr(xhr, textStatus);
      }(arguments) || arg && String(arg) || "Unknown error");
    }
    if (error2.message !== XHR_ERROR_UNLOAD) {
      pendingDeferred.reject(error2);
    }
  };
}
function invokeUserLoad(store, options2) {
  const userFunc = store._loadFunc;
  let userResult;
  ensureRequiredFuncOption(LOAD, userFunc);
  userResult = userFunc.apply(store, [options2]);
  if (Array.isArray(userResult)) {
    userResult = trivialPromise2(userResult);
  } else if (null === userResult || void 0 === userResult) {
    userResult = trivialPromise2([]);
  } else if (!isPromise2(userResult)) {
    throwInvalidUserFuncResult(LOAD);
  }
  return fromPromise(userResult);
}
function invokeUserTotalCountFunc(store, options2) {
  const userFunc = store._totalCountFunc;
  let userResult;
  if (!isFunction(userFunc)) {
    throw errors.Error("E4021");
  }
  userResult = userFunc.apply(store, [options2]);
  if (!isPromise2(userResult)) {
    userResult = Number(userResult);
    if (!isFinite(userResult)) {
      throwInvalidUserFuncResult(TOTAL_COUNT);
    }
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function invokeUserByKeyFunc(store, key, extraOptions) {
  const userFunc = store._byKeyFunc;
  let userResult;
  ensureRequiredFuncOption(BY_KEY, userFunc);
  userResult = userFunc.apply(store, [key, extraOptions]);
  if (!isPromise2(userResult)) {
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
  if (store.__rawData) {
    continuation(store.__rawData);
  } else {
    const loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);
    if (store._cacheRawData) {
      store.__rawDataPromise = loadPromise;
    }
    loadPromise.always(() => {
      delete store.__rawDataPromise;
    }).done((rawData) => {
      if (store._cacheRawData) {
        store.__rawData = rawData;
      }
      continuation(rawData);
    }).fail((error2) => {
      var _store$_errorHandler;
      const userFuncFailureHandler = createUserFuncFailureHandler(pendingDeferred);
      null === (_store$_errorHandler = store._errorHandler) || void 0 === _store$_errorHandler || _store$_errorHandler.call(store, error2);
      userFuncFailureHandler(error2);
    });
  }
}
function runRawLoadWithQuery(pendingDeferred, store, options2, countOnly) {
  options2 = options2 || {};
  const userFuncOptions = {};
  if ("userData" in options2) {
    userFuncOptions.userData = options2.userData;
  }
  runRawLoad(pendingDeferred, store, userFuncOptions, (rawData) => {
    const rawDataQuery = m_array_query_default(rawData, {
      errorHandler: store._errorHandler
    });
    let itemsQuery;
    let totalCountQuery;
    const waitList = [];
    let items;
    let totalCount;
    if (!countOnly) {
      itemsQuery = m_store_helper_default.queryByOptions(rawDataQuery, options2);
      if (itemsQuery === rawDataQuery) {
        items = rawData.slice(0);
      } else {
        waitList.push(itemsQuery.enumerate().done((asyncResult) => {
          items = asyncResult;
        }));
      }
    }
    if (options2.requireTotalCount || countOnly) {
      totalCountQuery = m_store_helper_default.queryByOptions(rawDataQuery, options2, true);
      if (totalCountQuery === rawDataQuery) {
        totalCount = rawData.length;
      } else {
        waitList.push(totalCountQuery.count().done((asyncResult) => {
          totalCount = asyncResult;
        }));
      }
    }
    when.apply(renderer_default, waitList).done(() => {
      if (countOnly) {
        pendingDeferred.resolve(totalCount);
      } else if (options2.requireTotalCount) {
        pendingDeferred.resolve(items, {
          totalCount
        });
      } else {
        pendingDeferred.resolve(items);
      }
    }).fail((x) => {
      pendingDeferred.reject(x);
    });
  });
}
function runRawLoadWithKey(pendingDeferred, store, key) {
  runRawLoad(pendingDeferred, store, {}, (rawData) => {
    const keyExpr = store.key();
    let item;
    for (let i = 0, len = rawData.length; i < len; i++) {
      item = rawData[i];
      if (keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {
        pendingDeferred.resolve(item);
        return;
      }
    }
    pendingDeferred.reject(errors.Error("E4009"));
  });
}
var CustomStore = m_abstract_store_default.inherit({
  ctor(options2) {
    options2 = options2 || {};
    this.callBase(options2);
    this._useDefaultSearch = !!options2.useDefaultSearch || "raw" === options2.loadMode;
    this._loadMode = options2.loadMode;
    this._cacheRawData = false !== options2.cacheRawData;
    this._loadFunc = options2[LOAD];
    this._totalCountFunc = options2[TOTAL_COUNT];
    this._byKeyFunc = options2[BY_KEY];
    this._insertFunc = options2[INSERT];
    this._updateFunc = options2[UPDATE];
    this._removeFunc = options2[REMOVE];
  },
  _clearCache() {
    delete this.__rawData;
  },
  createQuery() {
    throw errors.Error("E4010");
  },
  clearRawDataCache() {
    this._clearCache();
  },
  _totalCountImpl(options2) {
    let d = new Deferred();
    if ("raw" === this._loadMode && !this._totalCountFunc) {
      runRawLoadWithQuery(d, this, options2, true);
    } else {
      invokeUserTotalCountFunc(this, options2).done((count) => {
        d.resolve(Number(count));
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _pushImpl(changes) {
    if (this.__rawData) {
      applyBatch({
        keyInfo: this,
        data: this.__rawData,
        changes
      });
    }
  },
  _loadImpl(options2) {
    let d = new Deferred();
    if ("raw" === this._loadMode) {
      runRawLoadWithQuery(d, this, options2, false);
    } else {
      invokeUserLoad(this, options2).done((data2, extra) => {
        d.resolve(data2, extra);
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _byKeyImpl(key, extraOptions) {
    const d = new Deferred();
    if (this._byKeyViaLoad()) {
      this._requireKey();
      runRawLoadWithKey(d, this, key);
    } else {
      invokeUserByKeyFunc(this, key, extraOptions).done((obj) => {
        d.resolve(obj);
      }).fail(createUserFuncFailureHandler(d));
    }
    return d.promise();
  },
  _byKeyViaLoad() {
    return "raw" === this._loadMode && !this._byKeyFunc;
  },
  _insertImpl(values) {
    const that = this;
    const userFunc = that._insertFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(INSERT, userFunc);
    userResult = userFunc.apply(that, [values]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2(userResult);
    }
    fromPromise(userResult).done((serverResponse) => {
      if (config_default2().useLegacyStoreResult) {
        d.resolve(values, serverResponse);
      } else {
        d.resolve(serverResponse || values, that.keyOf(serverResponse));
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _updateImpl(key, values) {
    const userFunc = this._updateFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(UPDATE, userFunc);
    userResult = userFunc.apply(this, [key, values]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2(userResult);
    }
    fromPromise(userResult).done((serverResponse) => {
      if (config_default2().useLegacyStoreResult) {
        d.resolve(key, values);
      } else {
        d.resolve(serverResponse || values, key);
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _removeImpl(key) {
    const userFunc = this._removeFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(REMOVE, userFunc);
    userResult = userFunc.apply(this, [key]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2();
    }
    fromPromise(userResult).done(() => {
      d.resolve(key);
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  }
});
var m_custom_store_default = CustomStore;

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

// node_modules/devextreme/esm/common/data/query_adapters.js
var query_adapters_default = {};

// node_modules/devextreme/esm/__internal/data/m_remote_query.js
var remoteQueryImpl = function(url, queryOptions, tasks) {
  tasks = tasks || [];
  queryOptions = queryOptions || {};
  const createTask = function(name2, args) {
    return {
      name: name2,
      args
    };
  };
  const exec = function(executorTask) {
    const d = new Deferred();
    let _adapterFactory;
    let _adapter;
    let _taskQueue;
    let _currentTask;
    let _mergedSortArgs;
    const rejectWithNotify = function(error2) {
      const handler = queryOptions.errorHandler;
      if (handler) {
        handler(error2);
      }
      handleError(error2);
      d.reject(error2);
    };
    function mergeSortTask(task) {
      switch (task.name) {
        case "sortBy":
          _mergedSortArgs = [task.args];
          return true;
        case "thenBy":
          if (!_mergedSortArgs) {
            throw errors.Error("E4004");
          }
          _mergedSortArgs.push(task.args);
          return true;
      }
      return false;
    }
    try {
      _adapterFactory = queryOptions.adapter;
      if (!isFunction(_adapterFactory)) {
        _adapterFactory = query_adapters_default[_adapterFactory];
      }
      _adapter = _adapterFactory(queryOptions);
      _taskQueue = [].concat(tasks).concat(executorTask);
      const {
        optimize
      } = _adapter;
      if (optimize) {
        optimize(_taskQueue);
      }
      while (_taskQueue.length) {
        _currentTask = _taskQueue[0];
        if (!mergeSortTask(_currentTask)) {
          if (_mergedSortArgs) {
            _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
            _mergedSortArgs = null;
            continue;
          }
          if ("enumerate" !== String(_currentTask.name)) {
            if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
              break;
            }
          }
        }
        _taskQueue.shift();
      }
      !function() {
        const head = _taskQueue[0];
        const unmergedTasks = [];
        if (head && "multiSort" === head.name) {
          _taskQueue.shift();
          each(head.args[0], function() {
            unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this));
          });
        }
        _taskQueue = unmergedTasks.concat(_taskQueue);
      }();
      _adapter.exec(url).done((result2, extra) => {
        if (!_taskQueue.length) {
          d.resolve(result2, extra);
        } else {
          let clientChain = m_array_query_default(result2, {
            errorHandler: queryOptions.errorHandler
          });
          each(_taskQueue, function() {
            clientChain = clientChain[this.name].apply(clientChain, this.args);
          });
          clientChain.done(d.resolve).fail(d.reject);
        }
      }).fail(rejectWithNotify);
    } catch (x) {
      rejectWithNotify(x);
    }
    return d.promise();
  };
  const query2 = {};
  each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
    const name2 = String(this);
    query2[name2] = function() {
      return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name2, arguments)));
    };
  });
  each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
    const name2 = String(this);
    query2[name2] = function() {
      return exec.call(this, createTask(name2, arguments));
    };
  });
  return query2;
};
var m_remote_query_default = remoteQueryImpl;

// node_modules/devextreme/esm/common/data/query_implementation.js
var queryImpl = {
  array: m_array_query_default,
  remote: m_remote_query_default
};

// node_modules/devextreme/esm/__internal/data/m_query.js
var query = function() {
  const impl = Array.isArray(arguments[0]) ? "array" : "remote";
  return queryImpl[impl].apply(this, arguments);
};
var m_query_default = query;

// node_modules/devextreme/esm/__internal/data/m_array_store.js
var ArrayStore = m_abstract_store_default.inherit({
  ctor(options2) {
    if (Array.isArray(options2)) {
      options2 = {
        data: options2
      };
    } else {
      options2 = options2 || {};
    }
    this.callBase(options2);
    const initialArray = options2.data;
    if (initialArray && !Array.isArray(initialArray)) {
      throw errors.Error("E4006");
    }
    this._array = initialArray || [];
  },
  createQuery() {
    return m_query_default(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl(key) {
    const index2 = indexByKey(this, this._array, key);
    if (-1 === index2) {
      return rejectedPromise(errors.Error("E4009"));
    }
    return trivialPromise(this._array[index2]);
  },
  _insertImpl(values) {
    return insert(this, this._array, values);
  },
  _pushImpl(changes) {
    applyBatch({
      keyInfo: this,
      data: this._array,
      changes
    });
  },
  _updateImpl(key, values) {
    return update(this, this._array, key, values);
  },
  _removeImpl(key) {
    return remove(this, this._array, key);
  },
  clear() {
    this._eventsStrategy.fireEvent("modifying");
    this._array = [];
    this._eventsStrategy.fireEvent("modified");
  }
}, "array");
var m_array_store_default = ArrayStore;

// node_modules/devextreme/esm/__internal/core/m_http_request.js
var window13 = getWindow();
var nativeXMLHttpRequest = {
  getXhr: () => new window13.XMLHttpRequest()
};
var httpRequest = dependency_injector_default(nativeXMLHttpRequest);

// node_modules/devextreme/esm/core/http_request.js
var http_request_default = httpRequest;

// node_modules/devextreme/esm/__internal/core/utils/m_ajax_utils.js
var window14 = getWindow();
var createScript = function(options2) {
  const script = dom_adapter_default.createElement("script");
  for (const name2 in options2) {
    script[name2] = options2[name2];
  }
  return script;
};
var appendToHead = function(element) {
  return dom_adapter_default.getHead().appendChild(element);
};
var removeScript = function(scriptNode) {
  scriptNode.parentNode.removeChild(scriptNode);
};
var evalScript = function(code) {
  const script = createScript({
    text: code
  });
  appendToHead(script);
  removeScript(script);
};
var evalCrossDomainScript = function(url) {
  const script = createScript({
    src: url
  });
  return new Promise((resolve, reject) => {
    const events = {
      load: resolve,
      error: reject
    };
    const loadHandler = function(e) {
      events[e.type]();
      removeScript(script);
    };
    for (const event in events) {
      dom_adapter_default.listen(script, event, loadHandler);
    }
    appendToHead(script);
  });
};
function getMethod(options2) {
  return (options2.method || "GET").toUpperCase();
}
var paramsConvert = function(params) {
  const result2 = [];
  for (const name2 in params) {
    let value2 = params[name2];
    if (void 0 === value2) {
      continue;
    }
    if (null === value2) {
      value2 = "";
    }
    if ("function" === typeof value2) {
      value2 = value2();
    }
    result2.push(`${encodeURIComponent(name2)}=${encodeURIComponent(value2)}`);
  }
  return result2.join("&");
};
var getContentTypeHeader = function(options2) {
  let defaultContentType;
  if (options2.data && !options2.upload && "GET" !== getMethod(options2)) {
    defaultContentType = "application/x-www-form-urlencoded;charset=utf-8";
  }
  return options2.contentType || defaultContentType;
};
var getAcceptHeader = function(options2) {
  const dataType = options2.dataType || "*";
  const scriptAccept = "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript";
  const accepts = {
    "*": "*/*",
    text: "text/plain",
    html: "text/html",
    xml: "application/xml, text/xml",
    json: "application/json, text/javascript",
    jsonp: scriptAccept,
    script: scriptAccept
  };
  extendFromObject(accepts, options2.accepts, true);
  return accepts[dataType] ? accepts[dataType] + ("*" !== dataType ? ", */*; q=0.01" : "") : accepts["*"];
};
var getRequestHeaders = function(options2) {
  const headers = options2.headers || {};
  headers["Content-Type"] = headers["Content-Type"] || getContentTypeHeader(options2);
  headers.Accept = headers.Accept || getAcceptHeader(options2);
  if (!options2.crossDomain && !headers["X-Requested-With"]) {
    headers["X-Requested-With"] = "XMLHttpRequest";
  }
  return headers;
};
var getJsonpOptions = function(options2) {
  if ("jsonp" === options2.dataType) {
    const random = Math.random().toString().replace(/\D/g, "");
    const callbackName = options2.jsonpCallback || `dxCallback${Date.now()}_${random}`;
    const callbackParameter = options2.jsonp || "callback";
    options2.data = options2.data || {};
    options2.data[callbackParameter] = callbackName;
    return callbackName;
  }
};
var getRequestOptions = function(options2, headers) {
  let params = options2.data;
  const paramsAlreadyString = "string" === typeof params;
  let url = options2.url || window14.location.href;
  if (!paramsAlreadyString && !options2.cache) {
    params = params || {};
    params._ = Date.now();
  }
  if (params && !options2.upload) {
    if (!paramsAlreadyString) {
      params = paramsConvert(params);
    }
    if ("GET" === getMethod(options2)) {
      if ("" !== params) {
        url += (url.indexOf("?") > -1 ? "&" : "?") + params;
      }
      params = null;
    } else if (headers["Content-Type"] && headers["Content-Type"].indexOf("application/x-www-form-urlencoded") > -1) {
      params = params.replace(/%20/g, "+");
    }
  }
  return {
    url,
    parameters: params
  };
};
var isCrossDomain = function(url) {
  if (!hasWindow()) {
    return true;
  }
  let crossDomain = false;
  const originAnchor = dom_adapter_default.createElement("a");
  const urlAnchor = dom_adapter_default.createElement("a");
  originAnchor.href = window14.location.href;
  try {
    urlAnchor.href = url;
    urlAnchor.href = urlAnchor.href;
    crossDomain = `${originAnchor.protocol}//${originAnchor.host}` !== `${urlAnchor.protocol}//${urlAnchor.host}`;
  } catch (e) {
    crossDomain = true;
  }
  return crossDomain;
};

// node_modules/devextreme/esm/__internal/core/utils/m_ajax.js
var window15 = getWindow();
var SUCCESS = "success";
var ERROR = "error";
var TIMEOUT = "timeout";
var NO_CONTENT = "nocontent";
var PARSER_ERROR = "parsererror";
var isStatusSuccess = function(status) {
  return status >= 200 && status < 300;
};
var hasContent = function(status) {
  return 204 !== status;
};
var getDataFromResponse = function(xhr) {
  return xhr.responseType && "text" !== xhr.responseType || "string" !== typeof xhr.responseText ? xhr.response : xhr.responseText;
};
var postProcess = function(deferred, xhr, dataType) {
  const data2 = getDataFromResponse(xhr);
  switch (dataType) {
    case "jsonp":
      evalScript(data2);
      break;
    case "script":
      evalScript(data2);
      deferred.resolve(data2, SUCCESS, xhr);
      break;
    case "json":
      try {
        deferred.resolve(JSON.parse(data2), SUCCESS, xhr);
      } catch (e) {
        deferred.reject(xhr, PARSER_ERROR, e);
      }
      break;
    default:
      deferred.resolve(data2, SUCCESS, xhr);
  }
};
var setHttpTimeout = function(timeout, xhr) {
  return timeout && setTimeout(function() {
    xhr.customStatus = TIMEOUT;
    xhr.abort();
  }, timeout);
};
var sendRequest = function(options2) {
  const xhr = http_request_default.getXhr();
  const d = new Deferred();
  const result2 = d.promise();
  const async = isDefined(options2.async) ? options2.async : true;
  const {
    dataType
  } = options2;
  const timeout = options2.timeout || 0;
  let timeoutId;
  options2.crossDomain = isCrossDomain(options2.url);
  const needScriptEvaluation = "jsonp" === dataType || "script" === dataType;
  if (void 0 === options2.cache) {
    options2.cache = !needScriptEvaluation;
  }
  const callbackName = getJsonpOptions(options2);
  const headers = getRequestHeaders(options2);
  const requestOptions = getRequestOptions(options2, headers);
  const {
    url
  } = requestOptions;
  const {
    parameters
  } = requestOptions;
  if (callbackName) {
    window15[callbackName] = function(data2) {
      d.resolve(data2, SUCCESS, xhr);
    };
  }
  if (options2.crossDomain && needScriptEvaluation) {
    const reject = function() {
      d.reject(xhr, ERROR);
    };
    const resolve = function() {
      if ("jsonp" === dataType) {
        return;
      }
      d.resolve(null, SUCCESS, xhr);
    };
    evalCrossDomainScript(url).then(resolve, reject);
    return result2;
  }
  if (options2.crossDomain && !("withCredentials" in xhr)) {
    d.reject(xhr, ERROR);
    return result2;
  }
  xhr.open(getMethod(options2), url, async, options2.username, options2.password);
  if (async) {
    xhr.timeout = timeout;
    timeoutId = setHttpTimeout(timeout, xhr);
  }
  xhr.onreadystatechange = function(e) {
    if (4 === xhr.readyState) {
      clearTimeout(timeoutId);
      if (isStatusSuccess(xhr.status)) {
        if (hasContent(xhr.status)) {
          postProcess(d, xhr, dataType);
        } else {
          d.resolve(null, NO_CONTENT, xhr);
        }
      } else {
        d.reject(xhr, xhr.customStatus || ERROR);
      }
    }
  };
  if (options2.upload) {
    xhr.upload.onprogress = options2.upload.onprogress;
    xhr.upload.onloadstart = options2.upload.onloadstart;
    xhr.upload.onabort = options2.upload.onabort;
  }
  if (options2.xhrFields) {
    for (const field in options2.xhrFields) {
      xhr[field] = options2.xhrFields[field];
    }
  }
  if ("arraybuffer" === options2.responseType) {
    xhr.responseType = options2.responseType;
  }
  for (const name2 in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name2) && isDefined(headers[name2])) {
      xhr.setRequestHeader(name2, headers[name2]);
    }
  }
  if (options2.beforeSend) {
    options2.beforeSend(xhr);
  }
  xhr.send(parameters);
  result2.abort = function() {
    xhr.abort();
  };
  return result2;
};
var Ajax = dependency_injector_default({
  sendRequest
});

// node_modules/devextreme/esm/core/utils/ajax.js
var ajax_default = Ajax;

// node_modules/devextreme/esm/__internal/data/data_source/m_utils.js
var _excluded = ["items"];
var CANCELED_TOKEN = "canceled";
var isPending = (deferred) => "pending" === deferred.state();
var normalizeStoreLoadOptionAccessorArguments = (originalArguments) => {
  switch (originalArguments.length) {
    case 0:
      return;
    case 1:
      return originalArguments[0];
  }
  return [].slice.call(originalArguments);
};
var mapGroup = (group, level, mapper) => map(group, (item) => {
  const restItem = _objectWithoutPropertiesLoose(item, _excluded);
  return _extends({}, restItem, {
    items: mapRecursive(item.items, level - 1, mapper)
  });
});
var mapRecursive = (items, level, mapper) => {
  if (!Array.isArray(items)) {
    return items;
  }
  return level ? mapGroup(items, level, mapper) : map(items, mapper);
};
var mapDataRespectingGrouping = (items, mapper, groupInfo) => {
  const level = groupInfo ? normalizeSortingInfo(groupInfo).length : 0;
  return mapRecursive(items, level, mapper);
};
var normalizeLoadResult = (data2, extra) => {
  var _data;
  if (null !== (_data = data2) && void 0 !== _data && _data.data) {
    extra = data2;
    data2 = data2.data;
  }
  if (!Array.isArray(data2)) {
    data2 = [data2];
  }
  return {
    data: data2,
    extra
  };
};
var createCustomStoreFromLoadFunc = (options2) => {
  const storeConfig = {};
  each(["useDefaultSearch", "key", "load", "loadMode", "cacheRawData", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
    storeConfig[this] = options2[this];
    delete options2[this];
  });
  return new m_custom_store_default(storeConfig);
};
var createStoreFromConfig = (storeConfig) => {
  const alias = storeConfig.type;
  delete storeConfig.type;
  return m_abstract_store_default.create(alias, storeConfig);
};
var createCustomStoreFromUrl = (url, normalizationOptions) => new m_custom_store_default({
  load: () => ajax_default.sendRequest({
    url,
    dataType: "json"
  }),
  loadMode: null === normalizationOptions || void 0 === normalizationOptions ? void 0 : normalizationOptions.fromUrlLoadMode
});
var normalizeDataSourceOptions = (options2, normalizationOptions) => {
  let store;
  if ("string" === typeof options2) {
    options2 = {
      paginate: false,
      store: createCustomStoreFromUrl(options2, normalizationOptions)
    };
  }
  if (void 0 === options2) {
    options2 = [];
  }
  if (Array.isArray(options2) || options2 instanceof m_abstract_store_default) {
    options2 = {
      store: options2
    };
  } else {
    options2 = extend({}, options2);
  }
  if (void 0 === options2.store) {
    options2.store = [];
  }
  store = options2.store;
  if ("load" in options2) {
    store = createCustomStoreFromLoadFunc(options2);
  } else if (Array.isArray(store)) {
    store = new m_array_store_default(store);
  } else if (isPlainObject(store)) {
    store = createStoreFromConfig(extend({}, store));
  }
  options2.store = store;
  return options2;
};

// node_modules/devextreme/esm/__internal/data/data_source/m_operation_manager.js
var OperationManager = class {
  constructor() {
    this._counter = -1;
    this._deferreds = {};
  }
  add(deferred) {
    this._counter++;
    this._deferreds[this._counter] = deferred;
    return this._counter;
  }
  remove(operationId) {
    return delete this._deferreds[operationId];
  }
  cancel(operationId) {
    if (operationId in this._deferreds) {
      this._deferreds[operationId].reject(CANCELED_TOKEN);
      return true;
    }
    return false;
  }
  cancelAll() {
    while (this._counter > -1) {
      this.cancel(this._counter);
      this._counter--;
    }
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_queue.js
function createQueue2(discardPendingTasks) {
  let _tasks = [];
  let _busy = false;
  function exec() {
    while (_tasks.length) {
      _busy = true;
      const task = _tasks.shift();
      const result2 = task();
      if (void 0 === result2) {
        continue;
      }
      if (result2.then) {
        when(result2).always(exec);
        return;
      }
      throw errors_default.Error("E0015");
    }
    _busy = false;
  }
  return {
    add: function(task, removeTaskCallback) {
      if (!discardPendingTasks) {
        _tasks.push(task);
      } else {
        if (_tasks[0] && removeTaskCallback) {
          removeTaskCallback(_tasks[0]);
        }
        _tasks = [task];
      }
      if (!_busy) {
        exec();
      }
    },
    busy: function() {
      return _busy;
    }
  };
}
var enqueue = createQueue2().add;

// node_modules/devextreme/esm/__internal/data/data_source/m_data_source.js
var DataSource = class_default.inherit({
  ctor(options2) {
    options2 = normalizeDataSourceOptions(options2);
    this._eventsStrategy = new EventsStrategy(this, {
      syncStrategy: true
    });
    this._store = options2.store;
    this._changedTime = 0;
    const needThrottling = 0 !== options2.pushAggregationTimeout;
    if (needThrottling) {
      const throttlingTimeout = void 0 === options2.pushAggregationTimeout ? () => 5 * this._changedTime : options2.pushAggregationTimeout;
      let pushDeferred;
      let lastPushWaiters;
      const throttlingPushHandler = throttleChanges((changes) => {
        pushDeferred.resolve();
        const storePushPending = when(...lastPushWaiters);
        storePushPending.done(() => this._onPush(changes));
        lastPushWaiters = void 0;
        pushDeferred = void 0;
      }, throttlingTimeout);
      this._onPushHandler = (args) => {
        this._aggregationTimeoutId = throttlingPushHandler(args.changes);
        if (!pushDeferred) {
          pushDeferred = new Deferred();
        }
        lastPushWaiters = args.waitFor;
        args.waitFor.push(pushDeferred.promise());
      };
      this._store.on("beforePushAggregation", this._onPushHandler);
    } else {
      this._onPushHandler = (changes) => this._onPush(changes);
      this._store.on("push", this._onPushHandler);
    }
    this._storeLoadOptions = this._extractLoadOptions(options2);
    this._mapFunc = options2.map;
    this._postProcessFunc = options2.postProcess;
    this._pageIndex = void 0 !== options2.pageIndex ? options2.pageIndex : 0;
    this._pageSize = void 0 !== options2.pageSize ? options2.pageSize : 20;
    this._loadingCount = 0;
    this._loadQueue = this._createLoadQueue();
    this._searchValue = "searchValue" in options2 ? options2.searchValue : null;
    this._searchOperation = options2.searchOperation || "contains";
    this._searchExpr = options2.searchExpr;
    this._paginate = options2.paginate;
    this._reshapeOnPush = options2.reshapeOnPush ?? false;
    each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], (_, optionName) => {
      if (optionName in options2) {
        this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options2[optionName]);
      }
    });
    this._operationManager = new OperationManager();
    this._init();
  },
  _init() {
    this._items = [];
    this._userData = {};
    this._totalCount = -1;
    this._isLoaded = false;
    if (!isDefined(this._paginate)) {
      this._paginate = !this.group();
    }
    this._isLastPage = !this._paginate;
  },
  dispose() {
    var _this$_delayedLoadTas;
    this._store.off("beforePushAggregation", this._onPushHandler);
    this._store.off("push", this._onPushHandler);
    this._eventsStrategy.dispose();
    clearTimeout(this._aggregationTimeoutId);
    null === (_this$_delayedLoadTas = this._delayedLoadTask) || void 0 === _this$_delayedLoadTas || _this$_delayedLoadTas.abort();
    this._operationManager.cancelAll();
    delete this._store;
    delete this._items;
    delete this._delayedLoadTask;
    this._disposed = true;
  },
  _extractLoadOptions(options2) {
    const result2 = {};
    let names = ["sort", "filter", "langParams", "select", "group", "requireTotalCount"];
    const customNames = this._store._customLoadOptions();
    if (customNames) {
      names = names.concat(customNames);
    }
    each(names, function() {
      result2[this] = options2[this];
    });
    return result2;
  },
  loadOptions() {
    return this._storeLoadOptions;
  },
  items() {
    return this._items;
  },
  pageIndex(newIndex) {
    if (!isNumeric(newIndex)) {
      return this._pageIndex;
    }
    this._pageIndex = newIndex;
    this._isLastPage = !this._paginate;
  },
  paginate(value2) {
    if (!isBoolean(value2)) {
      return this._paginate;
    }
    if (this._paginate !== value2) {
      this._paginate = value2;
      this.pageIndex(0);
    }
  },
  pageSize(value2) {
    if (!isNumeric(value2)) {
      return this._pageSize;
    }
    this._pageSize = value2;
  },
  isLastPage() {
    return this._isLastPage;
  },
  generateStoreLoadOptionAccessor(optionName) {
    return (args) => {
      const normalizedArgs = normalizeStoreLoadOptionAccessorArguments(args);
      if (void 0 === normalizedArgs) {
        return this._storeLoadOptions[optionName];
      }
      this._storeLoadOptions[optionName] = normalizedArgs;
    };
  },
  sort() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.generateStoreLoadOptionAccessor("sort")(args);
  },
  filter() {
    const newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
    if (void 0 === newFilter) {
      return this._storeLoadOptions.filter;
    }
    this._storeLoadOptions.filter = newFilter;
    this.pageIndex(0);
  },
  group() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.generateStoreLoadOptionAccessor("group")(args);
  },
  select() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.generateStoreLoadOptionAccessor("select")(args);
  },
  requireTotalCount(value2) {
    if (!isBoolean(value2)) {
      return this._storeLoadOptions.requireTotalCount;
    }
    this._storeLoadOptions.requireTotalCount = value2;
  },
  searchValue(value2) {
    if (arguments.length < 1) {
      return this._searchValue;
    }
    this._searchValue = value2;
    this.pageIndex(0);
  },
  searchOperation(op) {
    if (!isString(op)) {
      return this._searchOperation;
    }
    this._searchOperation = op;
    this.pageIndex(0);
  },
  searchExpr(expr) {
    const argc = arguments.length;
    if (0 === argc) {
      return this._searchExpr;
    }
    if (argc > 1) {
      expr = [].slice.call(arguments);
    }
    this._searchExpr = expr;
    this.pageIndex(0);
  },
  store() {
    return this._store;
  },
  key() {
    var _this$_store;
    return null === (_this$_store = this._store) || void 0 === _this$_store ? void 0 : _this$_store.key();
  },
  totalCount() {
    return this._totalCount;
  },
  isLoaded() {
    return this._isLoaded;
  },
  isLoading() {
    return this._loadingCount > 0;
  },
  beginLoading() {
    this._changeLoadingCount(1);
  },
  endLoading() {
    this._changeLoadingCount(-1);
  },
  _createLoadQueue: () => createQueue2(),
  _changeLoadingCount(increment) {
    const oldLoading = this.isLoading();
    this._loadingCount += increment;
    const newLoading = this.isLoading();
    if (oldLoading ^ newLoading) {
      this._eventsStrategy.fireEvent("loadingChanged", [newLoading]);
    }
  },
  _scheduleLoadCallbacks(deferred) {
    this.beginLoading();
    deferred.always(() => {
      this.endLoading();
    });
  },
  _scheduleFailCallbacks(deferred) {
    var _this = this;
    deferred.fail(function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      if (args[0] === CANCELED_TOKEN) {
        return;
      }
      _this._eventsStrategy.fireEvent("loadError", args);
    });
  },
  _fireChanged(args) {
    const date = /* @__PURE__ */ new Date();
    this._eventsStrategy.fireEvent("changed", args);
    this._changedTime = /* @__PURE__ */ new Date() - date;
  },
  _scheduleChangedCallbacks(deferred) {
    deferred.done(() => this._fireChanged());
  },
  loadSingle(propName, propValue) {
    const d = new Deferred();
    const key = this.key();
    const store = this._store;
    const options2 = this._createStoreLoadOptions();
    this._scheduleFailCallbacks(d);
    if (arguments.length < 2) {
      propValue = propName;
      propName = key;
    }
    delete options2.skip;
    delete options2.group;
    delete options2.refresh;
    delete options2.pageIndex;
    delete options2.searchString;
    (() => {
      if (propName === key || store instanceof m_custom_store_default && !store._byKeyViaLoad()) {
        return store.byKey(propValue, options2);
      }
      options2.take = 1;
      options2.filter = options2.filter ? [options2.filter, [propName, propValue]] : [propName, propValue];
      return store.load(options2);
    })().fail(d.reject).done((data2) => {
      const isEmptyArray = Array.isArray(data2) && !data2.length;
      if (!isDefined(data2) || isEmptyArray) {
        d.reject(errors.Error("E4009"));
      } else {
        if (!Array.isArray(data2)) {
          data2 = [data2];
        }
        d.resolve(this._applyMapFunction(data2)[0]);
      }
    });
    return d.promise();
  },
  load() {
    const d = new Deferred();
    const loadTask = () => {
      if (this._disposed) {
        return;
      }
      if (!isPending(d)) {
        return;
      }
      return this._loadFromStore(loadOperation, d);
    };
    this._scheduleLoadCallbacks(d);
    this._scheduleFailCallbacks(d);
    this._scheduleChangedCallbacks(d);
    const loadOperation = this._createLoadOperation(d);
    this._eventsStrategy.fireEvent("customizeStoreLoadOptions", [loadOperation]);
    this._loadQueue.add(() => {
      if ("number" === typeof loadOperation.delay) {
        this._delayedLoadTask = m_common_default.executeAsync(loadTask, loadOperation.delay);
      } else {
        loadTask();
      }
      return d.promise();
    });
    return d.promise({
      operationId: loadOperation.operationId
    });
  },
  _onPush(changes) {
    if (this._reshapeOnPush) {
      this.load();
    } else {
      const changingArgs = {
        changes
      };
      this._eventsStrategy.fireEvent("changing", [changingArgs]);
      const group = this.group();
      const items = this.items();
      let groupLevel = 0;
      let dataSourceChanges = this.paginate() || group ? changes.filter((item) => "update" === item.type) : changes;
      if (group) {
        groupLevel = Array.isArray(group) ? group.length : 1;
      }
      if (this._mapFunc) {
        dataSourceChanges.forEach((item) => {
          if ("insert" === item.type) {
            item.data = this._mapFunc(item.data);
          }
        });
      }
      if (changingArgs.postProcessChanges) {
        dataSourceChanges = changingArgs.postProcessChanges(dataSourceChanges);
      }
      applyBatch({
        keyInfo: this.store(),
        data: items,
        changes: dataSourceChanges,
        groupCount: groupLevel,
        useInsertIndex: true
      });
      this._fireChanged([{
        changes
      }]);
    }
  },
  _createLoadOperation(deferred) {
    const operationId = this._operationManager.add(deferred);
    const storeLoadOptions = this._createStoreLoadOptions();
    if (this._store && !isEmptyObject(null === storeLoadOptions || void 0 === storeLoadOptions ? void 0 : storeLoadOptions.langParams)) {
      this._store._langParams = _extends({}, this._store._langParams, storeLoadOptions.langParams);
    }
    deferred.always(() => this._operationManager.remove(operationId));
    return {
      operationId,
      storeLoadOptions
    };
  },
  reload() {
    const store = this.store();
    store._clearCache();
    this._init();
    return this.load();
  },
  cancel(operationId) {
    return this._operationManager.cancel(operationId);
  },
  cancelAll() {
    return this._operationManager.cancelAll();
  },
  _addSearchOptions(storeLoadOptions) {
    if (this._disposed) {
      return;
    }
    if (this.store()._useDefaultSearch) {
      this._addSearchFilter(storeLoadOptions);
    } else {
      storeLoadOptions.searchOperation = this._searchOperation;
      storeLoadOptions.searchValue = this._searchValue;
      storeLoadOptions.searchExpr = this._searchExpr;
    }
  },
  _createStoreLoadOptions() {
    const result2 = extend({}, this._storeLoadOptions);
    this._addSearchOptions(result2);
    if (this._paginate) {
      if (this._pageSize) {
        result2.skip = this._pageIndex * this._pageSize;
        result2.take = this._pageSize;
      }
    }
    result2.userData = this._userData;
    return result2;
  },
  _addSearchFilter(storeLoadOptions) {
    const value2 = this._searchValue;
    const op = this._searchOperation;
    let selector = this._searchExpr;
    const searchFilter = [];
    if (!value2) {
      return;
    }
    if (!selector) {
      selector = "this";
    }
    if (!Array.isArray(selector)) {
      selector = [selector];
    }
    each(selector, (i, item) => {
      if (searchFilter.length) {
        searchFilter.push("or");
      }
      searchFilter.push([item, op, value2]);
    });
    if (storeLoadOptions.filter) {
      storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
    } else {
      storeLoadOptions.filter = searchFilter;
    }
  },
  _loadFromStore(loadOptions, pendingDeferred) {
    const handleSuccess = (data2, extra) => {
      if (this._disposed) {
        return;
      }
      if (!isPending(pendingDeferred)) {
        return;
      }
      const loadResult = extend(normalizeLoadResult(data2, extra), loadOptions);
      this._eventsStrategy.fireEvent("customizeLoadResult", [loadResult]);
      when(loadResult.data).done((data3) => {
        loadResult.data = data3;
        this._processStoreLoadResult(loadResult, pendingDeferred);
      }).fail(pendingDeferred.reject);
    };
    if (loadOptions.data) {
      return new Deferred().resolve(loadOptions.data).done(handleSuccess);
    }
    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject);
  },
  _processStoreLoadResult(loadResult, pendingDeferred) {
    let {
      data: data2
    } = loadResult;
    let {
      extra
    } = loadResult;
    const {
      storeLoadOptions
    } = loadResult;
    const resolvePendingDeferred = () => {
      this._isLoaded = true;
      this._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
      return pendingDeferred.resolve(data2, extra);
    };
    const proceedLoadingTotalCount = () => {
      this.store().totalCount(storeLoadOptions).done((count) => {
        extra.totalCount = count;
        resolvePendingDeferred();
      }).fail(pendingDeferred.reject);
    };
    if (this._disposed) {
      return;
    }
    data2 = this._applyPostProcessFunction(this._applyMapFunction(data2));
    if (!isObject(extra)) {
      extra = {};
    }
    this._items = data2;
    if (!data2.length || !this._paginate || this._pageSize && data2.length < this._pageSize) {
      this._isLastPage = true;
    }
    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
      proceedLoadingTotalCount();
    } else {
      resolvePendingDeferred();
    }
  },
  _applyMapFunction(data2) {
    if (this._mapFunc) {
      return mapDataRespectingGrouping(data2, this._mapFunc, this.group());
    }
    return data2;
  },
  _applyPostProcessFunction(data2) {
    if (this._postProcessFunc) {
      return this._postProcessFunc(data2);
    }
    return data2;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});

// node_modules/devextreme/esm/__internal/events/core/m_emitter.js
var Emitter = class_default.inherit({
  ctor(element) {
    this._$element = renderer_default(element);
    this._cancelCallback = callbacks_default();
    this._acceptCallback = callbacks_default();
  },
  getElement() {
    return this._$element;
  },
  validate: (e) => !isDxMouseWheelEvent(e),
  validatePointers: (e) => 1 === hasTouches(e),
  allowInterruptionByMouseWheel: () => true,
  configure(data2) {
    extend(this, data2);
  },
  addCancelCallback(callback) {
    this._cancelCallback.add(callback);
  },
  removeCancelCallback() {
    this._cancelCallback.empty();
  },
  _cancel(e) {
    this._cancelCallback.fire(this, e);
  },
  addAcceptCallback(callback) {
    this._acceptCallback.add(callback);
  },
  removeAcceptCallback() {
    this._acceptCallback.empty();
  },
  _accept(e) {
    this._acceptCallback.fire(this, e);
  },
  _requestAccept(e) {
    this._acceptRequestEvent = e;
  },
  _forgetAccept() {
    this._accept(this._acceptRequestEvent);
    this._acceptRequestEvent = null;
  },
  start: noop2,
  move: noop2,
  end: noop2,
  cancel: noop2,
  reset() {
    if (this._acceptRequestEvent) {
      this._accept(this._acceptRequestEvent);
    }
  },
  _fireEvent(eventName, e, params) {
    const eventData2 = extend({
      type: eventName,
      originalEvent: e,
      target: this._getEmitterTarget(e),
      delegateTarget: this.getElement().get(0)
    }, params);
    e = fireEvent(eventData2);
    if (e.cancel) {
      this._cancel(e);
    }
    return e;
  },
  _getEmitterTarget(e) {
    return (this.delegateSelector ? renderer_default(e.target).closest(this.delegateSelector) : this.getElement()).get(0);
  },
  dispose: noop2
});
var m_emitter_default = Emitter;

// node_modules/devextreme/esm/__internal/events/core/m_wheel.js
var EVENT_NAME = "dxmousewheel";
var wheel = {
  setup(element) {
    const $element = renderer_default(element);
    m_events_engine_default.on($element, addNamespace2("wheel", "dxWheel"), wheel._wheelHandler.bind(wheel));
  },
  teardown(element) {
    m_events_engine_default.off(element, ".dxWheel");
  },
  _wheelHandler(e) {
    const {
      deltaMode,
      deltaY,
      deltaX,
      deltaZ
    } = e.originalEvent;
    fireEvent({
      type: EVENT_NAME,
      originalEvent: e,
      delta: this._normalizeDelta(deltaY, deltaMode),
      deltaX,
      deltaY,
      deltaZ,
      deltaMode,
      pointerType: "mouse"
    });
    e.stopPropagation();
  },
  _normalizeDelta(delta) {
    let deltaMode = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (0 === deltaMode) {
      return -delta;
    }
    return -30 * delta;
  }
};
m_event_registrator_default(EVENT_NAME, wheel);

// node_modules/devextreme/esm/__internal/events/pointer/m_base.js
var BaseStrategy = class_default.inherit({
  ctor(eventName, originalEvents) {
    this._eventName = eventName;
    this._originalEvents = addNamespace2(originalEvents, "dxPointerEvents");
    this._handlerCount = 0;
    this.noBubble = this._isNoBubble();
  },
  _isNoBubble() {
    const eventName = this._eventName;
    return "dxpointerenter" === eventName || "dxpointerleave" === eventName;
  },
  _handler(e) {
    const delegateTarget = this._getDelegateTarget(e);
    const event = {
      type: this._eventName,
      pointerType: e.pointerType || eventSource(e),
      originalEvent: e,
      delegateTarget,
      timeStamp: browser_default.mozilla ? (/* @__PURE__ */ new Date()).getTime() : e.timeStamp
    };
    const target = getEventTarget(e);
    event.target = target;
    return this._fireEvent(event);
  },
  _getDelegateTarget(e) {
    let delegateTarget;
    if (this.noBubble) {
      delegateTarget = e.delegateTarget;
    }
    return delegateTarget;
  },
  _fireEvent: (args) => fireEvent(args),
  _setSelector(handleObj) {
    this._selector = this.noBubble && handleObj ? handleObj.selector : null;
  },
  _getSelector() {
    return this._selector;
  },
  setup: () => true,
  add(element, handleObj) {
    if (this._handlerCount <= 0 || this.noBubble) {
      element = this.noBubble ? element : dom_adapter_default.getDocument();
      this._setSelector(handleObj);
      const that = this;
      m_events_engine_default.on(element, this._originalEvents, this._getSelector(), (e) => {
        that._handler(e);
      });
    }
    if (!this.noBubble) {
      this._handlerCount++;
    }
  },
  remove(handleObj) {
    this._setSelector(handleObj);
    if (!this.noBubble) {
      this._handlerCount--;
    }
  },
  teardown(element) {
    if (this._handlerCount && !this.noBubble) {
      return;
    }
    element = this.noBubble ? element : dom_adapter_default.getDocument();
    if (".dxPointerEvents" !== this._originalEvents) {
      m_events_engine_default.off(element, this._originalEvents, this._getSelector());
    }
  },
  dispose(element) {
    element = this.noBubble ? element : dom_adapter_default.getDocument();
    m_events_engine_default.off(element, this._originalEvents);
  }
});
var m_base_default = BaseStrategy;

// node_modules/devextreme/esm/__internal/events/pointer/m_observer.js
var addEventsListener = function(events, handler) {
  ready_callbacks_default.add(() => {
    events.split(" ").forEach((event) => {
      dom_adapter_default.listen(dom_adapter_default.getDocument(), event, handler, true);
    });
  });
};
var Observer = function(eventMap4, pointerEquals, onPointerAdding) {
  onPointerAdding = onPointerAdding || function() {
  };
  let pointers = [];
  const getPointerIndex = function(e) {
    let index2 = -1;
    each(pointers, (i, pointer2) => {
      if (!pointerEquals(e, pointer2)) {
        return true;
      }
      index2 = i;
      return false;
    });
    return index2;
  };
  const removePointer = function(e) {
    const index2 = getPointerIndex(e);
    if (index2 > -1) {
      pointers.splice(index2, 1);
    }
  };
  addEventsListener(eventMap4.dxpointerdown, function(e) {
    if (-1 === getPointerIndex(e)) {
      onPointerAdding(e);
      pointers.push(e);
    }
  });
  addEventsListener(eventMap4.dxpointermove, function(e) {
    pointers[getPointerIndex(e)] = e;
  });
  addEventsListener(eventMap4.dxpointerup, removePointer);
  addEventsListener(eventMap4.dxpointercancel, removePointer);
  this.pointers = function() {
    return pointers;
  };
  this.reset = function() {
    pointers = [];
  };
};
var m_observer_default = Observer;

// node_modules/devextreme/esm/__internal/events/pointer/m_mouse.js
var eventMap = {
  dxpointerdown: "mousedown",
  dxpointermove: "mousemove",
  dxpointerup: "mouseup",
  dxpointercancel: "pointercancel",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
if (browser_default.safari) {
  eventMap.dxpointercancel += " dragstart";
}
var normalizeMouseEvent = function(e) {
  e.pointerId = 1;
  return {
    pointers: observer.pointers(),
    pointerId: 1
  };
};
var observer;
var activated = false;
var activateStrategy = function() {
  if (activated) {
    return;
  }
  observer = new m_observer_default(eventMap, () => true);
  activated = true;
};
var MouseStrategy = m_base_default.inherit({
  ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _fireEvent(args) {
    return this.callBase(extend(normalizeMouseEvent(args.originalEvent), args));
  }
});
MouseStrategy.map = eventMap;
MouseStrategy.normalize = normalizeMouseEvent;
MouseStrategy.activate = activateStrategy;
MouseStrategy.resetObserver = function() {
  observer.reset();
};
var m_mouse_default = MouseStrategy;

// node_modules/devextreme/esm/__internal/events/pointer/m_touch.js
var eventMap2 = {
  dxpointerdown: "touchstart",
  dxpointermove: "touchmove",
  dxpointerup: "touchend",
  dxpointercancel: "touchcancel",
  dxpointerover: "",
  dxpointerout: "",
  dxpointerenter: "",
  dxpointerleave: ""
};
var normalizeTouchEvent = function(e) {
  const pointers = [];
  each(e.touches, (_, touch2) => {
    pointers.push(extend({
      pointerId: touch2.identifier
    }, touch2));
  });
  return {
    pointers,
    pointerId: e.changedTouches[0].identifier
  };
};
var skipTouchWithSameIdentifier = function(pointerEvent) {
  return "ios" === m_devices_default.real().platform && ("dxpointerdown" === pointerEvent || "dxpointerup" === pointerEvent);
};
var TouchStrategy = m_base_default.inherit({
  ctor() {
    this.callBase.apply(this, arguments);
    this._pointerId = 0;
  },
  _handler(e) {
    if (skipTouchWithSameIdentifier(this._eventName)) {
      const touch2 = e.changedTouches[0];
      if (this._pointerId === touch2.identifier && 0 !== this._pointerId) {
        return;
      }
      this._pointerId = touch2.identifier;
    }
    return this.callBase.apply(this, arguments);
  },
  _fireEvent(args) {
    return this.callBase(extend(normalizeTouchEvent(args.originalEvent), args));
  }
});
TouchStrategy.map = eventMap2;
TouchStrategy.normalize = normalizeTouchEvent;
var m_touch_default = TouchStrategy;

// node_modules/devextreme/esm/__internal/events/pointer/m_mouse_and_touch.js
var eventMap3 = {
  dxpointerdown: "touchstart mousedown",
  dxpointermove: "touchmove mousemove",
  dxpointerup: "touchend mouseup",
  dxpointercancel: "touchcancel",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
var activated2 = false;
var activateStrategy2 = function() {
  if (activated2) {
    return;
  }
  m_mouse_default.activate();
  activated2 = true;
};
var MouseAndTouchStrategy = m_base_default.inherit({
  EVENT_LOCK_TIMEOUT: 100,
  ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy2();
  },
  _handler(e) {
    const isMouse = isMouseEvent(e);
    if (!isMouse) {
      this._skipNextEvents = true;
    }
    if (isMouse && this._mouseLocked) {
      return;
    }
    if (isMouse && this._skipNextEvents) {
      this._skipNextEvents = false;
      this._mouseLocked = true;
      clearTimeout(this._unlockMouseTimer);
      const that = this;
      this._unlockMouseTimer = setTimeout(() => {
        that._mouseLocked = false;
      }, this.EVENT_LOCK_TIMEOUT);
      return;
    }
    return this.callBase(e);
  },
  _fireEvent(args) {
    const normalizer = isMouseEvent(args.originalEvent) ? m_mouse_default.normalize : m_touch_default.normalize;
    return this.callBase(extend(normalizer(args.originalEvent), args));
  },
  dispose() {
    this.callBase();
    this._skipNextEvents = false;
    this._mouseLocked = false;
    clearTimeout(this._unlockMouseTimer);
  }
});
MouseAndTouchStrategy.map = eventMap3;
MouseAndTouchStrategy.resetObserver = m_mouse_default.resetObserver;
var m_mouse_and_touch_default = MouseAndTouchStrategy;

// node_modules/devextreme/esm/__internal/events/m_pointer.js
var getStrategy = (support, _ref) => {
  let {
    tablet,
    phone
  } = _ref;
  const pointerEventStrategy = getStrategyFromGlobalConfig();
  if (pointerEventStrategy) {
    return pointerEventStrategy;
  }
  if (support.touch && !(tablet || phone)) {
    return m_mouse_and_touch_default;
  }
  if (support.touch) {
    return m_touch_default;
  }
  return m_mouse_default;
};
var EventStrategy = getStrategy(m_support_default, m_devices_default.real());
each(EventStrategy.map, (pointerEvent, originalEvents) => {
  m_event_registrator_default(pointerEvent, new EventStrategy(pointerEvent, originalEvents));
});
var pointer = {
  down: "dxpointerdown",
  up: "dxpointerup",
  move: "dxpointermove",
  cancel: "dxpointercancel",
  enter: "dxpointerenter",
  leave: "dxpointerleave",
  over: "dxpointerover",
  out: "dxpointerout"
};
function getStrategyFromGlobalConfig() {
  const eventStrategyName = config_default2().pointerEventStrategy;
  return {
    "mouse-and-touch": m_mouse_and_touch_default,
    touch: m_touch_default,
    mouse: m_mouse_default
  }[eventStrategyName];
}
var m_pointer_default = pointer;

// node_modules/devextreme/esm/__internal/events/core/m_emitter_registrator.js
var MANAGER_EVENT = "dxEventManager";
var EventManager = class_default.inherit({
  ctor() {
    this._attachHandlers();
    this.reset();
    this._proxiedCancelHandler = this._cancelHandler.bind(this);
    this._proxiedAcceptHandler = this._acceptHandler.bind(this);
  },
  _attachHandlers() {
    ready_callbacks_default.add(() => {
      const document2 = dom_adapter_default.getDocument();
      m_events_engine_default.subscribeGlobal(document2, addNamespace2(m_pointer_default.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
      m_events_engine_default.subscribeGlobal(document2, addNamespace2(m_pointer_default.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
      m_events_engine_default.subscribeGlobal(document2, addNamespace2([m_pointer_default.up, m_pointer_default.cancel].join(" "), MANAGER_EVENT), this._pointerUpHandler.bind(this));
      m_events_engine_default.subscribeGlobal(document2, addNamespace2(EVENT_NAME, MANAGER_EVENT), this._mouseWheelHandler.bind(this));
    });
  },
  _eachEmitter(callback) {
    const activeEmitters = this._activeEmitters || [];
    let i = 0;
    while (activeEmitters.length > i) {
      const emitter = activeEmitters[i];
      if (false === callback(emitter)) {
        break;
      }
      if (activeEmitters[i] === emitter) {
        i++;
      }
    }
  },
  _applyToEmitters(method, arg) {
    this._eachEmitter((emitter) => {
      emitter[method].call(emitter, arg);
    });
  },
  reset() {
    this._eachEmitter(this._proxiedCancelHandler);
    this._activeEmitters = [];
  },
  resetEmitter(emitter) {
    this._proxiedCancelHandler(emitter);
  },
  _pointerDownHandler(e) {
    if (isMouseEvent(e) && e.which > 1) {
      return;
    }
    this._updateEmitters(e);
  },
  _updateEmitters(e) {
    if (!this._isSetChanged(e)) {
      return;
    }
    this._cleanEmitters(e);
    this._fetchEmitters(e);
  },
  _isSetChanged(e) {
    const currentSet = this._closestEmitter(e);
    const previousSet = this._emittersSet || [];
    let setChanged = currentSet.length !== previousSet.length;
    each(currentSet, (index2, emitter) => {
      setChanged = setChanged || previousSet[index2] !== emitter;
      return !setChanged;
    });
    this._emittersSet = currentSet;
    return setChanged;
  },
  _closestEmitter(e) {
    const that = this;
    const result2 = [];
    let $element = renderer_default(e.target);
    function handleEmitter(_, emitter) {
      if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
        emitter.addCancelCallback(that._proxiedCancelHandler);
        emitter.addAcceptCallback(that._proxiedAcceptHandler);
        result2.push(emitter);
      }
    }
    while ($element.length) {
      const emitters = data($element.get(0), "dxEmitter") || [];
      each(emitters, handleEmitter);
      $element = $element.parent();
    }
    return result2;
  },
  _acceptHandler(acceptedEmitter, e) {
    this._eachEmitter((emitter) => {
      if (emitter !== acceptedEmitter) {
        this._cancelEmitter(emitter, e);
      }
    });
  },
  _cancelHandler(canceledEmitter, e) {
    this._cancelEmitter(canceledEmitter, e);
  },
  _cancelEmitter(emitter, e) {
    const activeEmitters = this._activeEmitters;
    if (e) {
      emitter.cancel(e);
    } else {
      emitter.reset();
    }
    emitter.removeCancelCallback();
    emitter.removeAcceptCallback();
    const emitterIndex = activeEmitters.indexOf(emitter);
    if (emitterIndex > -1) {
      activeEmitters.splice(emitterIndex, 1);
    }
  },
  _cleanEmitters(e) {
    this._applyToEmitters("end", e);
    this.reset(e);
  },
  _fetchEmitters(e) {
    this._activeEmitters = this._emittersSet.slice();
    this._applyToEmitters("start", e);
  },
  _pointerMoveHandler(e) {
    this._applyToEmitters("move", e);
  },
  _pointerUpHandler(e) {
    this._updateEmitters(e);
  },
  _mouseWheelHandler(e) {
    if (!this._allowInterruptionByMouseWheel()) {
      return;
    }
    e.pointers = [null];
    this._pointerDownHandler(e);
    this._adjustWheelEvent(e);
    this._pointerMoveHandler(e);
    e.pointers = [];
    this._pointerUpHandler(e);
  },
  _allowInterruptionByMouseWheel() {
    let allowInterruption = true;
    this._eachEmitter((emitter) => {
      allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
      return allowInterruption;
    });
    return allowInterruption;
  },
  _adjustWheelEvent(e) {
    let closestGestureEmitter = null;
    this._eachEmitter((emitter) => {
      if (!emitter.gesture) {
        return;
      }
      const direction2 = emitter.getDirection(e);
      if ("horizontal" !== direction2 && !e.shiftKey || "vertical" !== direction2 && e.shiftKey) {
        closestGestureEmitter = emitter;
        return false;
      }
    });
    if (!closestGestureEmitter) {
      return;
    }
    const direction = closestGestureEmitter.getDirection(e);
    const verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction;
    const prop = verticalGestureDirection ? "pageY" : "pageX";
    e[prop] += e.delta;
  },
  isActive(element) {
    let result2 = false;
    this._eachEmitter((emitter) => {
      result2 = result2 || emitter.getElement().is(element);
    });
    return result2;
  }
});
var eventManager = new EventManager();
var registerEmitter = function(emitterConfig) {
  const EmitterClass = emitterConfig.emitter;
  const emitterName = emitterConfig.events[0];
  const emitterEvents = emitterConfig.events;
  each(emitterEvents, (_, eventName) => {
    m_event_registrator_default(eventName, {
      noBubble: !emitterConfig.bubble,
      setup(element) {
        const subscriptions = data(element, "dxEmitterSubscription") || {};
        const emitters = data(element, "dxEmitter") || {};
        const emitter = emitters[emitterName] || new EmitterClass(element);
        subscriptions[eventName] = true;
        emitters[emitterName] = emitter;
        data(element, "dxEmitter", emitters);
        data(element, "dxEmitterSubscription", subscriptions);
      },
      add(element, handleObj) {
        const emitters = data(element, "dxEmitter");
        const emitter = emitters[emitterName];
        emitter.configure(extend({
          delegateSelector: handleObj.selector
        }, handleObj.data), handleObj.type);
      },
      teardown(element) {
        const subscriptions = data(element, "dxEmitterSubscription");
        const emitters = data(element, "dxEmitter");
        const emitter = emitters[emitterName];
        delete subscriptions[eventName];
        let disposeEmitter = true;
        each(emitterEvents, (_2, eventName2) => {
          disposeEmitter = disposeEmitter && !subscriptions[eventName2];
          return disposeEmitter;
        });
        if (disposeEmitter) {
          if (eventManager.isActive(element)) {
            eventManager.resetEmitter(emitter);
          }
          emitter && emitter.dispose();
          delete emitters[emitterName];
        }
      }
    });
  });
};
var m_emitter_registrator_default = registerEmitter;

// node_modules/devextreme/esm/__internal/events/utils/m_event_nodes_disposing.js
function nodesByEvent(event) {
  return event && [event.target, event.delegateTarget, event.relatedTarget, event.currentTarget].filter((node) => !!node);
}
var subscribeNodesDisposing = (event, callback) => {
  m_events_engine_default.one(nodesByEvent(event), removeEvent, callback);
};
var unsubscribeNodesDisposing = (event, callback) => {
  m_events_engine_default.off(nodesByEvent(event), removeEvent, callback);
};

// node_modules/devextreme/esm/__internal/events/m_click.js
var CLICK_EVENT_NAME = "dxclick";
var prevented = null;
var lastFiredEvent = null;
var onNodeRemove = () => {
  lastFiredEvent = null;
};
var clickHandler = function(e) {
  const {
    originalEvent
  } = e;
  const eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
  const leftButton = !e.which || 1 === e.which;
  if (leftButton && !prevented && !eventAlreadyFired) {
    if (originalEvent) {
      originalEvent.DXCLICK_FIRED = true;
    }
    unsubscribeNodesDisposing(lastFiredEvent, onNodeRemove);
    lastFiredEvent = originalEvent;
    subscribeNodesDisposing(lastFiredEvent, onNodeRemove);
    fireEvent({
      type: "dxclick",
      originalEvent: e
    });
  }
};
var ClickEmitter = m_emitter_default.inherit({
  ctor(element) {
    this.callBase(element);
    m_events_engine_default.on(this.getElement(), "click", clickHandler);
  },
  start() {
    prevented = null;
  },
  cancel() {
    prevented = true;
  },
  dispose() {
    m_events_engine_default.off(this.getElement(), "click", clickHandler);
  }
});
!function() {
  const desktopDevice = m_devices_default.real().generic;
  if (!desktopDevice) {
    let startTarget = null;
    let blurPrevented = false;
    const isInput = function(element) {
      return renderer_default(element).is("input, textarea, select, button ,:focus, :focus *");
    };
    const pointerDownHandler = function(e) {
      startTarget = e.target;
      blurPrevented = e.isDefaultPrevented();
    };
    const getTarget = function(e) {
      const target = getEventTarget(e);
      return renderer_default(target);
    };
    const clickHandler2 = function(e) {
      const $target = getTarget(e);
      if (!blurPrevented && startTarget && !$target.is(startTarget) && !renderer_default(startTarget).is("label") && isInput($target)) {
        m_dom_default.resetActiveElement();
      }
      startTarget = null;
      blurPrevented = false;
    };
    const NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
    const document2 = dom_adapter_default.getDocument();
    m_events_engine_default.subscribeGlobal(document2, addNamespace2(m_pointer_default.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler);
    m_events_engine_default.subscribeGlobal(document2, addNamespace2("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler2);
  }
}();
m_emitter_registrator_default({
  emitter: ClickEmitter,
  bubble: true,
  events: ["dxclick"]
});

// node_modules/devextreme/esm/__internal/events/m_hold.js
var {
  abs
} = Math;
var HoldEmitter = m_emitter_default.inherit({
  start(e) {
    this._startEventData = eventData(e);
    this._startTimer(e);
  },
  _startTimer(e) {
    const holdTimeout = "timeout" in this ? this.timeout : 750;
    this._holdTimer = setTimeout(() => {
      this._requestAccept(e);
      this._fireEvent("dxhold", e, {
        target: e.target
      });
      this._forgetAccept();
    }, holdTimeout);
  },
  move(e) {
    if (this._touchWasMoved(e)) {
      this._cancel(e);
    }
  },
  _touchWasMoved(e) {
    const delta = eventDelta(this._startEventData, eventData(e));
    return abs(delta.x) > 5 || abs(delta.y) > 5;
  },
  end() {
    this._stopTimer();
  },
  _stopTimer() {
    clearTimeout(this._holdTimer);
  },
  cancel() {
    this._stopTimer();
  },
  dispose() {
    this._stopTimer();
  }
});
m_emitter_registrator_default({
  emitter: HoldEmitter,
  bubble: true,
  events: ["dxhold"]
});
var m_hold_default = {
  name: "dxhold"
};

// node_modules/devextreme/esm/__internal/events/m_contextmenu.js
var CONTEXTMENU_NAMESPACED_EVENT_NAME = addNamespace2("contextmenu", "dxContexMenu");
var HOLD_NAMESPACED_EVENT_NAME = addNamespace2(m_hold_default.name, "dxContexMenu");
var ContextMenu = class_default.inherit({
  setup(element) {
    const $element = renderer_default(element);
    m_events_engine_default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
    if (m_support_default.touch || m_devices_default.isSimulator()) {
      m_events_engine_default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
    }
  },
  _holdHandler(e) {
    if (isMouseEvent(e) && !m_devices_default.isSimulator()) {
      return;
    }
    this._fireContextMenu(e);
  },
  _contextMenuHandler(e) {
    this._fireContextMenu(e);
  },
  _fireContextMenu: (e) => fireEvent({
    type: "dxcontextmenu",
    originalEvent: e
  }),
  teardown(element) {
    m_events_engine_default.off(element, ".dxContexMenu");
  }
});
m_event_registrator_default("dxcontextmenu", new ContextMenu());
var name = "dxcontextmenu";

// node_modules/devextreme/esm/common/core/localization/cldr-data/parent_locales.js
var parent_locales_default = {
  "en-150": "en-001",
  "en-AG": "en-001",
  "en-AI": "en-001",
  "en-AU": "en-001",
  "en-BB": "en-001",
  "en-BM": "en-001",
  "en-BS": "en-001",
  "en-BW": "en-001",
  "en-BZ": "en-001",
  "en-CC": "en-001",
  "en-CK": "en-001",
  "en-CM": "en-001",
  "en-CX": "en-001",
  "en-CY": "en-001",
  "en-DG": "en-001",
  "en-DM": "en-001",
  "en-ER": "en-001",
  "en-FJ": "en-001",
  "en-FK": "en-001",
  "en-FM": "en-001",
  "en-GB": "en-001",
  "en-GD": "en-001",
  "en-GG": "en-001",
  "en-GH": "en-001",
  "en-GI": "en-001",
  "en-GM": "en-001",
  "en-GY": "en-001",
  "en-HK": "en-001",
  "en-IE": "en-001",
  "en-IL": "en-001",
  "en-IM": "en-001",
  "en-IN": "en-001",
  "en-IO": "en-001",
  "en-JE": "en-001",
  "en-JM": "en-001",
  "en-KE": "en-001",
  "en-KI": "en-001",
  "en-KN": "en-001",
  "en-KY": "en-001",
  "en-LC": "en-001",
  "en-LR": "en-001",
  "en-LS": "en-001",
  "en-MG": "en-001",
  "en-MO": "en-001",
  "en-MS": "en-001",
  "en-MT": "en-001",
  "en-MU": "en-001",
  "en-MV": "en-001",
  "en-MW": "en-001",
  "en-MY": "en-001",
  "en-NA": "en-001",
  "en-NF": "en-001",
  "en-NG": "en-001",
  "en-NR": "en-001",
  "en-NU": "en-001",
  "en-NZ": "en-001",
  "en-PG": "en-001",
  "en-PK": "en-001",
  "en-PN": "en-001",
  "en-PW": "en-001",
  "en-RW": "en-001",
  "en-SB": "en-001",
  "en-SC": "en-001",
  "en-SD": "en-001",
  "en-SG": "en-001",
  "en-SH": "en-001",
  "en-SL": "en-001",
  "en-SS": "en-001",
  "en-SX": "en-001",
  "en-SZ": "en-001",
  "en-TC": "en-001",
  "en-TK": "en-001",
  "en-TO": "en-001",
  "en-TT": "en-001",
  "en-TV": "en-001",
  "en-TZ": "en-001",
  "en-UG": "en-001",
  "en-VC": "en-001",
  "en-VG": "en-001",
  "en-VU": "en-001",
  "en-WS": "en-001",
  "en-ZA": "en-001",
  "en-ZM": "en-001",
  "en-ZW": "en-001",
  "en-AT": "en-150",
  "en-BE": "en-150",
  "en-CH": "en-150",
  "en-DE": "en-150",
  "en-DK": "en-150",
  "en-FI": "en-150",
  "en-NL": "en-150",
  "en-SE": "en-150",
  "en-SI": "en-150",
  "hi-Latn": "en-IN",
  "es-AR": "es-419",
  "es-BO": "es-419",
  "es-BR": "es-419",
  "es-BZ": "es-419",
  "es-CL": "es-419",
  "es-CO": "es-419",
  "es-CR": "es-419",
  "es-CU": "es-419",
  "es-DO": "es-419",
  "es-EC": "es-419",
  "es-GT": "es-419",
  "es-HN": "es-419",
  "es-MX": "es-419",
  "es-NI": "es-419",
  "es-PA": "es-419",
  "es-PE": "es-419",
  "es-PR": "es-419",
  "es-PY": "es-419",
  "es-SV": "es-419",
  "es-US": "es-419",
  "es-UY": "es-419",
  "es-VE": "es-419",
  nb: "no",
  nn: "no",
  "pt-AO": "pt-PT",
  "pt-CH": "pt-PT",
  "pt-CV": "pt-PT",
  "pt-FR": "pt-PT",
  "pt-GQ": "pt-PT",
  "pt-GW": "pt-PT",
  "pt-LU": "pt-PT",
  "pt-MO": "pt-PT",
  "pt-MZ": "pt-PT",
  "pt-ST": "pt-PT",
  "pt-TL": "pt-PT",
  "az-Arab": "und",
  "az-Cyrl": "und",
  "bal-Latn": "und",
  "blt-Latn": "und",
  "bm-Nkoo": "und",
  "bs-Cyrl": "und",
  "byn-Latn": "und",
  "cu-Glag": "und",
  "dje-Arab": "und",
  "dyo-Arab": "und",
  "en-Dsrt": "und",
  "en-Shaw": "und",
  "ff-Adlm": "und",
  "ff-Arab": "und",
  "ha-Arab": "und",
  "iu-Latn": "und",
  "kk-Arab": "und",
  "ks-Deva": "und",
  "ku-Arab": "und",
  "ky-Arab": "und",
  "ky-Latn": "und",
  "ml-Arab": "und",
  "mn-Mong": "und",
  "mni-Mtei": "und",
  "ms-Arab": "und",
  "pa-Arab": "und",
  "sat-Deva": "und",
  "sd-Deva": "und",
  "sd-Khoj": "und",
  "sd-Sind": "und",
  "shi-Latn": "und",
  "so-Arab": "und",
  "sr-Latn": "und",
  "sw-Arab": "und",
  "tg-Arab": "und",
  "ug-Cyrl": "und",
  "uz-Arab": "und",
  "uz-Cyrl": "und",
  "vai-Latn": "und",
  "wo-Arab": "und",
  "yo-Arab": "und",
  "yue-Hans": "und",
  "zh-Hant": "und",
  "zh-Hant-MO": "zh-Hant-HK"
};

// node_modules/devextreme/esm/common/core/localization/parentLocale.js
var parentLocale_default = (parentLocales, locale) => {
  const parentLocale = parentLocales[locale];
  if (parentLocale) {
    return "root" !== parentLocale && parentLocale;
  }
  return locale.substr(0, locale.lastIndexOf("-"));
};

// node_modules/devextreme/esm/common/core/localization/core.js
var core_default = dependency_injector_default({
  locale: /* @__PURE__ */ (() => {
    let currentLocale = "en";
    return (locale) => {
      if (!locale) {
        return currentLocale;
      }
      currentLocale = locale;
    };
  })(),
  getValueByClosestLocale: function(getter) {
    let locale = this.locale();
    let value2 = getter(locale);
    let isRootLocale;
    while (!value2 && !isRootLocale) {
      locale = parentLocale_default(parent_locales_default, locale);
      if (locale) {
        value2 = getter(locale);
      } else {
        isRootLocale = true;
      }
    }
    if (void 0 === value2 && "en" !== locale) {
      return getter("en");
    }
    return value2;
  }
});

// node_modules/devextreme/esm/common/core/localization/default_messages.js
var defaultMessages = {
  en: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    CheckState: "Check state",
    Close: "Close",
    Clear: "Clear",
    Done: "Done",
    Loading: "Loading...",
    Select: "Select...",
    Search: "Search",
    Back: "Back",
    OK: "OK",
    Today: "Today",
    Yesterday: "Yesterday",
    "dxCollectionWidget-noDataText": "No data to display",
    "dxDropDownEditor-selectLabel": "Select",
    "validation-required": "Required",
    "validation-required-formatted": "{0} is required",
    "validation-numeric": "Value must be a number",
    "validation-numeric-formatted": "{0} must be a number",
    "validation-range": "Value is out of range",
    "validation-range-formatted": "{0} is out of range",
    "validation-stringLength": "The length of the value is not correct",
    "validation-stringLength-formatted": "The length of {0} is not correct",
    "validation-custom": "Value is invalid",
    "validation-custom-formatted": "{0} is invalid",
    "validation-async": "Value is invalid",
    "validation-async-formatted": "{0} is invalid",
    "validation-compare": "Values do not match",
    "validation-compare-formatted": "{0} does not match",
    "validation-pattern": "Value does not match pattern",
    "validation-pattern-formatted": "{0} does not match pattern",
    "validation-email": "Email is invalid",
    "validation-email-formatted": "{0} is invalid",
    "validation-mask": "Value is invalid",
    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
    "dxList-pullingDownText": "Pull down to refresh...",
    "dxList-pulledDownText": "Release to refresh...",
    "dxList-refreshingText": "Refreshing...",
    "dxList-pageLoadingText": "Loading...",
    "dxList-nextButtonText": "More",
    "dxList-selectAll": "Select All",
    "dxList-listAriaLabel": "Items",
    "dxList-listAriaLabel-deletable": "Deletable items",
    "dxListEditDecorator-delete": "Delete",
    "dxListEditDecorator-more": "More",
    "dxList-selectAll-indeterminate": "Half-checked",
    "dxList-selectAll-checked": "Checked",
    "dxList-selectAll-notChecked": "Not checked",
    "dxList-ariaRoleDescription": "List",
    "dxList-listAriaLabel-itemContent": "List item content",
    "dxScrollView-pullingDownText": "Pull down to refresh...",
    "dxScrollView-pulledDownText": "Release to refresh...",
    "dxScrollView-refreshingText": "Refreshing...",
    "dxScrollView-reachBottomText": "Loading...",
    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
    "dxDateBox-validation-datetime": "Value must be a date or time",
    "dxDateRangeBox-invalidStartDateMessage": "Start value must be a date",
    "dxDateRangeBox-invalidEndDateMessage": "End value must be a date",
    "dxDateRangeBox-startDateOutOfRangeMessage": "Start date is out of range",
    "dxDateRangeBox-endDateOutOfRangeMessage": "End date is out of range",
    "dxDateRangeBox-startDateLabel": "Start Date",
    "dxDateRangeBox-endDateLabel": "End Date",
    "dxFileUploader-selectFile": "Select a file",
    "dxFileUploader-dropFile": "or Drop a file here",
    "dxFileUploader-bytes": "bytes",
    "dxFileUploader-kb": "KB",
    "dxFileUploader-Mb": "MB",
    "dxFileUploader-Gb": "GB",
    "dxFileUploader-upload": "Upload",
    "dxFileUploader-uploaded": "Uploaded",
    "dxFileUploader-readyToUpload": "Ready to upload",
    "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
    "dxFileUploader-uploadFailedMessage": "Upload failed",
    "dxFileUploader-invalidFileExtension": "File type is not allowed",
    "dxFileUploader-invalidMaxFileSize": "File is too large",
    "dxFileUploader-invalidMinFileSize": "File is too small",
    "dxRangeSlider-ariaFrom": "From",
    "dxRangeSlider-ariaTill": "Till",
    "dxSwitch-switchedOnText": "ON",
    "dxSwitch-switchedOffText": "OFF",
    "dxForm-optionalMark": "optional",
    "dxForm-requiredMessage": "{0} is required",
    "dxNumberBox-invalidValueMessage": "Value must be a number",
    "dxNumberBox-noDataText": "No data",
    "dxDataGrid-emptyHeaderWithColumnChooserText": "Use {0} to display columns",
    "dxDataGrid-emptyHeaderWithGroupPanelText": "Drag a column from the group panel here",
    "dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText": "Use {0} or drag a column from the group panel",
    "dxDataGrid-emptyHeaderColumnChooserText": "column chooser",
    "dxDataGrid-columnChooserTitle": "Column Chooser",
    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
    "dxDataGrid-groupHeaderText": "Group by This Column",
    "dxDataGrid-ungroupHeaderText": "Ungroup",
    "dxDataGrid-ungroupAllText": "Ungroup All",
    "dxDataGrid-editingEditRow": "Edit",
    "dxDataGrid-editingSaveRowChanges": "Save",
    "dxDataGrid-editingCancelRowChanges": "Cancel",
    "dxDataGrid-editingDeleteRow": "Delete",
    "dxDataGrid-editingUndeleteRow": "Undelete",
    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
    "dxDataGrid-validationCancelChanges": "Cancel changes",
    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
    "dxDataGrid-noDataText": "No data",
    "dxDataGrid-searchPanelPlaceholder": "Search...",
    "dxDataGrid-filterRowShowAllText": "(All)",
    "dxDataGrid-filterRowResetOperationText": "Reset",
    "dxDataGrid-filterRowOperationEquals": "Equals",
    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
    "dxDataGrid-filterRowOperationLess": "Less than",
    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
    "dxDataGrid-filterRowOperationGreater": "Greater than",
    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
    "dxDataGrid-filterRowOperationContains": "Contains",
    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
    "dxDataGrid-filterRowOperationBetween": "Between",
    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
    "dxDataGrid-filterRowOperationBetweenEndText": "End",
    "dxDataGrid-ariaSearchBox": "Search box",
    "dxDataGrid-applyFilterText": "Apply filter",
    "dxDataGrid-trueText": "true",
    "dxDataGrid-falseText": "false",
    "dxDataGrid-sortingAscendingText": "Sort Ascending",
    "dxDataGrid-sortingDescendingText": "Sort Descending",
    "dxDataGrid-sortingClearText": "Clear Sorting",
    "dxDataGrid-ariaNotSortedColumn": "Not sorted column",
    "dxDataGrid-ariaSortedAscendingColumn": "Column sorted in ascending order",
    "dxDataGrid-ariaSortedDescendingColumn": "Column sorted in descending order",
    "dxDataGrid-ariaSortIndex": "Sort index {0}",
    "dxDataGrid-editingSaveAllChanges": "Save changes",
    "dxDataGrid-editingCancelAllChanges": "Discard changes",
    "dxDataGrid-editingAddRow": "Add a row",
    "dxDataGrid-summaryMin": "Min: {0}",
    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
    "dxDataGrid-summaryMax": "Max: {0}",
    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
    "dxDataGrid-summaryAvg": "Avg: {0}",
    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
    "dxDataGrid-summarySum": "Sum: {0}",
    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
    "dxDataGrid-summaryCount": "Count: {0}",
    "dxDataGrid-columnFixingFix": "Set Fixed Position",
    "dxDataGrid-columnFixingUnfix": "Unfix",
    "dxDataGrid-columnFixingLeftPosition": "Left",
    "dxDataGrid-columnFixingRightPosition": "Right",
    "dxDataGrid-columnFixingStickyPosition": "Sticky",
    "dxDataGrid-exportTo": "Export",
    "dxDataGrid-exportToExcel": "Export to Excel file",
    "dxDataGrid-exporting": "Exporting...",
    "dxDataGrid-excelFormat": "Excel file",
    "dxDataGrid-selectedRows": "Selected rows",
    "dxDataGrid-exportSelectedRows": "Export selected rows to {0}",
    "dxDataGrid-exportAll": "Export all data to {0}",
    "dxDataGrid-headerFilterLabel": "Filter options",
    "dxDataGrid-headerFilterIndicatorLabel": "Show filter options for column '{0}'",
    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
    "dxDataGrid-headerFilterOK": "OK",
    "dxDataGrid-headerFilterCancel": "Cancel",
    "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
    "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
    "dxDataGrid-ariaColumn": "Column",
    "dxDataGrid-ariaColumnHeader": "Column header",
    "dxDataGrid-ariaValue": "Value",
    "dxDataGrid-ariaError": "Error",
    "dxDataGrid-ariaRevertButton": "Press Escape to discard the changes",
    "dxDataGrid-ariaFilterCell": "Filter cell",
    "dxDataGrid-ariaCollapse": "Collapse",
    "dxDataGrid-ariaModifiedCell": "Modified",
    "dxDataGrid-ariaDeletedCell": "Deleted",
    "dxDataGrid-ariaEditableCell": "Editable",
    "dxDataGrid-ariaExpand": "Expand",
    "dxDataGrid-ariaCollapsedRow": "Collapsed row",
    "dxDataGrid-ariaExpandedRow": "Expanded row",
    "dxDataGrid-ariaDataGrid": "Data grid with {0} rows and {1} columns",
    "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
    "dxDataGrid-ariaSelectAll": "Select all",
    "dxDataGrid-ariaSelectRow": "Select row",
    "dxDataGrid-ariaToolbar": "Data grid toolbar",
    "dxDataGrid-ariaEditForm": "Edit form",
    "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
    "dxDataGrid-filterPanelCreateFilter": "Create Filter",
    "dxDataGrid-filterPanelClearFilter": "Clear",
    "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
    "dxDataGrid-masterDetail": "Cell with details",
    "dxDataGrid-moveColumnToTheRight": "Move to the right",
    "dxDataGrid-moveColumnToTheLeft": "Move to the left",
    "dxTreeList-ariaTreeList": "Tree list with {0} rows and {1} columns",
    "dxTreeList-ariaExpandableInstruction": "Press Ctrl + right arrow to expand the focused node and Ctrl + left arrow to collapse it",
    "dxTreeList-ariaSearchInGrid": "Search in the tree list",
    "dxTreeList-ariaToolbar": "Tree list toolbar",
    "dxTreeList-editingAddRowToNode": "Add",
    "dxPager-infoText": "Page {0} of {1} ({2} items)",
    "dxPager-pagesCountText": "of",
    "dxPager-pageSize": "Items per page: {0}",
    "dxPager-pageSizesAllText": "All",
    "dxPager-page": "Page {0}",
    "dxPager-prevPage": "Previous page",
    "dxPager-nextPage": "Next page",
    "dxPager-ariaLabel": "Page navigation",
    "dxPager-ariaPageSize": "Page size",
    "dxPager-ariaPageNumber": "Page number",
    "dxPagination-infoText": "Page {0} of {1} ({2} items)",
    "dxPagination-pagesCountText": "of",
    "dxPagination-pageSize": "Items per page: {0}",
    "dxPagination-pageSizesAllText": "All",
    "dxPagination-page": "Page {0}",
    "dxPagination-prevPage": "Previous page",
    "dxPagination-nextPage": "Next page",
    "dxPagination-ariaLabel": "Page navigation",
    "dxPagination-ariaPageSize": "Page size",
    "dxPagination-ariaPageNumber": "Page number",
    "dxPivotGrid-grandTotal": "Grand Total",
    "dxPivotGrid-total": "{0} Total",
    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
    "dxPivotGrid-expandAll": "Expand All",
    "dxPivotGrid-collapseAll": "Collapse All",
    "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
    "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
    "dxPivotGrid-dataNotAvailable": "N/A",
    "dxPivotGrid-rowFields": "Row Fields",
    "dxPivotGrid-columnFields": "Column Fields",
    "dxPivotGrid-dataFields": "Data Fields",
    "dxPivotGrid-filterFields": "Filter Fields",
    "dxPivotGrid-allFields": "All Fields",
    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
    "dxScheduler-dateRange": "from {0} to {1}",
    "dxScheduler-ariaLabel": "Scheduler. {0} view: {1} with {2} appointments",
    "dxScheduler-ariaLabel-currentIndicator-present": "The current time indicator is visible in the view",
    "dxScheduler-ariaLabel-currentIndicator-not-present": "The current time indicator is not visible on the screen",
    "dxScheduler-appointmentAriaLabel-group": "Group: {0}",
    "dxScheduler-appointmentAriaLabel-recurring": "Recurring appointment",
    "dxScheduler-appointmentListAriaLabel": "Appointment list",
    "dxScheduler-editorLabelTitle": "Subject",
    "dxScheduler-editorLabelStartDate": "Start Date",
    "dxScheduler-editorLabelEndDate": "End Date",
    "dxScheduler-editorLabelDescription": "Description",
    "dxScheduler-editorLabelRecurrence": "Repeat",
    "dxScheduler-navigationToday": "Today",
    "dxScheduler-navigationPrevious": "Previous page",
    "dxScheduler-navigationNext": "Next page",
    "dxScheduler-openAppointment": "Open appointment",
    "dxScheduler-recurrenceNever": "Never",
    "dxScheduler-recurrenceMinutely": "Every minute",
    "dxScheduler-recurrenceHourly": "Hourly",
    "dxScheduler-recurrenceDaily": "Daily",
    "dxScheduler-recurrenceWeekly": "Weekly",
    "dxScheduler-recurrenceMonthly": "Monthly",
    "dxScheduler-recurrenceYearly": "Yearly",
    "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
    "dxScheduler-recurrenceRepeatOn": "Repeat On",
    "dxScheduler-recurrenceEnd": "End repeat",
    "dxScheduler-recurrenceAfter": "After",
    "dxScheduler-recurrenceOn": "On",
    "dxScheduler-recurrenceUntilDateLabel": "Date when repeat ends",
    "dxScheduler-recurrenceOccurrenceLabel": "Number of occurrences",
    "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
    "dxScheduler-recurrenceRepeatHourly": "hour(s)",
    "dxScheduler-recurrenceRepeatDaily": "day(s)",
    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
    "dxScheduler-recurrenceRepeatYearly": "year(s)",
    "dxScheduler-switcherDay": "Day",
    "dxScheduler-switcherWeek": "Week",
    "dxScheduler-switcherWorkWeek": "Work Week",
    "dxScheduler-switcherMonth": "Month",
    "dxScheduler-switcherAgenda": "Agenda",
    "dxScheduler-switcherTimelineDay": "Timeline Day",
    "dxScheduler-switcherTimelineWeek": "Timeline Week",
    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
    "dxScheduler-switcherTimelineMonth": "Timeline Month",
    "dxScheduler-recurrenceRepeatOnDate": "on date",
    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
    "dxScheduler-allDay": "All day",
    "dxScheduler-ariaEditForm": "Edit form",
    "dxScheduler-confirmRecurrenceEditTitle": "Edit Recurring Appointment",
    "dxScheduler-confirmRecurrenceDeleteTitle": "Delete Recurring Appointment",
    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
    "dxScheduler-noTimezoneTitle": "No timezone",
    "dxScheduler-moreAppointments": "{0} more",
    "dxCalendar-currentDay": "Today",
    "dxCalendar-currentMonth": "Current month",
    "dxCalendar-currentYear": "Current year",
    "dxCalendar-currentYearRange": "Current year range",
    "dxCalendar-todayButtonText": "Today",
    "dxCalendar-ariaWidgetName": "Calendar",
    "dxCalendar-previousMonthButtonLabel": "Previous month",
    "dxCalendar-previousYearButtonLabel": "Previous year",
    "dxCalendar-previousDecadeButtonLabel": "Previous decade",
    "dxCalendar-previousCenturyButtonLabel": "Previous century",
    "dxCalendar-nextMonthButtonLabel": "Next month",
    "dxCalendar-nextYearButtonLabel": "Next year",
    "dxCalendar-nextDecadeButtonLabel": "Next decade",
    "dxCalendar-nextCenturyButtonLabel": "Next century",
    "dxCalendar-captionMonthLabel": "Month selection",
    "dxCalendar-captionYearLabel": "Year selection",
    "dxCalendar-captionDecadeLabel": "Decade selection",
    "dxCalendar-captionCenturyLabel": "Century selection",
    "dxCalendar-selectedDate": "The selected date is {0}",
    "dxCalendar-selectedDates": "The selected dates",
    "dxCalendar-selectedDateRange": "The selected date range is from {0} to {1}",
    "dxCalendar-selectedMultipleDateRange": "from {0} to {1}",
    "dxCalendar-selectedDateRangeCount": "There are {0} selected date ranges",
    "dxCalendar-readOnlyLabel": "Read-only calendar",
    "dxCardView-ariaSearchInGrid": "Search in the card view",
    "dxCardView-ariaHeaderItemLabel": "Field name {0}",
    "dxCardView-ariaHeaderItemSortingAscendingLabel": "Sorted in ascending order",
    "dxCardView-ariaHeaderItemSortingDescendingLabel": "Sorted in descending order",
    "dxCardView-ariaHeaderItemSortingIndexLabel": "Sort index {0}",
    "dxCardView-ariaHeaderHasHeaderFilterLabel": "Header filter applied",
    "dxCardView-ariaSelectCard": "Select card",
    "dxCardView-ariaCardView": "Card view with {0} cards. Each card has {1} fields",
    "dxCardView-ariaCard": "Card",
    "dxCardView-ariaEditableCard": "Editable card",
    "dxCardView-ariaCardPosition": "Row {0}, column {1}",
    "dxCardView-ariaSelectedCardState": "Selected",
    "dxCardView-ariaNotSelectedCardState": "Not selected",
    "dxCardView-selectAll": "Select all",
    "dxCardView-clearSelection": "Clear selection",
    "dxCardView-cardNoImageAriaLabel": "No image",
    "dxCardView-headerItemDropZoneText": "Drop the header item here",
    "dxCardView-emptyHeaderPanelText": "Use {0} to display columns",
    "dxCardView-emptyHeaderPanelColumnChooserText": "column chooser",
    "dxAvatar-defaultImageAlt": "Avatar",
    "dxChat-elementAriaLabel": "Chat",
    "dxChat-textareaPlaceholder": "Type a message",
    "dxChat-sendButtonAriaLabel": "Send",
    "dxChat-cancelEditingButtonAriaLabel": "Cancel",
    "dxChat-editingMessageCaption": "Edit Message",
    "dxChat-defaultUserName": "Unknown User",
    "dxChat-messageListAriaLabel": "Message list",
    "dxChat-alertListAriaLabel": "Error list",
    "dxChat-emptyListMessage": "There are no messages in this chat",
    "dxChat-emptyListPrompt": "Write your first message",
    "dxChat-typingMessageSingleUser": "{0} is typing...",
    "dxChat-typingMessageTwoUsers": "{0} and {1} are typing...",
    "dxChat-typingMessageThreeUsers": "{0}, {1} and {2} are typing...",
    "dxChat-typingMessageMultipleUsers": "{0} and others are typing...",
    "dxChat-editedMessageText": "Edited",
    "dxChat-editingEditMessage": "Edit",
    "dxChat-editingDeleteMessage": "Delete",
    "dxChat-editingDeleteConfirmText": "Are you sure you want to delete this message?",
    "dxChat-deletedMessageText": "This message was deleted",
    "dxChat-defaultImageAlt": "Image shared in chat",
    "dxColorView-ariaRed": "Red",
    "dxColorView-ariaGreen": "Green",
    "dxColorView-ariaBlue": "Blue",
    "dxColorView-ariaAlpha": "Transparency",
    "dxColorView-ariaHex": "Color code",
    "dxTagBox-selected": "{0} selected",
    "dxTagBox-allSelected": "All selected ({0})",
    "dxTagBox-moreSelected": "{0} more",
    "dxTagBox-tagRoleDescription": "Tag. Press the delete button to remove this tag",
    "dxTagBox-ariaRoleDescription": "Tag box",
    "vizExport-printingButtonText": "Print",
    "vizExport-titleMenuText": "Exporting/Printing",
    "vizExport-exportButtonText": "{0} file",
    "dxFilterBuilder-and": "And",
    "dxFilterBuilder-or": "Or",
    "dxFilterBuilder-notAnd": "Not And",
    "dxFilterBuilder-notOr": "Not Or",
    "dxFilterBuilder-addCondition": "Add Condition",
    "dxFilterBuilder-addGroup": "Add Group",
    "dxFilterBuilder-enterValueText": "<enter a value>",
    "dxFilterBuilder-filterOperationEquals": "Equals",
    "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
    "dxFilterBuilder-filterOperationLess": "Is less than",
    "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
    "dxFilterBuilder-filterOperationGreater": "Is greater than",
    "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
    "dxFilterBuilder-filterOperationStartsWith": "Starts with",
    "dxFilterBuilder-filterOperationContains": "Contains",
    "dxFilterBuilder-filterOperationNotContains": "Does not contain",
    "dxFilterBuilder-filterOperationEndsWith": "Ends with",
    "dxFilterBuilder-filterOperationIsBlank": "Is blank",
    "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
    "dxFilterBuilder-filterOperationBetween": "Is between",
    "dxFilterBuilder-filterOperationAnyOf": "Is any of",
    "dxFilterBuilder-filterOperationNoneOf": "Is none of",
    "dxFilterBuilder-filterAriaRootElement": "Filter builder",
    "dxFilterBuilder-filterAriaGroupLevel": "Level {0}",
    "dxFilterBuilder-filterAriaGroupItem": "Group item",
    "dxFilterBuilder-filterAriaOperationButton": "Operation",
    "dxFilterBuilder-filterAriaAddButton": "Add",
    "dxFilterBuilder-filterAriaRemoveButton": "Remove {0}",
    "dxFilterBuilder-filterAriaItemField": "Item field",
    "dxFilterBuilder-filterAriaItemOperation": "Item operation",
    "dxFilterBuilder-filterAriaItemValue": "Item value",
    "dxHtmlEditor-dialogColorCaption": "Change Font Color",
    "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
    "dxHtmlEditor-dialogLinkCaption": "Add Link",
    "dxHtmlEditor-dialogLinkUrlField": "URL",
    "dxHtmlEditor-dialogLinkTextField": "Text",
    "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
    "dxHtmlEditor-dialogImageCaption": "Add Image",
    "dxHtmlEditor-dialogImageUrlField": "URL",
    "dxHtmlEditor-dialogImageAltField": "Alternate text",
    "dxHtmlEditor-dialogImageWidthField": "Width (px)",
    "dxHtmlEditor-dialogImageHeightField": "Height (px)",
    "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
    "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
    "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
    "dxHtmlEditor-dialogUpdateImageCaption": "Update Image",
    "dxHtmlEditor-dialogImageUpdateButton": "Update",
    "dxHtmlEditor-dialogImageAddButton": "Add",
    "dxHtmlEditor-dialogImageSpecifyUrl": "From the Web",
    "dxHtmlEditor-dialogImageSelectFile": "From This Device",
    "dxHtmlEditor-dialogImageKeepAspectRatio": "Keep Aspect Ratio",
    "dxHtmlEditor-dialogImageEncodeToBase64": "Encode to Base64",
    "dxHtmlEditor-heading": "Heading",
    "dxHtmlEditor-normalText": "Normal text",
    "dxHtmlEditor-background": "Background Color",
    "dxHtmlEditor-bold": "Bold",
    "dxHtmlEditor-color": "Font Color",
    "dxHtmlEditor-font": "Font",
    "dxHtmlEditor-italic": "Italic",
    "dxHtmlEditor-link": "Add Link",
    "dxHtmlEditor-image": "Add Image",
    "dxHtmlEditor-size": "Size",
    "dxHtmlEditor-strike": "Strikethrough",
    "dxHtmlEditor-subscript": "Subscript",
    "dxHtmlEditor-superscript": "Superscript",
    "dxHtmlEditor-underline": "Underline",
    "dxHtmlEditor-blockquote": "Blockquote",
    "dxHtmlEditor-header": "Header",
    "dxHtmlEditor-increaseIndent": "Increase Indent",
    "dxHtmlEditor-decreaseIndent": "Decrease Indent",
    "dxHtmlEditor-orderedList": "Ordered List",
    "dxHtmlEditor-bulletList": "Bullet List",
    "dxHtmlEditor-alignLeft": "Align Left",
    "dxHtmlEditor-alignCenter": "Align Center",
    "dxHtmlEditor-alignRight": "Align Right",
    "dxHtmlEditor-alignJustify": "Align Justify",
    "dxHtmlEditor-codeBlock": "Code Block",
    "dxHtmlEditor-variable": "Add Variable",
    "dxHtmlEditor-undo": "Undo",
    "dxHtmlEditor-redo": "Redo",
    "dxHtmlEditor-clear": "Clear Formatting",
    "dxHtmlEditor-insertTable": "Insert Table",
    "dxHtmlEditor-insertHeaderRow": "Insert Header Row",
    "dxHtmlEditor-insertRowAbove": "Insert Row Above",
    "dxHtmlEditor-insertRowBelow": "Insert Row Below",
    "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
    "dxHtmlEditor-insertColumnRight": "Insert Column Right",
    "dxHtmlEditor-deleteColumn": "Delete Column",
    "dxHtmlEditor-deleteRow": "Delete Row",
    "dxHtmlEditor-deleteTable": "Delete Table",
    "dxHtmlEditor-cellProperties": "Cell Properties",
    "dxHtmlEditor-tableProperties": "Table Properties",
    "dxHtmlEditor-insert": "Insert",
    "dxHtmlEditor-delete": "Delete",
    "dxHtmlEditor-border": "Border",
    "dxHtmlEditor-style": "Style",
    "dxHtmlEditor-width": "Width",
    "dxHtmlEditor-height": "Height",
    "dxHtmlEditor-borderColor": "Color",
    "dxHtmlEditor-borderWidth": "Border Width",
    "dxHtmlEditor-tableBackground": "Background",
    "dxHtmlEditor-dimensions": "Dimensions",
    "dxHtmlEditor-alignment": "Alignment",
    "dxHtmlEditor-horizontal": "Horizontal",
    "dxHtmlEditor-vertical": "Vertical",
    "dxHtmlEditor-paddingVertical": "Vertical Padding",
    "dxHtmlEditor-paddingHorizontal": "Horizontal Padding",
    "dxHtmlEditor-pixels": "Pixels",
    "dxHtmlEditor-list": "List",
    "dxHtmlEditor-ordered": "Ordered",
    "dxHtmlEditor-bullet": "Bullet",
    "dxHtmlEditor-align": "Align",
    "dxHtmlEditor-center": "Center",
    "dxHtmlEditor-left": "Left",
    "dxHtmlEditor-right": "Right",
    "dxHtmlEditor-indent": "Indent",
    "dxHtmlEditor-justify": "Justify",
    "dxHtmlEditor-borderStyleNone": "none",
    "dxHtmlEditor-borderStyleHidden": "hidden",
    "dxHtmlEditor-borderStyleDotted": "dotted",
    "dxHtmlEditor-borderStyleDashed": "dashed",
    "dxHtmlEditor-borderStyleSolid": "solid",
    "dxHtmlEditor-borderStyleDouble": "double",
    "dxHtmlEditor-borderStyleGroove": "groove",
    "dxHtmlEditor-borderStyleRidge": "ridge",
    "dxHtmlEditor-borderStyleInset": "inset",
    "dxHtmlEditor-borderStyleOutset": "outset",
    "dxHtmlEditor-aiDialogTitle": "AI Assistant",
    "dxHtmlEditor-aiDialogError": "Something went wrong. Please try again.",
    "dxHtmlEditor-aiDialogCanceled": "Generation canceled",
    "dxHtmlEditor-aiReplace": "Replace",
    "dxHtmlEditor-aiInsertAbove": "Insert above",
    "dxHtmlEditor-aiInsertBelow": "Insert below",
    "dxHtmlEditor-aiCopy": "Copy",
    "dxHtmlEditor-aiRegenerate": "Regenerate",
    "dxHtmlEditor-aiGenerate": "Generate",
    "dxHtmlEditor-aiCancel": "Cancel",
    "dxHtmlEditor-aiToolbarItemAriaLabel": "AI Assistant toolbar item",
    "dxHtmlEditor-aiResultTextAreaAriaLabel": "AI Assistant result",
    "dxHtmlEditor-aiAskPlaceholder": "Ask AI to modify text",
    "dxFileManager-newDirectoryName": "Untitled directory",
    "dxFileManager-rootDirectoryName": "Files",
    "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
    "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
    "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
    "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
    "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
    "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
    "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
    "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
    "dxFileManager-errorDefault": "Unspecified error.",
    "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
    "dxFileManager-commandCreate": "New directory",
    "dxFileManager-commandRename": "Rename",
    "dxFileManager-commandMove": "Move to",
    "dxFileManager-commandCopy": "Copy to",
    "dxFileManager-commandDelete": "Delete",
    "dxFileManager-commandDownload": "Download",
    "dxFileManager-commandUpload": "Upload files",
    "dxFileManager-commandRefresh": "Refresh",
    "dxFileManager-commandThumbnails": "Thumbnails View",
    "dxFileManager-commandDetails": "Details View",
    "dxFileManager-commandClearSelection": "Clear selection",
    "dxFileManager-commandShowNavPane": "Toggle navigation pane",
    "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
    "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
    "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
    "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
    "dxFileManager-dialogRenameItemTitle": "Rename",
    "dxFileManager-dialogRenameItemButtonText": "Save",
    "dxFileManager-dialogCreateDirectoryTitle": "New directory",
    "dxFileManager-dialogCreateDirectoryButtonText": "Create",
    "dxFileManager-dialogDeleteItemTitle": "Delete",
    "dxFileManager-dialogDeleteItemButtonText": "Delete",
    "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
    "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
    "dxFileManager-dialogButtonCancel": "Cancel",
    "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
    "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
    "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
    "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
    "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
    "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
    "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
    "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
    "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
    "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
    "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
    "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
    "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
    "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
    "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
    "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
    "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
    "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
    "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
    "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
    "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
    "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
    "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
    "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
    "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
    "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
    "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
    "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
    "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
    "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
    "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
    "dxFileManager-editingUploadCanceledMessage": "Canceled",
    "dxFileManager-editingDownloadSingleItemErrorMessage": "Item was not downloaded",
    "dxFileManager-editingDownloadMultipleItemsErrorMessage": "{0} items were not downloaded",
    "dxFileManager-listDetailsColumnCaptionName": "Name",
    "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
    "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
    "dxFileManager-listThumbnailsTooltipTextSize": "Size",
    "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
    "dxFileManager-notificationProgressPanelTitle": "Progress",
    "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
    "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
    "dxDiagram-categoryGeneral": "General",
    "dxDiagram-categoryFlowchart": "Flowchart",
    "dxDiagram-categoryOrgChart": "Org Chart",
    "dxDiagram-categoryContainers": "Containers",
    "dxDiagram-categoryCustom": "Custom",
    "dxDiagram-commandExportToSvg": "Export to SVG",
    "dxDiagram-commandExportToPng": "Export to PNG",
    "dxDiagram-commandExportToJpg": "Export to JPEG",
    "dxDiagram-commandUndo": "Undo",
    "dxDiagram-commandRedo": "Redo",
    "dxDiagram-commandFontName": "Font Name",
    "dxDiagram-commandFontSize": "Font Size",
    "dxDiagram-commandBold": "Bold",
    "dxDiagram-commandItalic": "Italic",
    "dxDiagram-commandUnderline": "Underline",
    "dxDiagram-commandTextColor": "Font Color",
    "dxDiagram-commandLineColor": "Line Color",
    "dxDiagram-commandLineWidth": "Line Width",
    "dxDiagram-commandLineStyle": "Line Style",
    "dxDiagram-commandLineStyleSolid": "Solid",
    "dxDiagram-commandLineStyleDotted": "Dotted",
    "dxDiagram-commandLineStyleDashed": "Dashed",
    "dxDiagram-commandFillColor": "Fill Color",
    "dxDiagram-commandAlignLeft": "Align Left",
    "dxDiagram-commandAlignCenter": "Align Center",
    "dxDiagram-commandAlignRight": "Align Right",
    "dxDiagram-commandConnectorLineType": "Connector Line Type",
    "dxDiagram-commandConnectorLineStraight": "Straight",
    "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
    "dxDiagram-commandConnectorLineStart": "Connector Line Start",
    "dxDiagram-commandConnectorLineEnd": "Connector Line End",
    "dxDiagram-commandConnectorLineNone": "None",
    "dxDiagram-commandConnectorLineArrow": "Arrow",
    "dxDiagram-commandFullscreen": "Full Screen",
    "dxDiagram-commandUnits": "Units",
    "dxDiagram-commandPageSize": "Page Size",
    "dxDiagram-commandPageOrientation": "Page Orientation",
    "dxDiagram-commandPageOrientationLandscape": "Landscape",
    "dxDiagram-commandPageOrientationPortrait": "Portrait",
    "dxDiagram-commandPageColor": "Page Color",
    "dxDiagram-commandShowGrid": "Show Grid",
    "dxDiagram-commandSnapToGrid": "Snap to Grid",
    "dxDiagram-commandGridSize": "Grid Size",
    "dxDiagram-commandZoomLevel": "Zoom Level",
    "dxDiagram-commandAutoZoom": "Auto Zoom",
    "dxDiagram-commandFitToContent": "Fit to Content",
    "dxDiagram-commandFitToWidth": "Fit to Width",
    "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
    "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
    "dxDiagram-commandSimpleView": "Simple View",
    "dxDiagram-commandCut": "Cut",
    "dxDiagram-commandCopy": "Copy",
    "dxDiagram-commandPaste": "Paste",
    "dxDiagram-commandSelectAll": "Select All",
    "dxDiagram-commandDelete": "Delete",
    "dxDiagram-commandBringToFront": "Bring to Front",
    "dxDiagram-commandSendToBack": "Send to Back",
    "dxDiagram-commandLock": "Lock",
    "dxDiagram-commandUnlock": "Unlock",
    "dxDiagram-commandInsertShapeImage": "Insert Image...",
    "dxDiagram-commandEditShapeImage": "Change Image...",
    "dxDiagram-commandDeleteShapeImage": "Delete Image",
    "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
    "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
    "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
    "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
    "dxDiagram-unitIn": "in",
    "dxDiagram-unitCm": "cm",
    "dxDiagram-unitPx": "px",
    "dxDiagram-dialogButtonOK": "OK",
    "dxDiagram-dialogButtonCancel": "Cancel",
    "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
    "dxDiagram-dialogEditShapeImageTitle": "Change Image",
    "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
    "dxDiagram-dialogEditShapeImageLabelText": "or drop a file here",
    "dxDiagram-uiExport": "Export",
    "dxDiagram-uiProperties": "Properties",
    "dxDiagram-uiSettings": "Settings",
    "dxDiagram-uiShowToolbox": "Show Toolbox",
    "dxDiagram-uiSearch": "Search",
    "dxDiagram-uiStyle": "Style",
    "dxDiagram-uiLayout": "Layout",
    "dxDiagram-uiLayoutTree": "Tree",
    "dxDiagram-uiLayoutLayered": "Layered",
    "dxDiagram-uiDiagram": "Diagram",
    "dxDiagram-uiText": "Text",
    "dxDiagram-uiObject": "Object",
    "dxDiagram-uiConnector": "Connector",
    "dxDiagram-uiPage": "Page",
    "dxDiagram-shapeText": "Text",
    "dxDiagram-shapeRectangle": "Rectangle",
    "dxDiagram-shapeEllipse": "Ellipse",
    "dxDiagram-shapeCross": "Cross",
    "dxDiagram-shapeTriangle": "Triangle",
    "dxDiagram-shapeDiamond": "Diamond",
    "dxDiagram-shapeHeart": "Heart",
    "dxDiagram-shapePentagon": "Pentagon",
    "dxDiagram-shapeHexagon": "Hexagon",
    "dxDiagram-shapeOctagon": "Octagon",
    "dxDiagram-shapeStar": "Star",
    "dxDiagram-shapeArrowLeft": "Left Arrow",
    "dxDiagram-shapeArrowUp": "Up Arrow",
    "dxDiagram-shapeArrowRight": "Right Arrow",
    "dxDiagram-shapeArrowDown": "Down Arrow",
    "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
    "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
    "dxDiagram-shapeProcess": "Process",
    "dxDiagram-shapeDecision": "Decision",
    "dxDiagram-shapeTerminator": "Terminator",
    "dxDiagram-shapePredefinedProcess": "Predefined Process",
    "dxDiagram-shapeDocument": "Document",
    "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
    "dxDiagram-shapeManualInput": "Manual Input",
    "dxDiagram-shapePreparation": "Preparation",
    "dxDiagram-shapeData": "Data",
    "dxDiagram-shapeDatabase": "Database",
    "dxDiagram-shapeHardDisk": "Hard Disk",
    "dxDiagram-shapeInternalStorage": "Internal Storage",
    "dxDiagram-shapePaperTape": "Paper Tape",
    "dxDiagram-shapeManualOperation": "Manual Operation",
    "dxDiagram-shapeDelay": "Delay",
    "dxDiagram-shapeStoredData": "Stored Data",
    "dxDiagram-shapeDisplay": "Display",
    "dxDiagram-shapeMerge": "Merge",
    "dxDiagram-shapeConnector": "Connector",
    "dxDiagram-shapeOr": "Or",
    "dxDiagram-shapeSummingJunction": "Summing Junction",
    "dxDiagram-shapeContainerDefaultText": "Container",
    "dxDiagram-shapeVerticalContainer": "Vertical Container",
    "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
    "dxDiagram-shapeCardDefaultText": "Person's Name",
    "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
    "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
    "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
    "dxGantt-dialogTitle": "Title",
    "dxGantt-dialogStartTitle": "Start",
    "dxGantt-dialogEndTitle": "End",
    "dxGantt-dialogProgressTitle": "Progress",
    "dxGantt-dialogResourcesTitle": "Resources",
    "dxGantt-dialogResourceManagerTitle": "Resource Manager",
    "dxGantt-dialogTaskDetailsTitle": "Task Details",
    "dxGantt-dialogEditResourceListHint": "Edit Resource List",
    "dxGantt-dialogEditNoResources": "No resources",
    "dxGantt-dialogButtonAdd": "Add",
    "dxGantt-contextMenuNewTask": "New Task",
    "dxGantt-contextMenuNewSubtask": "New Subtask",
    "dxGantt-contextMenuDeleteTask": "Delete Task",
    "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
    "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
    "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
    "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
    "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
    "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
    "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
    "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
    "dxGantt-dialogConstraintCriticalViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. How would you like to proceed?",
    "dxGantt-dialogDeleteDependenciesMessage": "Delete the dependency relations",
    "dxGantt-dialogMoveTaskAndKeepDependenciesMessage": "Move the task and keep the dependencies",
    "dxGantt-undo": "Undo",
    "dxGantt-redo": "Redo",
    "dxGantt-expandAll": "Expand All",
    "dxGantt-collapseAll": "Collapse All",
    "dxGantt-addNewTask": "Add New Task",
    "dxGantt-deleteSelectedTask": "Delete Selected Task",
    "dxGantt-zoomIn": "Zoom In",
    "dxGantt-zoomOut": "Zoom Out",
    "dxGantt-fullScreen": "Full Screen",
    "dxGantt-quarter": "Q{0}",
    "dxGantt-sortingAscendingText": "Sort Ascending",
    "dxGantt-sortingDescendingText": "Sort Descending",
    "dxGantt-sortingClearText": "Clear Sorting",
    "dxGantt-showResources": "Show Resources",
    "dxGantt-showDependencies": "Show Dependencies",
    "dxGantt-dialogStartDateValidation": "Start date must be after {0}",
    "dxGantt-dialogEndDateValidation": "End date must be after {0}",
    "dxGallery-itemName": "Gallery item",
    "dxMultiView-elementAriaRoleDescription": "MultiView",
    "dxMultiView-elementAriaLabel": "Use the arrow keys or swipe to navigate between views",
    "dxMultiView-itemAriaRoleDescription": "View",
    "dxMultiView-itemAriaLabel": "{0} of {1}",
    "dxSplitter-resizeHandleAriaLabel": "Split bar",
    "dxSplitter-resizeHandleAriaRoleDescription": "Separator",
    "dxStepper-optionalMark": "(Optional)"
  }
};

// node_modules/devextreme/esm/common/core/localization/message.js
var baseDictionary = extend(true, {}, defaultMessages);
var getDataByLocale = (localeData, locale) => {
  var _Object$entries$find;
  return localeData[locale] || (null === locale || void 0 === locale ? void 0 : locale.toLowerCase) && (null === (_Object$entries$find = Object.entries(localeData).find((_ref) => {
    let [key] = _ref;
    return key.toLowerCase() === locale.toLowerCase();
  })) || void 0 === _Object$entries$find ? void 0 : _Object$entries$find[1]) || {};
};
var newMessages = {};
var messageLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  _dictionary: baseDictionary,
  load: function(messages) {
    extend(true, this._dictionary, messages);
  },
  _localizablePrefix: "@",
  setup: function(localizablePrefix) {
    this._localizablePrefix = localizablePrefix;
  },
  localizeString: function(text) {
    const that = this;
    const regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g");
    const escapeString = that._localizablePrefix + that._localizablePrefix;
    return text.replace(regex, (str, prefix, escape, localizationKey) => {
      const defaultResult = that._localizablePrefix + localizationKey;
      let result2;
      if (escape !== escapeString) {
        result2 = that.format(localizationKey);
      }
      if (!result2) {
        newMessages[localizationKey] = humanize(localizationKey);
      }
      return prefix + (result2 || defaultResult);
    });
  },
  getMessagesByLocales: function() {
    return this._dictionary;
  },
  getDictionary: function(onlyNew) {
    if (onlyNew) {
      return newMessages;
    }
    return extend({}, newMessages, this.getMessagesByLocales()[core_default.locale()]);
  },
  getFormatter: function(key) {
    return this._getFormatterBase(key) || this._getFormatterBase(key, "en");
  },
  _getFormatterBase: function(key, locale) {
    const message = core_default.getValueByClosestLocale((locale2) => getDataByLocale(this._dictionary, locale2)[key]);
    if (message) {
      return function() {
        const args = 1 === arguments.length && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
        args.unshift(message);
        return format.apply(this, args);
      };
    }
  },
  format: function(key) {
    const formatter = this.getFormatter(key);
    const values = Array.prototype.slice.call(arguments, 1);
    return formatter && formatter.apply(this, values) || "";
  }
});
var message_default = messageLocalization;

// node_modules/devextreme/esm/__internal/core/templates/m_child_default_template.js
var ChildDefaultTemplate = class extends TemplateBase {
  constructor(name2) {
    super();
    this.name = name2;
  }
};

// node_modules/devextreme/esm/__internal/core/templates/m_empty_template.js
var EmptyTemplate = class extends TemplateBase {
  _renderCore() {
    return renderer_default();
  }
};

// node_modules/devextreme/esm/__internal/core/templates/m_template.js
registerTemplateEngine("default", {
  compile: (element) => normalizeTemplateElement(element),
  render: (template, model, index2) => template.clone()
});
setTemplateEngine("default");
var Template = class extends TemplateBase {
  constructor(element) {
    super();
    this._element = element;
  }
  _renderCore(options2) {
    const {
      transclude
    } = options2;
    if (!transclude && !this._compiledTemplate) {
      this._compiledTemplate = getCurrentTemplateEngine().compile(this._element);
    }
    return renderer_default("<div>").append(transclude ? this._element : getCurrentTemplateEngine().render(this._compiledTemplate, options2.model, options2.index)).contents();
  }
  source() {
    return renderer_default(this._element).clone();
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_array.js
function createOccurrenceMap(array) {
  return array.reduce((map2, value2) => {
    const count = (map2.get(value2) ?? 0) + 1;
    map2.set(value2, count);
    return map2;
  }, /* @__PURE__ */ new Map());
}
var wrapToArray = function(item) {
  return Array.isArray(item) ? item : [item];
};
var getUniqueValues = function(values) {
  return [...new Set(values)];
};
var removeDuplicates = function() {
  let from = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  let toRemove = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
  const toRemoveMap = createOccurrenceMap(toRemove);
  return from.filter((value2) => {
    const occurrencesCount = toRemoveMap.get(value2);
    occurrencesCount && toRemoveMap.set(value2, occurrencesCount - 1);
    return !occurrencesCount;
  });
};
var groupBy = (array, getGroupName) => array.reduce((groupedResult, item) => {
  const groupName = getGroupName(item);
  groupedResult[groupName] = groupedResult[groupName] ?? [];
  groupedResult[groupName].push(item);
  return groupedResult;
}, {});

// node_modules/devextreme/esm/__internal/core/utils/m_template_manager.js
var findTemplates = (element, name2) => {
  const templates = renderer_default(element).contents().filter(`[data-options*="${name2}"]`);
  return [].slice.call(templates).map((element2) => {
    const optionsString = renderer_default(element2).attr("data-options") || "";
    return {
      element: element2,
      options: config_default2().optionsParser(optionsString)[name2]
    };
  }).filter((template) => !!template.options);
};
var suitableTemplatesByName = (rawTemplates) => {
  const templatesMap = groupBy(rawTemplates, (template) => template.options.name);
  if (templatesMap.undefined) {
    throw errors_default.Error("E0023");
  }
  const result2 = {};
  Object.keys(templatesMap).forEach((name2) => {
    var _findBestMatches$;
    const suitableTemplate = null === (_findBestMatches$ = findBestMatches(devices_default.current(), templatesMap[name2], (template) => template.options)[0]) || void 0 === _findBestMatches$ ? void 0 : _findBestMatches$.element;
    if (suitableTemplate) {
      result2[name2] = suitableTemplate;
    }
  });
  return result2;
};
var addOneRenderedCall = (template) => {
  const render2 = template.render.bind(template);
  return extend({}, template, {
    render(options2) {
      const templateResult = render2(options2);
      options2 && options2.onRendered && options2.onRendered();
      return templateResult;
    }
  });
};
var addPublicElementNormalization = (template) => {
  const render2 = template.render.bind(template);
  return extend({}, template, {
    render(options2) {
      const $container = renderer_default(options2.container);
      return render2(_extends({}, options2, {
        container: getPublicElement($container)
      }));
    }
  });
};
var getNormalizedTemplateArgs = (options2) => {
  const args = [];
  if ("model" in options2) {
    args.push(options2.model);
  }
  if ("index" in options2) {
    args.push(options2.index);
  }
  args.push(options2.container);
  return args;
};
var validateTemplateSource = (templateSource) => "string" === typeof templateSource ? m_dom_default.normalizeTemplateElement(templateSource) : templateSource;
var templateKey = (templateSource) => m_type_default.isRenderer(templateSource) && templateSource[0] || templateSource;
var defaultCreateElement = (element) => new Template(element);
var acquireIntegrationTemplate = (templateSource, templates, isAsyncTemplate, skipTemplates) => {
  let integrationTemplate = null;
  if (!skipTemplates || -1 === skipTemplates.indexOf(templateSource)) {
    integrationTemplate = templates[templateSource];
    if (integrationTemplate && !(integrationTemplate instanceof TemplateBase)) {
      if (m_type_default.isFunction(integrationTemplate.render)) {
        integrationTemplate = addPublicElementNormalization(integrationTemplate);
      }
      if (!isAsyncTemplate) {
        integrationTemplate = addOneRenderedCall(integrationTemplate);
      }
    }
  }
  return integrationTemplate;
};
var acquireTemplate = (templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) => {
  if (null == templateSource) {
    return new EmptyTemplate();
  }
  if (templateSource instanceof ChildDefaultTemplate) {
    return defaultTemplates[templateSource.name];
  }
  if (templateSource instanceof TemplateBase) {
    return templateSource;
  }
  if (m_type_default.isFunction(templateSource.render) && !m_type_default.isRenderer(templateSource)) {
    return isAsyncTemplate ? templateSource : addOneRenderedCall(templateSource);
  }
  if (templateSource.nodeType || m_type_default.isRenderer(templateSource)) {
    return createTemplate(renderer_default(templateSource));
  }
  return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource);
};

// node_modules/devextreme/esm/__internal/ui/collection/m_data_controller.js
var DataControllerMock = {
  load: () => Deferred().reject(),
  loadSingle: () => Deferred().reject(),
  loadFromStore: () => Deferred().reject(),
  loadNextPage: () => Deferred().reject(),
  loadOptions: noop2,
  userData: noop2,
  cancel: noop2,
  cancelAll: noop2,
  filter: noop2,
  addSearchFilter: noop2,
  group: noop2,
  paginate: noop2,
  pageSize: noop2,
  pageIndex: noop2,
  resetDataSourcePageIndex: noop2,
  totalCount: noop2,
  isLastPage: noop2,
  isLoading: noop2,
  isLoaded: noop2,
  searchValue: noop2,
  searchOperation: noop2,
  searchExpr: noop2,
  select: noop2,
  key: noop2,
  keyOf: noop2,
  store: noop2,
  items: noop2,
  applyMapFunction: noop2,
  getDataSource: noop2,
  reload: noop2,
  on: noop2,
  off: noop2
};
var DataController = class {
  constructor(dataSource) {
    if (!dataSource) {
      return DataControllerMock;
    }
    this._dataSource = dataSource;
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (arguments.length < 2) {
      propValue = propName;
      propName = this.key();
    }
    return this._dataSource.loadSingle(propName, propValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value2) {
    if (!arguments.length) {
      return this._dataSource.searchValue();
    }
    return this._dataSource.searchValue(value2);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    if (!arguments.length) {
      return this._dataSource.searchExpr();
    }
    return this._dataSource.searchExpr(expr);
  }
  select() {
    return this._dataSource.select(...arguments);
  }
  key() {
    return this._dataSource.key();
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    return this._dataSource.items();
  }
  applyMapFunction(data2) {
    return this._dataSource._applyMapFunction(data2);
  }
  getDataSource() {
    return this._dataSource || null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
};
var m_data_controller_default = DataController;

// node_modules/devextreme/esm/__internal/data/m_data_helper.js
var DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
var SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
var DataHelperMixin = {
  postCtor() {
    this.on("disposing", () => {
      this._disposeDataSource();
    });
  },
  _refreshDataSource() {
    this._initDataSource();
    this._loadDataSource();
  },
  _initDataSource() {
    let dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
    let widgetDataSourceOptions;
    let dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = "_dataSourceOptions" in this ? this._dataSourceOptions() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
          fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
        });
        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  },
  _initDataController() {
    var _this$option;
    const dataController = null === (_this$option = this.option) || void 0 === _this$option ? void 0 : _this$option.call(this, "_dataController");
    const dataSource = this._dataSource;
    if (dataController) {
      this._dataController = dataController;
    } else {
      this._dataController = new m_data_controller_default(dataSource);
    }
  },
  _addDataSourceHandlers() {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }
    if ("_dataSourceLoadErrorHandler" in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if ("_dataSourceLoadingChangedHandler" in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  },
  _addReadyWatcher() {
    this.readyWatcher = (function(isLoading) {
      this._ready && this._ready(!isLoading);
    }).bind(this);
    this._dataSource.on("loadingChanged", this.readyWatcher);
  },
  _addDataSourceChangeHandler() {
    const dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = (function(e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }).bind(this);
    dataSource.on("changed", this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this);
    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this);
    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource() {
    const dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  },
  _loadSingle(key, value2) {
    key = "this" === key ? this._dataSource.key() || "this" : key;
    return this._dataSource.loadSingle(key, value2);
  },
  _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
        if (this._dataSource._eventsStrategy) {
          this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
        }
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  },
  getDataSource() {
    return this._dataSource || null;
  }
};

// node_modules/devextreme/esm/data_helper.js
var data_helper_default = DataHelperMixin;

// node_modules/devextreme/esm/__internal/events/core/m_emitter.feedback.js
var FeedbackEvent = class_default.inherit({
  ctor(timeout, fire) {
    this._timeout = timeout;
    this._fire = fire;
  },
  start() {
    const that = this;
    this._schedule(() => {
      that.force();
    });
  },
  _schedule(fn) {
    this.stop();
    this._timer = setTimeout(fn, this._timeout);
  },
  stop() {
    clearTimeout(this._timer);
  },
  force() {
    if (this._fired) {
      return;
    }
    this.stop();
    this._fire();
    this._fired = true;
  },
  fired() {
    return this._fired;
  }
});
var activeFeedback;
var FeedbackEmitter = m_emitter_default.inherit({
  ctor() {
    this.callBase.apply(this, arguments);
    this._active = new FeedbackEvent(0, noop2);
    this._inactive = new FeedbackEvent(0, noop2);
  },
  configure(data2, eventName) {
    switch (eventName) {
      case "dxactive":
        data2.activeTimeout = data2.timeout;
        break;
      case "dxinactive":
        data2.inactiveTimeout = data2.timeout;
    }
    this.callBase(data2);
  },
  start(e) {
    if (activeFeedback) {
      const activeChildExists = contains2(this.getElement().get(0), activeFeedback.getElement().get(0));
      const childJustActivated = !activeFeedback._active.fired();
      if (activeChildExists && childJustActivated) {
        this._cancel();
        return;
      }
      activeFeedback._inactive.force();
    }
    activeFeedback = this;
    this._initEvents(e);
    this._active.start();
  },
  _initEvents(e) {
    const that = this;
    const eventTarget = this._getEmitterTarget(e);
    const mouseEvent = isMouseEvent(e);
    const isSimulator = m_devices_default.isSimulator();
    const deferFeedback = isSimulator || !mouseEvent;
    const activeTimeout = ensureDefined(this.activeTimeout, 30);
    const inactiveTimeout = ensureDefined(this.inactiveTimeout, 400);
    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, () => {
      that._fireEvent("dxactive", e, {
        target: eventTarget
      });
    });
    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, () => {
      that._fireEvent("dxinactive", e, {
        target: eventTarget
      });
      activeFeedback = null;
    });
  },
  cancel(e) {
    this.end(e);
  },
  end(e) {
    const skipTimers = e.type !== m_pointer_default.up;
    if (skipTimers) {
      this._active.stop();
    } else {
      this._active.force();
    }
    this._inactive.start();
    if (skipTimers) {
      this._inactive.force();
    }
  },
  dispose() {
    this._active.stop();
    this._inactive.stop();
    if (activeFeedback === this) {
      activeFeedback = null;
    }
    this.callBase();
  },
  lockInactive() {
    this._active.force();
    this._inactive.stop();
    activeFeedback = null;
    this._cancel();
    return this._inactive.force.bind(this._inactive);
  }
});
FeedbackEmitter.lock = function(deferred) {
  const lockInactive = activeFeedback ? activeFeedback.lockInactive() : noop2;
  deferred.done(lockInactive);
};
m_emitter_registrator_default({
  emitter: FeedbackEmitter,
  events: ["dxactive", "dxinactive"]
});
var {
  lock
} = FeedbackEmitter;

// node_modules/devextreme/esm/__internal/events/m_hover.js
var HOVERSTART = "dxhoverstart";
var POINTERENTER_NAMESPACED_EVENT_NAME = addNamespace2(m_pointer_default.enter, "dxHoverStart");
var HOVEREND = "dxhoverend";
var POINTERLEAVE_NAMESPACED_EVENT_NAME = addNamespace2(m_pointer_default.leave, "dxHoverEnd");
var Hover = class_default.inherit({
  noBubble: true,
  ctor() {
    this._handlerArrayKeyPath = `${this._eventNamespace}_HandlerStore`;
  },
  setup(element) {
    data(element, this._handlerArrayKeyPath, {});
  },
  add(element, handleObj) {
    const that = this;
    const handler = function(e) {
      that._handler(e);
    };
    m_events_engine_default.on(element, this._originalEventName, handleObj.selector, handler);
    data(element, this._handlerArrayKeyPath)[handleObj.guid] = handler;
  },
  _handler(e) {
    if (isTouchEvent(e) || m_devices_default.isSimulator()) {
      return;
    }
    fireEvent({
      type: this._eventName,
      originalEvent: e,
      delegateTarget: e.delegateTarget
    });
  },
  remove(element, handleObj) {
    const handler = data(element, this._handlerArrayKeyPath)[handleObj.guid];
    m_events_engine_default.off(element, this._originalEventName, handleObj.selector, handler);
  },
  teardown(element) {
    removeData(element, this._handlerArrayKeyPath);
  }
});
var HoverStart = Hover.inherit({
  ctor() {
    this._eventNamespace = "dxHoverStart";
    this._eventName = HOVERSTART;
    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
    this.callBase();
  },
  _handler(e) {
    const pointers = e.pointers || [];
    if (!pointers.length) {
      this.callBase(e);
    }
  }
});
var HoverEnd = Hover.inherit({
  ctor() {
    this._eventNamespace = "dxHoverEnd";
    this._eventName = HOVEREND;
    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
    this.callBase();
  }
});
m_event_registrator_default(HOVERSTART, new HoverStart());
m_event_registrator_default(HOVEREND, new HoverEnd());

// node_modules/devextreme/esm/__internal/events/core/m_keyboard_processor.js
var NAMESPACE = "KeyboardProcessor";
var createKeyDownOptions = (e) => ({
  keyName: normalizeKeyName(e),
  key: e.key,
  code: e.code,
  ctrl: e.ctrlKey,
  location: e.location,
  metaKey: e.metaKey,
  shift: e.shiftKey,
  alt: e.altKey,
  which: e.which,
  originalEvent: e
});
var KeyboardProcessor = class_default.inherit({
  _keydown: addNamespace2("keydown", NAMESPACE),
  _compositionStart: addNamespace2("compositionstart", NAMESPACE),
  _compositionEnd: addNamespace2("compositionend", NAMESPACE),
  ctor(options2) {
    options2 = options2 || {};
    if (options2.element) {
      this._element = renderer_default(options2.element);
    }
    if (options2.focusTarget) {
      this._focusTarget = options2.focusTarget;
    }
    this._handler = options2.handler;
    if (this._element) {
      this._processFunction = (e) => {
        const focusTargets = renderer_default(this._focusTarget).toArray();
        const isNotFocusTarget = this._focusTarget && this._focusTarget !== e.target && !focusTargets.includes(e.target);
        const shouldSkipProcessing = this._isComposingJustFinished && 229 === e.which || this._isComposing || isNotFocusTarget;
        this._isComposingJustFinished = false;
        if (!shouldSkipProcessing) {
          this.process(e);
        }
      };
      this._toggleProcessingWithContext = this.toggleProcessing.bind(this);
      m_events_engine_default.on(this._element, this._keydown, this._processFunction);
      m_events_engine_default.on(this._element, this._compositionStart, this._toggleProcessingWithContext);
      m_events_engine_default.on(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
  },
  dispose() {
    if (this._element) {
      m_events_engine_default.off(this._element, this._keydown, this._processFunction);
      m_events_engine_default.off(this._element, this._compositionStart, this._toggleProcessingWithContext);
      m_events_engine_default.off(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
    this._element = void 0;
    this._handler = void 0;
  },
  process(e) {
    this._handler(createKeyDownOptions(e));
  },
  toggleProcessing(_ref) {
    let {
      type: type2
    } = _ref;
    this._isComposing = "compositionstart" === type2;
    this._isComposingJustFinished = !this._isComposing;
  }
});
KeyboardProcessor.createKeyDownOptions = createKeyDownOptions;
var m_keyboard_processor_default = KeyboardProcessor;

// node_modules/devextreme/esm/__internal/events/m_short.js
function addNamespace3(event, namespace) {
  return namespace ? addNamespace2(event, namespace) : event;
}
function executeAction(action, args) {
  return "function" === typeof action ? action(args) : action.execute(args);
}
var active = {
  on: ($el, active2, inactive, opts) => {
    const {
      selector,
      showTimeout,
      hideTimeout,
      namespace
    } = opts;
    m_events_engine_default.on($el, addNamespace3("dxactive", namespace), selector, {
      timeout: showTimeout
    }, (event) => executeAction(active2, {
      event,
      element: event.currentTarget
    }));
    m_events_engine_default.on($el, addNamespace3("dxinactive", namespace), selector, {
      timeout: hideTimeout
    }, (event) => executeAction(inactive, {
      event,
      element: event.currentTarget
    }));
  },
  off: ($el, _ref) => {
    let {
      namespace,
      selector
    } = _ref;
    m_events_engine_default.off($el, addNamespace3("dxactive", namespace), selector);
    m_events_engine_default.off($el, addNamespace3("dxinactive", namespace), selector);
  }
};
var resize = {
  on: function($el, resize2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    m_events_engine_default.on($el, addNamespace3("dxresize", namespace), resize2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    m_events_engine_default.off($el, addNamespace3("dxresize", namespace));
  }
};
var hover = {
  on: ($el, start, end, _ref2) => {
    let {
      selector,
      namespace
    } = _ref2;
    m_events_engine_default.on($el, addNamespace3("dxhoverend", namespace), selector, (event) => end(event));
    m_events_engine_default.on($el, addNamespace3("dxhoverstart", namespace), selector, (event) => executeAction(start, {
      element: event.target,
      event
    }));
  },
  off: ($el, _ref3) => {
    let {
      selector,
      namespace
    } = _ref3;
    m_events_engine_default.off($el, addNamespace3("dxhoverstart", namespace), selector);
    m_events_engine_default.off($el, addNamespace3("dxhoverend", namespace), selector);
  }
};
var visibility = {
  on: ($el, shown, hiding, _ref4) => {
    let {
      namespace
    } = _ref4;
    m_events_engine_default.on($el, addNamespace3("dxhiding", namespace), hiding);
    m_events_engine_default.on($el, addNamespace3("dxshown", namespace), shown);
  },
  off: ($el, _ref5) => {
    let {
      namespace
    } = _ref5;
    m_events_engine_default.off($el, addNamespace3("dxhiding", namespace));
    m_events_engine_default.off($el, addNamespace3("dxshown", namespace));
  }
};
var focus = {
  on: ($el, focusIn, focusOut, _ref6) => {
    let {
      namespace
    } = _ref6;
    m_events_engine_default.on($el, addNamespace3("focusin", namespace), focusIn);
    m_events_engine_default.on($el, addNamespace3("focusout", namespace), focusOut);
  },
  off: ($el, _ref7) => {
    let {
      namespace
    } = _ref7;
    m_events_engine_default.off($el, addNamespace3("focusin", namespace));
    m_events_engine_default.off($el, addNamespace3("focusout", namespace));
  },
  trigger: ($el) => m_events_engine_default.trigger($el, "focus")
};
var dxClick = {
  on: function($el, click2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    m_events_engine_default.on($el, addNamespace3("dxclick", namespace), click2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    m_events_engine_default.off($el, addNamespace3("dxclick", namespace));
  }
};
var click = {
  on: function($el, click2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    m_events_engine_default.on($el, addNamespace3("click", namespace), click2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    m_events_engine_default.off($el, addNamespace3("click", namespace));
  }
};
var index = 0;
var keyboardProcessors = {};
var generateListenerId = () => "keyboardProcessorId" + index++;
var keyboard = {
  on: (element, focusTarget, handler) => {
    const listenerId = generateListenerId();
    keyboardProcessors[listenerId] = new m_keyboard_processor_default({
      element,
      focusTarget,
      handler
    });
    return listenerId;
  },
  off: (listenerId) => {
    if (listenerId && keyboardProcessors[listenerId]) {
      keyboardProcessors[listenerId].dispose();
      delete keyboardProcessors[listenerId];
    }
  },
  _getProcessor: (listenerId) => keyboardProcessors[listenerId]
};

// node_modules/devextreme/esm/__internal/core/utils/m_version.js
function compare(x, y, maxLevel) {
  function normalizeArg(value2) {
    if ("string" === typeof value2) {
      return value2.split(".");
    }
    if ("number" === typeof value2) {
      return [value2];
    }
    return value2;
  }
  x = normalizeArg(x);
  y = normalizeArg(y);
  let length = Math.max(x.length, y.length);
  if (isFinite(maxLevel)) {
    length = Math.min(length, maxLevel);
  }
  for (let i = 0; i < length; i++) {
    const xItem = parseInt(x[i] || 0, 10);
    const yItem = parseInt(y[i] || 0, 10);
    if (xItem < yItem) {
      return -1;
    }
    if (xItem > yItem) {
      return 1;
    }
  }
  return 0;
}

// node_modules/devextreme/esm/__internal/utils/version.js
var assertedVersions = [];
function stringifyVersion(version2) {
  const {
    major,
    minor,
    patch: patch2
  } = version2;
  return [major, minor, patch2].join(".");
}
function parseVersion(version2) {
  const [major, minor, patch2] = version2.split(".").map(Number);
  return {
    major,
    minor,
    patch: patch2
  };
}
function stringifyVersionList(assertedVersionList) {
  return assertedVersionList.map((assertedVersion) => `${assertedVersion.packageName}: ${assertedVersion.version}`).join("\n");
}
function versionsEqual(versionA, versionB) {
  return versionA.major === versionB.major && versionA.minor === versionB.minor && versionA.patch === versionB.patch;
}
function getPreviousMajorVersion(_ref) {
  let {
    major,
    minor,
    patch: patch2
  } = _ref;
  const previousMajorVersion = 1 === minor ? {
    major: major - 1,
    minor: 2,
    patch: patch2
  } : {
    major,
    minor: minor - 1,
    patch: patch2
  };
  return previousMajorVersion;
}
function assertedVersionsCompatible(currentVersion) {
  const mismatchingVersions = assertedVersions.filter((assertedVersion) => !versionsEqual(parseVersion(assertedVersion.version), currentVersion));
  if (mismatchingVersions.length) {
    errors_default.log("W0023", stringifyVersionList([{
      packageName: "devextreme",
      version: stringifyVersion(currentVersion)
    }, ...mismatchingVersions]));
    return false;
  }
  return true;
}

// node_modules/devextreme/esm/__internal/core/license/byte_utils.js
function base64ToBytes(base64) {
  return new Uint8Array(atob(base64).split("").map((s) => s.charCodeAt(0)));
}
function hexToBytes(string) {
  var _string$match;
  return new Uint8Array((null === (_string$match = string.match(/.{1,2}/g)) || void 0 === _string$match ? void 0 : _string$match.map((byte) => parseInt(byte, 16))) ?? []);
}
function stringToBytes(string) {
  const bytes = new Uint8Array(string.length);
  for (let k = 0; k < string.length; k += 1) {
    bytes[k] = 255 & string.charCodeAt(k);
  }
  return bytes;
}
function wordsToBytes(words) {
  const bytes = new Uint8Array(4 * words.length);
  for (let k = 0; k < bytes.length; k += 1) {
    bytes[k] = words[k >> 2] >>> 8 * (3 - k % 4);
  }
  return bytes;
}
function bytesToWords(bytes) {
  const words = new Uint32Array(1 + (bytes.length - 1 >> 2));
  for (let k = 0; k < bytes.length; k += 1) {
    words[k >> 2] |= bytes[k] << 8 * (3 - k % 4);
  }
  return words;
}
function leftRotate(x, n) {
  return (x << n | x >>> 32 - n) >>> 0;
}
function concatBytes(a, b) {
  const result2 = new Uint8Array(a.length + b.length);
  result2.set(a, 0);
  result2.set(b, a.length);
  return result2;
}

// node_modules/devextreme/esm/__internal/core/license/key.js
var PUBLIC_KEY = {
  e: 65537,
  n: new Uint8Array([200, 219, 153, 203, 140, 7, 228, 253, 193, 243, 62, 137, 139, 60, 68, 242, 48, 142, 113, 88, 185, 235, 253, 105, 80, 74, 32, 170, 96, 74, 111, 250, 7, 205, 154, 3, 146, 115, 153, 53, 45, 132, 123, 56, 61, 208, 184, 201, 63, 24, 109, 223, 0, 179, 169, 102, 139, 224, 73, 233, 45, 173, 138, 66, 98, 88, 69, 76, 177, 111, 113, 218, 192, 33, 101, 152, 25, 134, 34, 173, 32, 82, 230, 44, 247, 200, 253, 170, 192, 246, 30, 12, 96, 205, 100, 249, 181, 93, 0, 231])
};
var INTERNAL_USAGE_ID = "V2QpQmJVXWy6Nexkq9Xk9o";

// node_modules/devextreme/esm/__internal/core/license/pkcs1.js
var ASN1_SHA1 = "3021300906052b0e03021a05000414";
function pad(hash) {
  const dataLength = (8 * PUBLIC_KEY.n.length + 6) / 8;
  const data2 = concatBytes(hexToBytes(ASN1_SHA1), hash);
  if (data2.length + 10 > dataLength) {
    throw Error("Key is too short for SHA1 signing algorithm");
  }
  const padding = new Uint8Array(dataLength - data2.length);
  padding.fill(255, 0, padding.length - 1);
  padding[0] = 0;
  padding[1] = 1;
  padding[padding.length - 1] = 0;
  return concatBytes(padding, data2);
}

// node_modules/devextreme/esm/__internal/core/license/rsa_bigint.js
function compareSignatures(args) {
  try {
    const zero = BigInt(0);
    const one2 = BigInt(1);
    const eight = BigInt(8);
    const modExp = (base2, exponent2, modulus2) => {
      let result2 = one2;
      let b = base2;
      let e = exponent2;
      while (e) {
        if (e & one2) {
          result2 = result2 * b % modulus2;
        }
        b = b * b % modulus2;
        e >>= one2;
      }
      return result2;
    };
    const bigIntFromBytes = (bytes) => bytes.reduce((acc, cur) => (acc << eight) + BigInt(cur), zero);
    const actual = bigIntFromBytes(args.actual);
    const signature = bigIntFromBytes(args.signature);
    const exponent = BigInt(args.key.e);
    const modulus = bigIntFromBytes(args.key.n);
    const expected = modExp(signature, exponent, modulus);
    return expected === actual;
  } catch {
    return true;
  }
}

// node_modules/devextreme/esm/__internal/core/license/sha1.js
function preprocess(text) {
  const bytes = new Uint8Array(text.length + 1);
  bytes.set(stringToBytes(text));
  bytes[bytes.length - 1] = 128;
  const words = bytesToWords(new Uint8Array(bytes));
  const result2 = new Uint32Array(16 * Math.ceil((words.length + 2) / 16));
  result2.set(words, 0);
  result2[result2.length - 1] = 8 * (bytes.length - 1);
  return result2;
}
function sha1(text) {
  const message = preprocess(text);
  const h = new Uint32Array([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
  for (let i = 0; i < message.length; i += 16) {
    const w = new Uint32Array(80);
    for (let j = 0; j < 16; j += 1) {
      w[j] = message[i + j];
    }
    for (let j = 16; j < 80; j += 1) {
      const n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
      w[j] = n << 1 | n >>> 31;
    }
    let a = h[0];
    let b = h[1];
    let c = h[2];
    let d = h[3];
    let e = h[4];
    for (let j = 0; j < 80; j += 1) {
      const [f, k] = j < 20 ? [b & c | ~b & d, 1518500249] : j < 40 ? [b ^ c ^ d, 1859775393] : j < 60 ? [b & c | b & d | c & d, 2400959708] : [b ^ c ^ d, 3395469782];
      const temp = leftRotate(a, 5) + f + e + k + w[j];
      e = d;
      d = c;
      c = leftRotate(b, 30);
      b = a;
      a = temp;
    }
    h[0] += a;
    h[1] += b;
    h[2] += c;
    h[3] += d;
    h[4] += e;
  }
  return wordsToBytes(h);
}

// node_modules/devextreme/esm/__internal/core/license/trial_panel.client.js
var isClient = () => "undefined" !== typeof HTMLElement && "undefined" !== typeof customElements;
var SafeHTMLElement = isClient() ? HTMLElement : class {
};
var componentNames2 = {
  trigger: "dx-license-trigger",
  panel: "dx-license"
};
var attributeNames = {
  buyNow: "buy-now",
  licensingDoc: "licensing-doc",
  version: "version"
};
var commonStyles = {
  opacity: "1",
  visibility: "visible",
  "clip-path": "none",
  filter: "none"
};
var contentStyles = _extends({}, commonStyles, {
  width: "100%",
  height: "auto",
  "line-height": "normal",
  display: "block",
  "z-index": "1500",
  position: "static",
  transform: "translate(0px, 0px)",
  "background-color": "#FF7200",
  border: "none",
  margin: "auto",
  "box-sizing": "border-box",
  "text-align": "center"
});
var containerStyles = _extends({}, contentStyles, {
  display: "flex",
  "align-items": "center",
  "flex-direction": "row",
  position: "relative",
  top: "0px",
  left: "0px",
  padding: "0.5rem"
});
var buttonStyles = {
  width: "1rem",
  cursor: "pointer",
  height: "1rem"
};
var textStyles = _extends({}, commonStyles, {
  display: "inline",
  position: "static",
  padding: "0px",
  margin: "0px",
  color: "white",
  "font-family": "'Segoe UI','Open Sans Condensed',-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,Cantarell,Ubuntu,roboto,noto,arial,sans-serif",
  "font-size": "0.875rem",
  "font-wight": "600"
});
function createImportantStyles(defaultStyles, customStyles) {
  const styles = customStyles ? _extends({}, defaultStyles, customStyles) : defaultStyles;
  return Object.keys(styles).reduce((cssString, currentKey) => `${cssString}${[currentKey, `${styles[currentKey]} !important;`].join(": ")}`, "");
}
var DxLicense = class _DxLicense extends SafeHTMLElement {
  constructor() {
    var _DxLicense$customStyl, _DxLicense$customStyl2, _DxLicense$customStyl3, _DxLicense$customStyl4, _DxLicense$customStyl5;
    super();
    this._observer = null;
    this._inReassign = false;
    this._spanStyles = createImportantStyles(textStyles, null === (_DxLicense$customStyl = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl ? void 0 : _DxLicense$customStyl.textStyles);
    this._linkStyles = createImportantStyles(textStyles, null === (_DxLicense$customStyl2 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl2 ? void 0 : _DxLicense$customStyl2.linkStyles);
    this._containerStyles = createImportantStyles(containerStyles, null === (_DxLicense$customStyl3 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl3 ? void 0 : _DxLicense$customStyl3.containerStyles);
    this._contentStyles = createImportantStyles(contentStyles, null === (_DxLicense$customStyl4 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl4 ? void 0 : _DxLicense$customStyl4.contentStyles);
    this._buttonStyles = createImportantStyles(buttonStyles, null === (_DxLicense$customStyl5 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl5 ? void 0 : _DxLicense$customStyl5.contentStyles);
  }
  _createSpan(text) {
    const span = document.createElement("span");
    span.innerText = text;
    span.style.cssText = this._spanStyles;
    return span;
  }
  _createLink(text, href) {
    const link = document.createElement("a");
    link.innerText = text;
    link.style.cssText = this._linkStyles;
    link.href = href;
    link.target = "_blank";
    return link;
  }
  _createButton() {
    const button = document.createElement("div");
    button.style.cssText = this._buttonStyles;
    const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    polygon.setAttribute("points", "13.4 12.7 8.7 8 13.4 3.4 12.6 2.6 8 7.3 3.4 2.6 2.6 3.4 7.3 8 2.6 12.6 3.4 13.4 8 8.7 12.7 13.4 13.4 12.7");
    polygon.style.cssText = createImportantStyles({
      fill: "#fff",
      opacity: ".5",
      "stroke-width": "0px"
    });
    svg.setAttribute("id", "Layer_1");
    svg.setAttribute("data-name", "Layer 1");
    svg.setAttribute("version", "1.1");
    svg.setAttribute("viewBox", "0 0 16 16");
    svg.style.cssText = createImportantStyles({
      "vertical-align": "baseline"
    });
    svg.appendChild(polygon);
    button.appendChild(svg);
    button.onclick = () => {
      _DxLicense.closed = true;
      this.style.cssText = createImportantStyles({
        display: "none"
      });
    };
    return button;
  }
  _createContentContainer() {
    const contentContainer = document.createElement("div");
    contentContainer.style.cssText = this._contentStyles;
    contentContainer.append(this._createSpan("For evaluation purposes only. Redistribution prohibited. Please "), this._createLink("register", this.getAttribute(attributeNames.licensingDoc)), this._createSpan(" an existing license or "), this._createLink("purchase a new license", this.getAttribute(attributeNames.buyNow)), this._createSpan(` to continue use of DevExpress product libraries (v${this.getAttribute(attributeNames.version)}).`));
    return contentContainer;
  }
  _reassignComponent() {
    this.innerHTML = "";
    this.style.cssText = this._containerStyles;
    this.append(this._createContentContainer(), this._createButton());
  }
  connectedCallback() {
    this._reassignComponent();
    if (!this._observer) {
      this._observer = new MutationObserver(() => {
        if (_DxLicense.closed) {
          var _this$_observer;
          null === (_this$_observer = this._observer) || void 0 === _this$_observer || _this$_observer.disconnect();
          return;
        }
        if (this._inReassign) {
          this._inReassign = false;
        } else {
          this._inReassign = true;
          this._reassignComponent();
        }
      });
      this._observer.observe(this, {
        childList: true,
        attributes: true,
        subtree: true
      });
    }
  }
  disconnectedCallback() {
    if (_DxLicense.closed) {
      return;
    }
    Promise.resolve().then(() => {
      if (!document) {
        return;
      }
      const licensePanel = document.getElementsByTagName(componentNames2.panel);
      if (!licensePanel.length) {
        document.body.prepend(this);
      }
    });
  }
};
DxLicense.customStyles = void 0;
DxLicense.closed = false;
var DxLicenseTrigger = class extends SafeHTMLElement {
  connectedCallback() {
    this.style.cssText = createImportantStyles({
      display: "none"
    });
    const licensePanel = document.getElementsByTagName(componentNames2.panel);
    if (!licensePanel.length && !DxLicense.closed) {
      const license = document.createElement(componentNames2.panel);
      license.setAttribute(attributeNames.version, this.getAttribute(attributeNames.version));
      license.setAttribute(attributeNames.buyNow, this.getAttribute(attributeNames.buyNow));
      license.setAttribute(attributeNames.licensingDoc, this.getAttribute(attributeNames.licensingDoc));
      license.setAttribute("data-permanent", "");
      document.body.prepend(license);
    }
  }
};
function registerCustomComponents(customStyles) {
  if (!customElements.get(componentNames2.trigger)) {
    DxLicense.customStyles = customStyles;
    customElements.define(componentNames2.trigger, DxLicenseTrigger);
    customElements.define(componentNames2.panel, DxLicense);
  }
}
function renderTrialPanel(buyNowUrl, licensingDocUrl, version2, customStyles) {
  registerCustomComponents(customStyles);
  const trialPanelTrigger = document.createElement(componentNames2.trigger);
  trialPanelTrigger.setAttribute(attributeNames.buyNow, buyNowUrl);
  trialPanelTrigger.setAttribute(attributeNames.licensingDoc, licensingDocUrl);
  trialPanelTrigger.setAttribute(attributeNames.version, version2);
  document.body.appendChild(trialPanelTrigger);
}

// node_modules/devextreme/esm/__internal/core/license/trial_panel.js
function showTrialPanel(buyNowUrl, licensingDocUrl, version2, customStyles) {
  if (isClient()) {
    renderTrialPanel(buyNowUrl, licensingDocUrl, version2, customStyles);
  }
}

// node_modules/devextreme/esm/__internal/core/license/types.js
var TokenKind;
!function(TokenKind2) {
  TokenKind2.corrupted = "corrupted";
  TokenKind2.verified = "verified";
  TokenKind2.internal = "internal";
}(TokenKind || (TokenKind = {}));

// node_modules/devextreme/esm/__internal/core/license/license_validation.js
var _excluded2 = ["customerId", "maxVersionAllowed", "format", "internalUsageId"];
var BUY_NOW_LINK = "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeJQuery.aspx";
var LICENSING_DOC_LINK = "https://go.devexpress.com/Licensing_Documentation_DevExtremeJQuery.aspx";
var GENERAL_ERROR = {
  kind: TokenKind.corrupted,
  error: "general"
};
var VERIFICATION_ERROR = {
  kind: TokenKind.corrupted,
  error: "verification"
};
var DECODING_ERROR = {
  kind: TokenKind.corrupted,
  error: "decoding"
};
var DESERIALIZATION_ERROR = {
  kind: TokenKind.corrupted,
  error: "deserialization"
};
var PAYLOAD_ERROR = {
  kind: TokenKind.corrupted,
  error: "payload"
};
var VERSION_ERROR = {
  kind: TokenKind.corrupted,
  error: "version"
};
var validationPerformed = false;
function verifySignature(_ref) {
  let {
    text,
    signature: encodedSignature
  } = _ref;
  return compareSignatures({
    key: PUBLIC_KEY,
    signature: base64ToBytes(encodedSignature),
    actual: pad(sha1(text))
  });
}
function parseLicenseKey(encodedKey) {
  if (void 0 === encodedKey) {
    return GENERAL_ERROR;
  }
  const parts = encodedKey.split(".");
  if (2 !== parts.length || 0 === parts[0].length || 0 === parts[1].length) {
    return GENERAL_ERROR;
  }
  if (!verifySignature({
    text: parts[0],
    signature: parts[1]
  })) {
    return VERIFICATION_ERROR;
  }
  let decodedPayload = "";
  try {
    decodedPayload = atob(parts[0]);
  } catch {
    return DECODING_ERROR;
  }
  let payload = {};
  try {
    payload = JSON.parse(decodedPayload);
  } catch {
    return DESERIALIZATION_ERROR;
  }
  const {
    customerId,
    maxVersionAllowed,
    format: format2,
    internalUsageId
  } = payload, rest = _objectWithoutPropertiesLoose(payload, _excluded2);
  if (void 0 !== internalUsageId) {
    return {
      kind: TokenKind.internal,
      internalUsageId
    };
  }
  if (void 0 === customerId || void 0 === maxVersionAllowed || void 0 === format2) {
    return PAYLOAD_ERROR;
  }
  if (1 !== format2) {
    return VERSION_ERROR;
  }
  return {
    kind: TokenKind.verified,
    payload: _extends({
      customerId,
      maxVersionAllowed
    }, rest)
  };
}
function isPreview(patch2) {
  return isNaN(patch2) || patch2 < 3;
}
function getLicenseCheckParams(_ref2) {
  let {
    licenseKey,
    version: version2
  } = _ref2;
  let preview = false;
  try {
    preview = isPreview(version2.patch);
    const {
      major,
      minor
    } = preview ? getPreviousMajorVersion(version2) : version2;
    if (!licenseKey) {
      return {
        preview,
        error: "W0019"
      };
    }
    const license = parseLicenseKey(licenseKey);
    if (license.kind === TokenKind.corrupted) {
      return {
        preview,
        error: "W0021"
      };
    }
    if (license.kind === TokenKind.internal) {
      return {
        preview,
        internal: true,
        error: license.internalUsageId === INTERNAL_USAGE_ID ? void 0 : "W0020"
      };
    }
    if (!(major && minor)) {
      return {
        preview,
        error: "W0021"
      };
    }
    if (10 * major + minor > license.payload.maxVersionAllowed) {
      return {
        preview,
        error: "W0020"
      };
    }
    return {
      preview,
      error: void 0
    };
  } catch {
    return {
      preview,
      error: "W0021"
    };
  }
}
function validateLicense(licenseKey) {
  let versionStr = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : fullVersion;
  if (validationPerformed) {
    return;
  }
  validationPerformed = true;
  const version2 = parseVersion(versionStr);
  const versionsCompatible = assertedVersionsCompatible(version2);
  const {
    internal,
    error: error2
  } = getLicenseCheckParams({
    licenseKey,
    version: version2
  });
  if (!versionsCompatible && internal) {
    return;
  }
  if (error2 && !internal) {
    const buyNowLink = config_default2().buyNowLink ?? BUY_NOW_LINK;
    const licensingDocLink = config_default2().licensingDocLink ?? LICENSING_DOC_LINK;
    showTrialPanel(buyNowLink, licensingDocLink, fullVersion);
  }
  const preview = isPreview(version2.patch);
  if (error2) {
    errors_default.log(preview ? "W0022" : error2);
    return;
  }
  if (preview && !internal) {
    errors_default.log("W0022");
  }
}
function peekValidationPerformed() {
  return validationPerformed;
}
var license_validation_default = {
  validateLicense
};

// node_modules/devextreme/esm/__internal/core/templates/m_function_template.js
var FunctionTemplate = class extends TemplateBase {
  constructor(render2) {
    super();
    this._render = render2;
  }
  _renderCore(options2) {
    return normalizeTemplateElement(this._render(options2));
  }
};

// node_modules/devextreme/esm/__internal/core/m_template_manager.js
var DX_POLYMORPH_WIDGET_TEMPLATE = new FunctionTemplate((_ref) => {
  let {
    model,
    parent
  } = _ref;
  const widgetName = model.widget;
  if (!widgetName) {
    return renderer_default();
  }
  const widgetElement = renderer_default("<div>");
  const widgetOptions = model.options || {};
  if (parent) {
    parent._createComponent(widgetElement, widgetName, widgetOptions);
  } else {
    widgetElement[widgetName](widgetOptions);
  }
  return widgetElement;
});
var TemplateManager = class {
  constructor(createElement10, anonymousTemplateName) {
    this._tempTemplates = [];
    this._defaultTemplates = {};
    this._anonymousTemplateName = anonymousTemplateName || "template";
    this._createElement = createElement10 || defaultCreateElement;
    this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
  }
  static createDefaultOptions() {
    return {
      integrationOptions: {
        watchMethod: function(fn, callback) {
          let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          if (!options2.skipImmediate) {
            callback(fn());
          }
          return noop2;
        },
        templates: {
          "dx-polymorph-widget": DX_POLYMORPH_WIDGET_TEMPLATE
        },
        useDeferUpdateForTemplates: true
      }
    };
  }
  get anonymousTemplateName() {
    return this._anonymousTemplateName;
  }
  addDefaultTemplates(templates) {
    this._defaultTemplates = extend({}, this._defaultTemplates, templates);
  }
  dispose() {
    this._tempTemplates.forEach((tempTemplate) => {
      tempTemplate.template.dispose && tempTemplate.template.dispose();
    });
    this._tempTemplates = [];
  }
  extractTemplates($el) {
    const templates = this._extractTemplates($el);
    const anonymousTemplateMeta = this._extractAnonymousTemplate($el);
    return {
      templates,
      anonymousTemplateMeta
    };
  }
  _extractTemplates($el) {
    const templates = findTemplates($el, "dxTemplate");
    const suitableTemplates = suitableTemplatesByName(templates);
    templates.forEach((_ref2) => {
      let {
        element,
        options: {
          name: name2
        }
      } = _ref2;
      if (element === suitableTemplates[name2]) {
        renderer_default(element).addClass("dx-template-wrapper").detach();
      } else {
        renderer_default(element).remove();
      }
    });
    return Object.keys(suitableTemplates).map((name2) => ({
      name: name2,
      template: this._createTemplate(suitableTemplates[name2])
    }));
  }
  _extractAnonymousTemplate($el) {
    const $anonymousTemplate = $el.contents().detach();
    const $notJunkTemplateContent = $anonymousTemplate.filter((_, element) => {
      const isTextNode = 3 === element.nodeType;
      const isEmptyText = renderer_default(element).text().trim().length < 1;
      return !(isTextNode && isEmptyText);
    });
    return $notJunkTemplateContent.length > 0 ? {
      template: this._createTemplate($anonymousTemplate),
      name: this._anonymousTemplateName
    } : {};
  }
  _createTemplateIfNeeded(templateSource) {
    const cachedTemplate = this._tempTemplates.filter((tempTemplate) => tempTemplate.source === templateKey(templateSource))[0];
    if (cachedTemplate) {
      return cachedTemplate.template;
    }
    const template = this._createTemplate(templateSource);
    this._tempTemplates.push({
      template,
      source: templateKey(templateSource)
    });
    return template;
  }
  _createTemplate(templateSource) {
    return this._createElement(validateTemplateSource(templateSource));
  }
  getTemplate(templateSource, templates, _ref3, context2) {
    let {
      isAsyncTemplate,
      skipTemplates
    } = _ref3;
    if (!isFunction(templateSource)) {
      return acquireTemplate(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
    }
    return new FunctionTemplate((options2) => {
      const templateSourceResult = templateSource.apply(context2, getNormalizedTemplateArgs(options2));
      if (!isDefined(templateSourceResult)) {
        return new EmptyTemplate();
      }
      let dispose2 = false;
      const template = acquireTemplate(templateSourceResult, (templateSource2) => {
        if (templateSource2.nodeType || isRenderer(templateSource2) && !renderer_default(templateSource2).is("script")) {
          return new FunctionTemplate(() => templateSource2);
        }
        dispose2 = true;
        return this._createTemplate(templateSource2);
      }, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
      const result2 = template.render(options2);
      dispose2 && template.dispose && template.dispose();
      return result2;
    });
  }
};
var m_template_manager_default = {
  TemplateManager
};

// node_modules/devextreme/esm/__internal/core/widget/dom_component.js
var DOMComponent = class _DOMComponent extends Component {
  static getInstance(element) {
    return getInstanceByElement(renderer_default(element), this);
  }
  static defaultOptions(rule) {
    this._classCustomRules = Object.hasOwnProperty.bind(this)("_classCustomRules") && this._classCustomRules ? this._classCustomRules : [];
    this._classCustomRules.push(rule);
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      width: void 0,
      height: void 0,
      rtlEnabled: config_default2().rtlEnabled,
      elementAttr: {},
      disabled: false,
      integrationOptions: {}
    }, this._useTemplates() ? m_template_manager_default.TemplateManager.createDefaultOptions() : {});
  }
  ctor(element, options2) {
    this._customClass = null;
    this._createElement(element);
    attachInstanceToElement(this._$element, this, this._dispose);
    super.ctor(options2);
    const validationAlreadyPerformed = peekValidationPerformed();
    license_validation_default.validateLicense(config_default2().licenseKey);
    if (!validationAlreadyPerformed && peekValidationPerformed()) {
      config_default2({
        licenseKey: ""
      });
    }
    uiLayerInitialized.resolve();
  }
  _createElement(element) {
    this._$element = renderer_default(element);
  }
  _getSynchronizableOptionsForCreateComponent() {
    return ["rtlEnabled", "disabled", "templatesRenderAsynchronously"];
  }
  _checkFunctionValueDeprecation(optionNames) {
    if (!this.option("_ignoreFunctionValueDeprecation")) {
      optionNames.forEach((optionName) => {
        if (isFunction(this.option(optionName))) {
          errors_default.log("W0017", optionName);
        }
      });
    }
  }
  _visibilityChanged(value2) {
  }
  _dimensionChanged() {
  }
  _init() {
    super._init();
    this._checkFunctionValueDeprecation(["width", "height", "maxHeight", "maxWidth", "minHeight", "minWidth", "popupHeight", "popupWidth"]);
    this._attachWindowResizeCallback();
    this._initTemplateManager();
  }
  _setOptionsByDevice(instanceCustomRules) {
    const ctor = this.constructor;
    const hasOwnCustomRules = Object.prototype.hasOwnProperty.call(ctor, "_classCustomRules");
    const hasOwnDefaultOptions = Object.prototype.hasOwnProperty.call(ctor, "defaultOptions");
    const ownClassCustomRules = hasOwnCustomRules || hasOwnDefaultOptions ? ctor._classCustomRules : [];
    super._setOptionsByDevice([].concat(ownClassCustomRules || [], instanceCustomRules || []));
  }
  _isInitialOptionValue(name2) {
    const isCustomOption = this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name2);
    return !isCustomOption && super._isInitialOptionValue(name2);
  }
  _attachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      const windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
      resize_callbacks_default.add(windowResizeCallBack);
    }
  }
  _isDimensionChangeSupported() {
    return this._dimensionChanged !== _DOMComponent.prototype._dimensionChanged;
  }
  _renderComponent() {
    addShadowDomStyles(this.$element());
    this._initMarkup();
    hasWindow() && this._render();
  }
  _initMarkup() {
    const {
      rtlEnabled
    } = this.option() || {};
    this._renderElementAttributes();
    this._toggleRTLDirection(rtlEnabled);
    this._renderVisibilityChange();
    this._renderDimensions();
  }
  _render() {
    this._attachVisibilityChangeHandlers();
  }
  _renderElementAttributes() {
    const {
      elementAttr
    } = this.option() || {};
    const attributes = extend({}, elementAttr);
    const classNames = attributes.class;
    delete attributes.class;
    this.$element().attr(attributes).removeClass(this._customClass).addClass(classNames);
    this._customClass = classNames;
  }
  _renderVisibilityChange() {
    if (this._isDimensionChangeSupported()) {
      this._attachDimensionChangeHandlers();
    }
    if (this._isVisibilityChangeSupported()) {
      const $element = this.$element();
      $element.addClass("dx-visibility-change-handler");
    }
  }
  _renderDimensions() {
    const $element = this.$element();
    const element = $element.get(0);
    const width = this._getOptionValue("width", element);
    const height = this._getOptionValue("height", element);
    if (this._isCssUpdateRequired(element, height, width)) {
      $element.css({
        width: null === width ? "" : width,
        height: null === height ? "" : height
      });
    }
  }
  _isCssUpdateRequired(element, height, width) {
    return !!(isDefined(width) || isDefined(height) || element.style.width || element.style.height);
  }
  _attachDimensionChangeHandlers() {
    const $el = this.$element();
    const namespace = `${this.NAME}VisibilityChange`;
    resize.off($el, {
      namespace
    });
    resize.on($el, () => this._dimensionChanged(), {
      namespace
    });
  }
  _attachVisibilityChangeHandlers() {
    if (this._isVisibilityChangeSupported()) {
      const $el = this.$element();
      const namespace = `${this.NAME}VisibilityChange`;
      this._isHidden = !this._isVisible();
      visibility.off($el, {
        namespace
      });
      visibility.on($el, () => this._checkVisibilityChanged("shown"), () => this._checkVisibilityChanged("hiding"), {
        namespace
      });
    }
  }
  _isVisible() {
    const $element = this.$element();
    return $element.is(":visible");
  }
  _checkVisibilityChanged(action) {
    const isVisible2 = this._isVisible();
    if (isVisible2) {
      if ("hiding" === action && !this._isHidden) {
        this._visibilityChanged(false);
        this._isHidden = true;
      } else if ("shown" === action && this._isHidden) {
        this._isHidden = false;
        this._visibilityChanged(true);
      }
    }
  }
  _isVisibilityChangeSupported() {
    return this._visibilityChanged !== _DOMComponent.prototype._visibilityChanged && hasWindow();
  }
  _clean() {
  }
  _modelByElement(element) {
    const {
      modelByElement
    } = this.option();
    const $element = this.$element();
    return modelByElement ? modelByElement($element) : void 0;
  }
  _invalidate() {
    if (this._isUpdateAllowed()) {
      throw errors_default.Error("E0007");
    }
    this._requireRefresh = true;
  }
  _refresh() {
    this._clean();
    this._renderComponent();
  }
  _dispose() {
    this._templateManager && this._templateManager.dispose();
    super._dispose();
    this._clean();
    this._detachWindowResizeCallback();
  }
  _detachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      resize_callbacks_default.remove(this._windowResizeCallBack);
    }
  }
  _toggleRTLDirection(rtl) {
    const $element = this.$element();
    $element.toggleClass("dx-rtl", rtl);
  }
  _createComponent(element, component, componentConfiguration) {
    const configuration = componentConfiguration ?? {};
    const synchronizableOptions = grep(this._getSynchronizableOptionsForCreateComponent(), (value2) => !(value2 in configuration));
    const {
      integrationOptions
    } = this.option();
    let {
      nestedComponentOptions
    } = this.option();
    nestedComponentOptions = nestedComponentOptions ?? noop2;
    const nestedComponentConfig = extend({
      integrationOptions
    }, nestedComponentOptions(this));
    synchronizableOptions.forEach((optionName) => nestedComponentConfig[optionName] = this.option(optionName));
    this._extendConfig(configuration, nestedComponentConfig);
    let instance;
    if (isString(component)) {
      const $element = renderer_default(element)[component](configuration);
      instance = $element[component]("instance");
    } else if (element) {
      instance = component.getInstance(element);
      if (instance) {
        instance.option(configuration);
      } else {
        instance = new component(element, configuration);
      }
    }
    if (instance) {
      const optionChangedHandler = (_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        if (synchronizableOptions.includes(name2)) {
          instance.option(name2, value2);
        }
      };
      this.on("optionChanged", optionChangedHandler);
      instance.on("disposing", () => this.off("optionChanged", optionChangedHandler));
    }
    return instance;
  }
  _extendConfig(configuration, extendConfig) {
    each(extendConfig, (key, value2) => {
      !Object.prototype.hasOwnProperty.call(configuration, key) && (configuration[key] = value2);
    });
  }
  _defaultActionConfig() {
    const $element = this.$element();
    const context2 = this._modelByElement($element);
    return extend(super._defaultActionConfig(), {
      context: context2
    });
  }
  _defaultActionArgs() {
    const $element = this.$element();
    const model = this._modelByElement($element);
    const element = this.element();
    return extend(super._defaultActionArgs(), {
      element,
      model
    });
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "width":
      case "height":
        this._renderDimensions();
        break;
      case "rtlEnabled":
        this._invalidate();
        break;
      case "elementAttr":
        this._renderElementAttributes();
        break;
      case "disabled":
      case "integrationOptions":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _removeAttributes(element) {
    const attrs = element.attributes;
    for (let i = attrs.length - 1; i >= 0; i--) {
      const attr = attrs[i];
      if (attr) {
        const {
          name: name2
        } = attr;
        if (!name2.indexOf("aria-") || -1 !== name2.indexOf("dx-") || "role" === name2 || "style" === name2 || "tabindex" === name2) {
          element.removeAttribute(name2);
        }
      }
    }
  }
  _removeClasses(element) {
    element.className = element.className.split(" ").filter((cssClass) => 0 !== cssClass.lastIndexOf("dx-", 0)).join(" ");
  }
  _updateDOMComponent(renderRequired) {
    if (renderRequired) {
      this._renderComponent();
    } else if (this._requireRefresh) {
      this._requireRefresh = false;
      this._refresh();
    }
  }
  endUpdate() {
    const renderRequired = this._isInitializingRequired();
    super.endUpdate();
    this._isUpdateAllowed() && this._updateDOMComponent(renderRequired);
  }
  $element() {
    return this._$element;
  }
  element() {
    const $element = this.$element();
    return getPublicElement($element);
  }
  dispose() {
    const element = this.$element().get(0);
    cleanDataRecursive(element, true);
    element.textContent = "";
    this._removeAttributes(element);
    this._removeClasses(element);
  }
  resetOption(optionName) {
    super.resetOption(optionName);
    if ("width" === optionName || "height" === optionName) {
      const initialOption = this.initialOption(optionName);
      !isDefined(initialOption) && this.$element().css(optionName, "");
    }
  }
  _getAnonymousTemplateName() {
    return;
  }
  _initTemplateManager() {
    if (this._templateManager || !this._useTemplates()) {
      return;
    }
    const {
      integrationOptions = {}
    } = this.option();
    const {
      createTemplate
    } = integrationOptions;
    this._templateManager = new m_template_manager_default.TemplateManager(createTemplate, this._getAnonymousTemplateName());
    this._initTemplates();
    return;
  }
  _initTemplates() {
    const {
      templates,
      anonymousTemplateMeta
    } = this._templateManager.extractTemplates(this.$element());
    const anonymousTemplate = this.option(`integrationOptions.templates.${anonymousTemplateMeta.name}`);
    templates.forEach((_ref2) => {
      let {
        name: name2,
        template
      } = _ref2;
      this._options.silent(`integrationOptions.templates.${name2}`, template);
    });
    if (anonymousTemplateMeta.name && !anonymousTemplate) {
      this._options.silent(`integrationOptions.templates.${anonymousTemplateMeta.name}`, anonymousTemplateMeta.template);
      this._options.silent("_hasAnonymousTemplateContent", true);
    }
  }
  _getTemplateByOption(optionName) {
    return this._getTemplate(this.option(optionName));
  }
  _getTemplate(templateSource) {
    const templates = this.option("integrationOptions.templates");
    const isAsyncTemplate = this.option("templatesRenderAsynchronously");
    const skipTemplates = this.option("integrationOptions.skipTemplates");
    return this._templateManager.getTemplate(templateSource, templates, {
      isAsyncTemplate,
      skipTemplates
    }, this);
  }
  _saveTemplate(name2, template) {
    this._setOptionWithoutOptionChange(`integrationOptions.templates.${name2}`, this._templateManager._createTemplate(template));
  }
  _useTemplates() {
    return true;
  }
};
var dom_component_default = DOMComponent;

// node_modules/devextreme/esm/__internal/core/widget/widget.js
function setAttribute(name2, value2, target) {
  name2 = "role" === name2 || "id" === name2 ? name2 : `aria-${name2}`;
  value2 = isDefined(value2) ? value2.toString() : null;
  target.attr(name2, value2);
}
var Widget = class _Widget extends dom_component_default {
  constructor() {
    super(...arguments);
    this._feedbackHideTimeout = 400;
    this._feedbackShowTimeout = 30;
  }
  static getOptionsFromContainer(_ref) {
    let {
      name: name2,
      fullName,
      value: value2
    } = _ref;
    let options2 = {};
    if (name2 === fullName) {
      options2 = value2;
    } else {
      const option = fullName.split(".").pop();
      options2[option] = value2;
    }
    return options2;
  }
  _supportedKeys() {
    return {};
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      hoveredElement: null,
      isActive: false,
      disabled: false,
      visible: true,
      hint: void 0,
      activeStateEnabled: false,
      onContentReady: null,
      hoverStateEnabled: false,
      focusStateEnabled: false,
      tabIndex: 0,
      accessKey: void 0,
      onFocusIn: null,
      onFocusOut: null,
      onKeyboardHandled: null,
      ignoreParentReadOnly: false,
      useResizeObserver: true
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        const device = devices_default.real();
        const {
          platform
        } = device;
        const {
          version: version2
        } = device;
        return "ios" === platform && compare(version2, "13.3") <= 0;
      },
      options: {
        useResizeObserver: false
      }
    }]);
  }
  _init() {
    super._init();
    this._initContentReadyAction();
  }
  _innerWidgetOptionChanged(innerWidget, args) {
    const options2 = _Widget.getOptionsFromContainer(args);
    innerWidget && innerWidget.option(options2);
    this._options.cache(args.name, options2);
  }
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    const syncOptions = () => this._options.silent(optionsContainer, extend({}, innerWidget.option()));
    syncOptions();
    innerWidget.on("optionChanged", syncOptions);
  }
  _getAriaTarget() {
    return this._focusTarget();
  }
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initMarkup() {
    const {
      disabled,
      visible: visible2
    } = this.option();
    this.$element().addClass("dx-widget");
    this._toggleDisabledState(disabled);
    this._toggleVisibility(visible2);
    this._renderHint();
    this._isFocusable() && this._renderFocusTarget();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderContent();
    this._renderFocusState();
    this._attachFeedbackEvents();
    this._attachHoverEvents();
    this._toggleIndependentState();
  }
  _renderHint() {
    const {
      hint
    } = this.option();
    this.$element().attr("title", hint || null);
  }
  _renderContent() {
    deferRender(() => !this._disposed ? this._renderContentImpl() : void 0).done(() => !this._disposed ? this._fireContentReadyAction() : void 0);
  }
  _renderContentImpl() {
  }
  _fireContentReadyAction() {
    return deferRender(() => {
      var _this$_contentReadyAc;
      return null === (_this$_contentReadyAc = this._contentReadyAction) || void 0 === _this$_contentReadyAc ? void 0 : _this$_contentReadyAc.call(this);
    });
  }
  _dispose() {
    this._contentReadyAction = null;
    this._detachKeyboardEvents();
    super._dispose();
  }
  _resetActiveState() {
    this._toggleActiveState(this._eventBindingTarget(), false);
  }
  _clean() {
    this._cleanFocusState();
    this._resetActiveState();
    super._clean();
    this.$element().empty();
  }
  _toggleVisibility(visible2) {
    this.$element().toggleClass("dx-state-invisible", !visible2);
  }
  _renderFocusState() {
    this._attachKeyboardEvents();
    if (this._isFocusable()) {
      this._renderFocusTarget();
      this._attachFocusEvents();
      this._renderAccessKey();
    }
  }
  _renderAccessKey() {
    const $el = this._focusTarget();
    const {
      accessKey
    } = this.option();
    $el.attr("accesskey", accessKey);
  }
  _isFocusable() {
    const {
      focusStateEnabled,
      disabled
    } = this.option();
    return focusStateEnabled && !disabled;
  }
  _eventBindingTarget() {
    return this.$element();
  }
  _focusTarget() {
    return this._getActiveElement();
  }
  _isFocusTarget(element) {
    const focusTargets = renderer_default(this._focusTarget()).toArray();
    return focusTargets.includes(element);
  }
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit).not(".dx-state-disabled");
  }
  _getActiveElement() {
    const activeElement = this._eventBindingTarget();
    if (this._activeStateUnit) {
      return this._findActiveTarget(activeElement);
    }
    return activeElement;
  }
  _renderFocusTarget() {
    const {
      tabIndex
    } = this.option();
    this._focusTarget().attr("tabIndex", tabIndex);
  }
  _keyboardEventBindingTarget() {
    return this._eventBindingTarget();
  }
  _refreshFocusEvent() {
    this._detachFocusEvents();
    this._attachFocusEvents();
  }
  _focusEventTarget() {
    return this._focusTarget();
  }
  _focusInHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusIn", {
        beforeExecute: () => this._updateFocusState(event, true),
        excludeValidators: ["readOnly"]
      })({
        event
      });
    }
  }
  _focusOutHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusOut", {
        beforeExecute: () => this._updateFocusState(event, false),
        excludeValidators: ["readOnly", "disabled"]
      })({
        event
      });
    }
  }
  _updateFocusState(_ref2, isFocused) {
    let {
      target
    } = _ref2;
    if (this._isFocusTarget(target)) {
      this._toggleFocusClass(isFocused, renderer_default(target));
    }
  }
  _toggleFocusClass(isFocused, $element) {
    const $focusTarget = $element && $element.length ? $element : this._focusTarget();
    $focusTarget.toggleClass("dx-state-focused", isFocused);
  }
  _hasFocusClass(element) {
    const $focusTarget = renderer_default(element ?? this._focusTarget());
    return $focusTarget.hasClass("dx-state-focused");
  }
  _isFocused() {
    return this._hasFocusClass();
  }
  _getKeyboardListeners() {
    return [];
  }
  _attachKeyboardEvents() {
    this._detachKeyboardEvents();
    const {
      focusStateEnabled,
      onKeyboardHandled
    } = this.option();
    const hasChildListeners = this._getKeyboardListeners().length;
    const hasKeyboardEventHandler = !!onKeyboardHandled;
    const shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;
    if (shouldAttach) {
      this._keyboardListenerId = keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), (opts) => this._keyboardHandler(opts));
    }
  }
  _keyboardHandler(options2, onlyChildProcessing) {
    if (!onlyChildProcessing) {
      const {
        originalEvent,
        keyName,
        which
      } = options2;
      const keys = this._supportedKeys(originalEvent);
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          return false;
        }
      }
    }
    const keyboardListeners = this._getKeyboardListeners();
    const {
      onKeyboardHandled
    } = this.option();
    keyboardListeners.forEach((listener) => listener && listener._keyboardHandler(options2));
    onKeyboardHandled && onKeyboardHandled(options2);
    return true;
  }
  _refreshFocusState() {
    this._cleanFocusState();
    this._renderFocusState();
  }
  _cleanFocusState() {
    const $element = this._focusTarget();
    $element.removeAttr("tabIndex");
    this._toggleFocusClass(false);
    this._detachFocusEvents();
    this._detachKeyboardEvents();
  }
  _detachKeyboardEvents() {
    keyboard.off(this._keyboardListenerId);
    this._keyboardListenerId = null;
  }
  _attachHoverEvents() {
    const {
      hoverStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const $el = this._eventBindingTarget();
    hover.off($el, {
      selector,
      namespace: "UIFeedback"
    });
    if (hoverStateEnabled) {
      hover.on($el, new action_default((_ref3) => {
        let {
          event,
          element
        } = _ref3;
        this._hoverStartHandler(event);
        this.option("hoveredElement", renderer_default(element));
      }, {
        excludeValidators: ["readOnly"]
      }), (event) => {
        this.option("hoveredElement", null);
        this._hoverEndHandler(event);
      }, {
        selector,
        namespace: "UIFeedback"
      });
    }
  }
  _attachFeedbackEvents() {
    const {
      activeStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const $el = this._eventBindingTarget();
    active.off($el, {
      namespace: "UIFeedback",
      selector
    });
    if (activeStateEnabled) {
      active.on($el, new action_default((_ref4) => {
        let {
          event,
          element
        } = _ref4;
        return this._toggleActiveState(renderer_default(element), true, event);
      }), new action_default((_ref5) => {
        let {
          event,
          element
        } = _ref5;
        return this._toggleActiveState(renderer_default(element), false, event);
      }, {
        excludeValidators: ["disabled", "readOnly"]
      }), {
        showTimeout: this._feedbackShowTimeout,
        hideTimeout: this._feedbackHideTimeout,
        selector,
        namespace: "UIFeedback"
      });
    }
  }
  _detachFocusEvents() {
    const $el = this._focusEventTarget();
    focus.off($el, {
      namespace: `${this.NAME}Focus`
    });
  }
  _attachFocusEvents() {
    const $el = this._focusEventTarget();
    focus.on($el, (e) => this._focusInHandler(e), (e) => this._focusOutHandler(e), {
      namespace: `${this.NAME}Focus`,
      isFocusable: (index2, el) => renderer_default(el).is(focusable)
    });
  }
  _hoverStartHandler(event) {
  }
  _hoverEndHandler(event) {
  }
  _toggleActiveState($element, value2, event) {
    this.option("isActive", value2);
    $element.toggleClass("dx-state-active", value2);
  }
  _updatedHover() {
    const hoveredElement = this._options.silent("hoveredElement");
    this._hover(hoveredElement, hoveredElement);
  }
  _findHoverTarget($el) {
    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());
  }
  _hover($el, $previous) {
    const {
      hoverStateEnabled,
      disabled,
      isActive
    } = this.option();
    $previous = this._findHoverTarget($previous);
    $previous && $previous.toggleClass("dx-state-hover", false);
    if ($el && hoverStateEnabled && !disabled && !isActive) {
      const newHoveredElement = this._findHoverTarget($el);
      newHoveredElement && newHoveredElement.toggleClass("dx-state-hover", true);
    }
  }
  _toggleDisabledState(value2) {
    this.$element().toggleClass("dx-state-disabled", Boolean(value2));
    this.setAria("disabled", value2 || void 0);
  }
  _toggleIndependentState() {
    const {
      ignoreParentReadOnly
    } = this.option();
    this.$element().toggleClass("dx-state-independent", ignoreParentReadOnly);
  }
  _setWidgetOption(widgetName, args) {
    if (!this[widgetName]) {
      return;
    }
    if (isPlainObject(args[0])) {
      each(args[0], (option, value3) => this._setWidgetOption(widgetName, [option, value3]));
      return;
    }
    const optionName = args[0];
    let value2 = args[1];
    if (1 === args.length) {
      value2 = this.option(optionName);
    }
    const widgetOptionMap = this[`${widgetName}OptionMap`];
    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value2);
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "disabled":
        this._toggleDisabledState(value2);
        this._updatedHover();
        this._refreshFocusState();
        break;
      case "hint":
        this._renderHint();
        break;
      case "ignoreParentReadOnly":
        this._toggleIndependentState();
        break;
      case "activeStateEnabled":
        this._attachFeedbackEvents();
        break;
      case "hoverStateEnabled":
        this._attachHoverEvents();
        this._updatedHover();
        break;
      case "tabIndex":
      case "focusStateEnabled":
        this._refreshFocusState();
        break;
      case "onFocusIn":
      case "onFocusOut":
      case "useResizeObserver":
        break;
      case "accessKey":
        this._renderAccessKey();
        break;
      case "hoveredElement":
        this._hover(value2, previousValue);
        break;
      case "isActive":
        this._updatedHover();
        break;
      case "visible":
        this._toggleVisibility(value2);
        if (this._isVisibilityChangeSupported()) {
          this._checkVisibilityChanged(value2 ? "shown" : "hiding");
        }
        break;
      case "onKeyboardHandled":
        this._attachKeyboardEvents();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _isVisible() {
    const {
      visible: visible2
    } = this.option();
    return super._isVisible() && visible2;
  }
  beginUpdate() {
    this._ready(false);
    super.beginUpdate();
  }
  endUpdate() {
    super.endUpdate();
    if (this._initialized) {
      this._ready(true);
    }
  }
  _ready(value2) {
    if (0 === arguments.length) {
      return !!this._isReady;
    }
    this._isReady = !!value2;
    return this._isReady;
  }
  setAria() {
    if (!isPlainObject(arguments.length <= 0 ? void 0 : arguments[0])) {
      setAttribute(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget());
    } else {
      const target = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();
      each(arguments.length <= 0 ? void 0 : arguments[0], (name2, value2) => setAttribute(name2, value2, target));
    }
  }
  isReady() {
    return this._ready();
  }
  repaint() {
    this._refresh();
  }
  focus() {
    focus.trigger(this._focusTarget());
  }
  registerKeyHandler(key, handler) {
    const currentKeys = this._supportedKeys();
    this._supportedKeys = () => extend(currentKeys, {
      [key]: handler
    });
  }
};
var widget_default = Widget;

// node_modules/devextreme/esm/__internal/ui/collection/item.js
var forcibleWatcher = (watchMethod, fn, callback) => {
  const filteredCallback = /* @__PURE__ */ (() => {
    let oldValue;
    return (value2) => {
      if (oldValue !== value2) {
        callback(value2, oldValue);
        oldValue = value2;
      }
    };
  })();
  return {
    dispose: watchMethod(fn, filteredCallback),
    force() {
      filteredCallback(fn());
    }
  };
};
var CollectionItem = class extends class_default.inherit({}) {
  ctor($element, options2, rawData) {
    this._$element = $element;
    this._options = options2;
    this._rawData = rawData;
    attachInstanceToElement($element, this, this._dispose);
    this._render();
  }
  _render() {
    const $placeholder = renderer_default("<div>").addClass("dx-item-content-placeholder");
    this._$element.append($placeholder);
    this._watchers = [];
    this._renderWatchers();
  }
  _renderWatchers() {
    this._startWatcher("disabled", this._renderDisabled.bind(this));
    this._startWatcher("visible", this._renderVisible.bind(this));
  }
  _startWatcher(field, render2) {
    const rawData = this._rawData;
    const exprGetter = this._options.fieldGetter(field);
    const watcher = forcibleWatcher(this._options.watchMethod(), () => exprGetter(rawData), (value2, oldValue) => {
      this._dirty = true;
      render2(value2, oldValue);
    });
    this._watchers.push(watcher);
  }
  setDataField() {
    this._dirty = false;
    each(this._watchers, (_, watcher) => {
      watcher.force();
    });
    return this._dirty;
  }
  _renderDisabled(value2, oldValue) {
    this._$element.toggleClass("dx-state-disabled", !!value2);
    this._$element.attr("aria-disabled", !!value2);
    this._updateOwnerFocus(value2);
  }
  _updateOwnerFocus(isDisabled) {
    const ownerComponent = this._options.owner;
    if (ownerComponent && isDisabled) {
      ownerComponent._resetItemFocus(this._$element);
    }
  }
  _renderVisible(value2, oldValue) {
    this._$element.toggleClass("dx-state-invisible", void 0 !== value2 && !value2);
  }
  _dispose() {
    each(this._watchers, (_, watcher) => {
      watcher.dispose();
    });
  }
  static getInstance($element) {
    return getInstanceByElement($element, this);
  }
};
var item_default = CollectionItem;

// node_modules/devextreme/esm/__internal/ui/collection/collection_widget.base.js
var ITEM_CLASS = "dx-item";
var EMPTY_COLLECTION = "dx-empty-collection";
var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
var CollectionWidget = class extends widget_default {
  _supportedKeys() {
    const move2 = (location, e) => {
      if (!isCommandKeyPressed(e)) {
        e.preventDefault();
        e.stopPropagation();
        this._moveFocus(location, e);
      }
    };
    return _extends({}, super._supportedKeys(), {
      space: (e) => {
        e.preventDefault();
        this._enterKeyHandler(e);
      },
      enter: this._enterKeyHandler,
      leftArrow: move2.bind(this, "left"),
      rightArrow: move2.bind(this, "right"),
      upArrow: move2.bind(this, "up"),
      downArrow: move2.bind(this, "down"),
      pageUp: move2.bind(this, "up"),
      pageDown: move2.bind(this, "down"),
      home: move2.bind(this, "first"),
      end: move2.bind(this, "last")
    });
  }
  _getHandlerExtendedParams(e, $target) {
    const params = extend({}, e, {
      target: $target.get(0),
      currentTarget: $target.get(0)
    });
    return params;
  }
  _enterKeyHandler(e) {
    const {
      focusedElement
    } = this.option();
    const $itemElement = renderer_default(focusedElement);
    if (!$itemElement.length) {
      return;
    }
    const itemData = this._getItemData($itemElement);
    if (null !== itemData && void 0 !== itemData && itemData.onClick) {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }
    this._itemClickHandler(this._getHandlerExtendedParams(e, $itemElement));
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      selectOnFocus: false,
      loopItemFocus: true,
      items: [],
      itemTemplate: "item",
      onItemRendered: null,
      onItemClick: null,
      onItemHold: null,
      itemHoldTimeout: 750,
      onItemContextMenu: null,
      onFocusedItemChanged: null,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: false,
      dataSource: null,
      _dataController: null,
      _itemAttributes: {},
      itemTemplateProperty: "template",
      focusedElement: null,
      displayExpr: void 0,
      disabledExpr: (data2) => data2 ? data2.disabled : void 0,
      visibleExpr: (data2) => data2 ? data2.visible : void 0
    });
  }
  _init() {
    this._compileDisplayGetter();
    this._initDataController();
    super._init();
    this._activeStateUnit = `.${ITEM_CLASS}`;
    this._cleanRenderedItems();
    this._refreshDataSource();
  }
  _compileDisplayGetter() {
    const {
      displayExpr
    } = this.option();
    this._displayGetter = displayExpr ? compileGetter(displayExpr) : void 0;
  }
  _initTemplates() {
    this._initItemsFromMarkup();
    this._initDefaultItemTemplate();
    super._initTemplates();
  }
  _getAnonymousTemplateName() {
    return "item";
  }
  _initDefaultItemTemplate() {
    const fieldsMap = this._getFieldsMap();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data2) => {
        if (isPlainObject(data2)) {
          this._prepareDefaultItemTemplate(data2, $container);
        } else {
          if (fieldsMap && isFunction(fieldsMap.text)) {
            data2 = fieldsMap.text(data2);
          }
          $container.text(String(ensureDefined(data2, "")));
        }
      }, this._getBindableFields(), this.option("integrationOptions.watchMethod"), fieldsMap)
    });
  }
  _getBindableFields() {
    return ["text", "html"];
  }
  _getFieldsMap() {
    if (this._displayGetter) {
      return {
        text: this._displayGetter
      };
    }
    return;
  }
  _prepareDefaultItemTemplate(data2, $container) {
    const {
      text,
      html
    } = data2;
    if (isDefined(text)) {
      $container.text(text);
    }
    if (isDefined(html)) {
      $container.html(html);
    }
  }
  _initItemsFromMarkup() {
    const rawItems = findTemplates(this.$element(), "dxItem");
    if (!rawItems.length || this.option("items").length) {
      return;
    }
    const items = rawItems.map((_ref) => {
      let {
        element,
        options: options2
      } = _ref;
      const isTemplateRequired = /\S/.test(element.innerHTML) && !options2.template;
      if (isTemplateRequired) {
        options2.template = this._prepareItemTemplate(element);
      } else {
        renderer_default(element).remove();
      }
      return options2;
    });
    this.option("items", items);
  }
  _prepareItemTemplate(item) {
    const templateId = `tmpl-${new guid_default2()}`;
    const $template = renderer_default(item).detach().clone().removeAttr("data-options").addClass("dx-template-wrapper");
    this._saveTemplate(templateId, $template);
    return templateId;
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _cleanRenderedItems() {
    this._renderedItemsCount = 0;
  }
  _focusTarget() {
    return this.$element();
  }
  _focusInHandler(e) {
    super._focusInHandler(e);
    if (!this._isFocusTarget(e.target)) {
      return;
    }
    const $focusedElement = renderer_default(this.option("focusedElement"));
    if ($focusedElement.length) {
      this._shouldSkipSelectOnFocus = true;
      this._setFocusedItem($focusedElement);
      this._shouldSkipSelectOnFocus = false;
    } else {
      const $activeItem = this._getActiveItem();
      if ($activeItem.length) {
        this.option("focusedElement", getPublicElement($activeItem));
      }
    }
  }
  _focusOutHandler(e) {
    super._focusOutHandler(e);
    const {
      focusedElement
    } = this.option();
    const $target = renderer_default(focusedElement);
    this._updateFocusedItemState($target, false);
  }
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit);
  }
  _getActiveItem(last) {
    const {
      focusedElement
    } = this.option();
    const $focusedElement = renderer_default(focusedElement);
    if ($focusedElement.length) {
      return $focusedElement;
    }
    return this._determineFocusedElement(last);
  }
  _determineFocusedElement(last) {
    let index2 = this._getFocusedElementIndex();
    const activeElements = this._getActiveElement();
    const lastIndex = activeElements.length - 1;
    if (index2 < 0) {
      index2 = last ? lastIndex : 0;
    }
    return activeElements.eq(index2);
  }
  _getFocusedElementIndex() {
    return 0;
  }
  _moveFocus(location, e) {
    const $items = this._getAvailableItems();
    let $newTarget = renderer_default();
    switch (location) {
      case "pageup":
      case "up":
        $newTarget = this._prevItem($items);
        break;
      case "pagedown":
      case "down":
        $newTarget = this._nextItem($items);
        break;
      case "right":
        $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
        break;
      case "left":
        $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
        break;
      case "first":
        $newTarget = $items.first();
        break;
      case "last":
        $newTarget = $items.last();
        break;
      default:
        return false;
    }
    if (0 !== $newTarget.length) {
      this.option("focusedElement", getPublicElement($newTarget));
    }
  }
  _getVisibleItems($itemElements) {
    const $items = $itemElements ?? this._itemElements();
    return $items.filter(":visible");
  }
  _getAvailableItems($itemElements) {
    return this._getVisibleItems($itemElements);
  }
  _prevItem($items) {
    const $target = this._getActiveItem();
    const targetIndex = $items.index($target);
    const $last = $items.last();
    let $item = renderer_default($items[targetIndex - 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $last;
    }
    return $item;
  }
  _nextItem($items) {
    const $target = this._getActiveItem(true);
    const targetIndex = $items.index($target);
    const $first = $items.first();
    let $item = renderer_default($items[targetIndex + 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $first;
    }
    return $item;
  }
  _selectFocusedItem($target) {
    this.selectItem($target);
  }
  _updateFocusedItemState(target, isFocused, needCleanItemId) {
    const $target = renderer_default(target);
    if ($target.length) {
      this._refreshActiveDescendant();
      this._refreshItemId($target, needCleanItemId);
      this._toggleFocusClass(isFocused, $target);
    }
    this._updateParentActiveDescendant();
  }
  _getElementClassToSkipRefreshId() {
    return "";
  }
  _shouldSkipRefreshId(target) {
    const elementClass = this._getElementClassToSkipRefreshId();
    const shouldSkipRefreshId = renderer_default(target).hasClass(elementClass);
    return shouldSkipRefreshId;
  }
  _refreshActiveDescendant($target) {
    const {
      focusedElement
    } = this.option();
    if (isDefined(focusedElement)) {
      const shouldSetExistingId = this._shouldSkipRefreshId(focusedElement);
      const id = shouldSetExistingId ? renderer_default(focusedElement).attr("id") : this.getFocusedItemId();
      this.setAria("activedescendant", id, $target);
      return;
    }
    this.setAria("activedescendant", null, $target);
  }
  _refreshItemId($target, needCleanItemId) {
    const {
      focusedElement
    } = this.option();
    const shouldSkipRefreshId = this._shouldSkipRefreshId($target);
    if (shouldSkipRefreshId) {
      return;
    }
    if (!needCleanItemId && focusedElement) {
      this.setAria("id", this.getFocusedItemId(), $target);
    } else {
      this.setAria("id", null, $target);
    }
  }
  _isDisabled($element) {
    return $element && "true" === renderer_default($element).attr("aria-disabled");
  }
  _setFocusedItem($target) {
    if (!$target || !$target.length) {
      return;
    }
    this._updateFocusedItemState($target, true);
    this.onFocusedItemChanged(this.getFocusedItemId());
    const {
      selectOnFocus
    } = this.option();
    const isTargetDisabled = this._isDisabled($target);
    if (selectOnFocus && !isTargetDisabled && !this._shouldSkipSelectOnFocus) {
      this._selectFocusedItem($target);
    }
  }
  _findItemElementByItem(item) {
    let result2 = renderer_default();
    const itemDataKey = this._itemDataKey();
    this.itemElements().each((index2, itemElement) => {
      const $item = renderer_default(itemElement);
      if ($item.data(itemDataKey) === item) {
        result2 = $item;
        return false;
      }
      return true;
    });
    return result2;
  }
  _getIndexByItem(item) {
    const {
      items
    } = this.option();
    return items.indexOf(item);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    const $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value2)) {
      this._refreshItem($item, item);
    }
    const isDisabling = "disabled" === property && value2;
    if (isDisabling) {
      this._resetItemFocus($item);
    }
  }
  _resetItemFocus($item) {
    if ($item.is(this.option("focusedElement"))) {
      this._resetFocusedElement();
    }
  }
  _resetFocusedElement() {
    this.option("focusedElement", null);
  }
  _refreshItem($item, item) {
    const itemData = this._getItemData($item);
    const index2 = $item.data(this._itemIndexKey());
    this._renderItem(this._renderedItemsCount + index2, itemData, null, $item);
  }
  _updateParentActiveDescendant() {
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue,
      fullName
    } = args;
    if ("items" === name2) {
      const matches = fullName.match(ITEM_PATH_REGEX);
      if (null !== matches && void 0 !== matches && matches.length) {
        const property = matches[matches.length - 1];
        const itemPath = fullName.replace(`.${property}`, "");
        const item = this.option(itemPath);
        this._itemOptionChanged(item, property, value2, previousValue);
        return;
      }
    }
    switch (name2) {
      case "items":
      case "_itemAttributes":
      case "itemTemplateProperty":
      case "useItemTextAsTitle":
        this._cleanRenderedItems();
        this._invalidate();
        break;
      case "dataSource":
        this._refreshDataSource();
        this._renderEmptyMessage();
        break;
      case "noDataText":
      case "encodeNoDataText":
        this._renderEmptyMessage();
        break;
      case "itemTemplate":
      case "visibleExpr":
      case "disabledExpr":
        this._invalidate();
        break;
      case "onItemRendered":
        this._createItemRenderAction();
        break;
      case "onItemClick":
      case "selectOnFocus":
      case "loopItemFocus":
        break;
      case "onItemHold":
      case "itemHoldTimeout":
        this._attachHoldEvent();
        break;
      case "onItemContextMenu":
        this._attachContextMenuEvent();
        break;
      case "onFocusedItemChanged":
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        break;
      case "focusedElement":
        this._updateFocusedItemState(previousValue, false, true);
        this._setFocusedItem(renderer_default(value2));
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDefaultItemTemplate();
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _invalidate() {
    this._resetFocusedElement();
    super._invalidate();
  }
  _loadNextPage() {
    this._expectNextPageLoading();
    return this._dataController.loadNextPage();
  }
  _expectNextPageLoading() {
    this._startIndexForAppendedItems = 0;
  }
  _expectLastItemLoading() {
    this._startIndexForAppendedItems = -1;
  }
  _forgetNextPageLoading() {
    this._startIndexForAppendedItems = null;
  }
  _dataSourceChangedHandler(newItems, e) {
    const items = this.option("items");
    if (this._initialized && items && this._shouldAppendItems()) {
      this._renderedItemsCount = items.length;
      if (!this._isLastPage() || -1 !== this._startIndexForAppendedItems) {
        this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
      }
      this._forgetNextPageLoading();
      this._refreshContent();
    } else {
      this.option("items", newItems.slice());
    }
  }
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  }
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    this.option("items", this.option("items"));
  }
  _shouldAppendItems() {
    return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend();
  }
  _allowDynamicItemsAppend() {
    return false;
  }
  _clean() {
    this._cleanFocusState();
    this._cleanItemContainer();
    if (this._inkRipple) {
      delete this._inkRipple;
    }
    this._resetActiveState();
  }
  _cleanItemContainer() {
    renderer_default(this._itemContainer()).empty();
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._itemFocusTimeout);
  }
  _refresh() {
    this._cleanRenderedItems();
    super._refresh();
  }
  _itemContainer(searchEnabled, previousSelectAllEnabled) {
    return this.$element();
  }
  _itemClass() {
    return ITEM_CLASS;
  }
  _itemContentClass() {
    return `${this._itemClass()}-content`;
  }
  _itemResponseWaitClass() {
    return "dx-item-response-wait";
  }
  _itemSelector() {
    return `.${this._itemClass()}`;
  }
  _itemDataKey() {
    return "dxItemData";
  }
  _itemIndexKey() {
    return "dxItemIndex";
  }
  _itemElements() {
    return this._itemContainer().find(this._itemSelector());
  }
  _initMarkup() {
    super._initMarkup();
    this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
    this.$element().addClass("dx-collection");
    this._prepareContent();
  }
  _prepareContent() {
    deferRenderer(() => {
      this._renderContentImpl();
    })();
  }
  _renderContent() {
    this._fireContentReadyAction();
  }
  _render() {
    super._render();
    this._attachClickEvent();
    this._attachHoldEvent();
    this._attachContextMenuEvent();
  }
  _getPointerEvent() {
    return m_pointer_default.down;
  }
  _attachClickEvent() {
    const itemSelector = this._itemSelector();
    const pointerEvent = this._getPointerEvent();
    const clickEventNamespace = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const pointerEventNamespace = addNamespace2(pointerEvent, this.NAME);
    const pointerAction = new action_default((args) => {
      const {
        event
      } = args;
      this._itemPointerDownHandler(event);
    });
    m_events_engine_default.off(this._itemContainer(), clickEventNamespace, itemSelector);
    m_events_engine_default.off(this._itemContainer(), pointerEventNamespace, itemSelector);
    m_events_engine_default.on(this._itemContainer(), clickEventNamespace, itemSelector, (e) => this._itemClickHandler(e));
    m_events_engine_default.on(this._itemContainer(), pointerEventNamespace, itemSelector, (e) => {
      pointerAction.execute({
        element: renderer_default(e.target),
        event: e
      });
    });
  }
  _itemClickHandler(e, args, config3) {
    this._itemDXEventHandler(e, "onItemClick", args, config3);
  }
  _itemPointerDownHandler(e) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    this._itemFocusHandler = () => {
      clearTimeout(this._itemFocusTimeout);
      this._itemFocusHandler = void 0;
      if (e.isDefaultPrevented()) {
        return;
      }
      const $target = renderer_default(e.target);
      const $closestItem = $target.closest(this._itemElements());
      const $closestFocusable = this._closestFocusable($target);
      if ($closestItem.length && this._isFocusTarget(null === $closestFocusable || void 0 === $closestFocusable ? void 0 : $closestFocusable.get(0))) {
        this._shouldSkipSelectOnFocus = true;
        this.option("focusedElement", getPublicElement($closestItem));
        this._shouldSkipSelectOnFocus = false;
      }
    };
    this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this));
  }
  _closestFocusable($target) {
    if ($target.is(focusable)) {
      return $target;
    }
    let $nextTarget = $target.parent();
    while ($nextTarget.length && !dom_adapter_default.isDocument($nextTarget.get(0)) && !dom_adapter_default.isDocumentFragment($nextTarget.get(0))) {
      if ($nextTarget.is(focusable)) {
        return $nextTarget;
      }
      $nextTarget = $nextTarget.parent();
    }
    return;
  }
  _forcePointerDownFocus() {
    if (this._itemFocusHandler) {
      this._itemFocusHandler();
    }
  }
  _updateFocusState(e, isFocused) {
    super._updateFocusState(e, isFocused);
    this._forcePointerDownFocus();
  }
  _attachHoldEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace2(m_hold_default.name, this.NAME);
    m_events_engine_default.off($itemContainer, eventName, itemSelector);
    m_events_engine_default.on($itemContainer, eventName, itemSelector, {
      timeout: this._getHoldTimeout()
    }, this._itemHoldHandler.bind(this));
  }
  _getHoldTimeout() {
    const {
      itemHoldTimeout
    } = this.option();
    return itemHoldTimeout;
  }
  _shouldFireHoldEvent() {
    return this.hasActionSubscription("onItemHold");
  }
  _itemHoldHandler(e) {
    if (this._shouldFireHoldEvent()) {
      this._itemDXEventHandler(e, "onItemHold");
    } else {
      e.cancel = true;
    }
  }
  _attachContextMenuEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace2(name, this.NAME);
    m_events_engine_default.off($itemContainer, eventName, itemSelector);
    m_events_engine_default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this));
  }
  _shouldFireContextMenuEvent() {
    return this.hasActionSubscription("onItemContextMenu");
  }
  _itemContextMenuHandler(e) {
    if (this._shouldFireContextMenuEvent()) {
      this._itemDXEventHandler(e, "onItemContextMenu");
    } else {
      e.cancel = true;
    }
  }
  _renderContentImpl() {
    const {
      items
    } = this.option();
    const itemsToRender = items ?? [];
    if (this._renderedItemsCount) {
      this._renderItems(itemsToRender.slice(this._renderedItemsCount));
    } else {
      this._renderItems(itemsToRender);
    }
  }
  _renderItems(items) {
    if (items.length) {
      each(items, (index2, itemData) => {
        this._renderItem(this._renderedItemsCount + index2, itemData);
      });
    }
    this._renderEmptyMessage();
  }
  _getItemsContainer() {
    return this._itemContainer();
  }
  _setAttributes($element) {
    const attributes = _extends({}, this.option("_itemAttributes"));
    const {
      class: customClassValue
    } = attributes;
    if (customClassValue) {
      const currentClassValue = $element.get(0).className;
      attributes.class = [currentClassValue, customClassValue].join(" ");
    }
    $element.attr(attributes);
  }
  _renderItem(index2, itemData, $container, $itemToReplace) {
    const itemIndex = (null === index2 || void 0 === index2 ? void 0 : index2.item) ?? index2;
    const $containerToRender = $container ?? this._getItemsContainer();
    const $itemFrame = this._renderItemFrame(itemIndex, itemData, $containerToRender, $itemToReplace);
    this._setElementData($itemFrame, itemData, itemIndex);
    this._setAttributes($itemFrame);
    this._attachItemClickEvent(itemData, $itemFrame);
    const $itemContent = this._getItemContent($itemFrame);
    const {
      itemTemplate
    } = this.option();
    const renderContentPromise = this._renderItemContent({
      index: itemIndex,
      itemData,
      container: getPublicElement($itemContent),
      contentClass: this._itemContentClass(),
      defaultTemplateName: itemTemplate
    });
    when(renderContentPromise).done(($content) => {
      this._postprocessRenderItem({
        itemElement: $itemFrame,
        itemContent: $content,
        itemData,
        itemIndex
      });
      this._executeItemRenderAction(index2, itemData, getPublicElement($itemFrame));
    });
    return $itemFrame;
  }
  _getItemContent($itemFrame) {
    const $itemContent = $itemFrame.find(".dx-item-content-placeholder");
    $itemContent.removeClass("dx-item-content-placeholder");
    return $itemContent;
  }
  _attachItemClickEvent(itemData, $itemElement) {
    if (!itemData || !itemData.onClick) {
      return;
    }
    m_events_engine_default.on($itemElement, CLICK_EVENT_NAME, (e) => {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    });
  }
  _renderItemContent(args) {
    const itemTemplateName = this._getItemTemplateName(args);
    const itemTemplate = this._getTemplate(itemTemplateName);
    this._addItemContentClasses(args);
    const $templateResult = renderer_default(this._createItemByTemplate(itemTemplate, args));
    if (!$templateResult.hasClass("dx-template-wrapper")) {
      return args.container;
    }
    return this._renderItemContentByNode(args, $templateResult);
  }
  _renderItemContentByNode(args, $node) {
    renderer_default(args.container).replaceWith($node);
    args.container = getPublicElement($node);
    this._addItemContentClasses(args);
    return $node;
  }
  _addItemContentClasses(args) {
    const classes = [ITEM_CLASS + "-content", args.contentClass];
    renderer_default(args.container).addClass(classes.join(" "));
  }
  _appendItemToContainer($container, $itemFrame, index2) {
    $itemFrame.appendTo($container);
  }
  _renderItemFrame(index2, itemData, $container, $itemToReplace) {
    const $itemFrame = renderer_default("<div>");
    new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
    if (null !== $itemToReplace && void 0 !== $itemToReplace && $itemToReplace.length) {
      $itemToReplace.replaceWith($itemFrame);
    } else {
      this._appendItemToContainer.call(this, $container, $itemFrame, index2);
    }
    if (this.option("useItemTextAsTitle")) {
      const displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
      $itemFrame.attr("title", displayValue);
    }
    return $itemFrame;
  }
  _itemOptions() {
    return {
      watchMethod: () => this.option("integrationOptions.watchMethod"),
      owner: this,
      fieldGetter: (field) => {
        const expr = this.option(`${field}Expr`);
        const getter = compileGetter(expr);
        return getter;
      }
    };
  }
  _postprocessRenderItem(args) {
  }
  _executeItemRenderAction(index2, itemData, itemElement) {
    this._getItemRenderAction()({
      itemElement,
      itemIndex: index2,
      itemData
    });
  }
  _setElementData(element, data2, index2) {
    element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data2).data(this._itemIndexKey(), index2);
  }
  _createItemRenderAction() {
    this._itemRenderAction = this._createActionByOption("onItemRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    return this._itemRenderAction;
  }
  _getItemRenderAction() {
    return this._itemRenderAction ?? this._createItemRenderAction();
  }
  _getItemTemplateName(args) {
    const data2 = args.itemData;
    const templateProperty = args.templateProperty || this.option("itemTemplateProperty");
    const template = data2 && data2[templateProperty];
    return template || args.defaultTemplateName;
  }
  _createItemByTemplate(itemTemplate, renderArgs) {
    const {
      itemData,
      container,
      index: index2
    } = renderArgs;
    return itemTemplate.render({
      model: itemData,
      container,
      index: index2,
      onRendered: this._onItemTemplateRendered(itemTemplate, renderArgs)
    });
  }
  _onItemTemplateRendered(itemTemplate, renderArgs) {
    return () => {
    };
  }
  _emptyMessageContainer() {
    return this._itemContainer();
  }
  _renderEmptyMessage(rootNodes) {
    const items = rootNodes ?? this.option("items");
    const noDataText = this.option("noDataText");
    const hideNoData = !noDataText || items && items.length || this._dataController.isLoading();
    if (hideNoData && this._$noData) {
      this._$noData.remove();
      this._$noData = null;
      this.setAria("label", void 0);
    }
    if (!hideNoData) {
      this._$noData = this._$noData ?? renderer_default("<div>").addClass("dx-empty-message");
      this._$noData.appendTo(this._emptyMessageContainer());
      if (this.option("encodeNoDataText")) {
        this._$noData.text(noDataText);
      } else {
        this._$noData.html(noDataText);
      }
    }
    this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData);
  }
  _itemDXEventHandler(dxEvent, handlerOptionName, actionArgs, actionConfig) {
    this._itemEventHandler(dxEvent.target, handlerOptionName, extend(actionArgs, {
      event: dxEvent
    }), actionConfig);
  }
  _itemEventHandler(initiator, handlerOptionName, actionArgs, actionConfig) {
    const action = this._createActionByOption(handlerOptionName, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  }
  _itemEventHandlerByHandler(initiator, handler, actionArgs, actionConfig) {
    const action = this._createAction(handler, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  }
  _itemEventHandlerImpl(initiator, action, actionArgs) {
    const $itemElement = this._closestItemElement(renderer_default(initiator));
    const args = extend({}, actionArgs);
    return action(extend(actionArgs, this._extendActionArgs($itemElement), args));
  }
  _extendActionArgs($itemElement) {
    return {
      itemElement: getPublicElement($itemElement),
      itemIndex: this._itemElements().index($itemElement),
      itemData: this._getItemData($itemElement)
    };
  }
  _closestItemElement($element) {
    return renderer_default($element).closest(this._itemSelector());
  }
  _getItemData(itemElement) {
    return renderer_default(itemElement).data(this._itemDataKey());
  }
  _getSummaryItemsSize(dimension, items, includeMargin) {
    let result2 = 0;
    if (items) {
      each(items, (_, item) => {
        if ("width" === dimension) {
          result2 += getOuterWidth(item, includeMargin ?? false);
        } else if ("height" === dimension) {
          result2 += getOuterHeight(item, includeMargin ?? false);
        }
      });
    }
    return result2;
  }
  getFocusedItemId() {
    if (!this._focusedItemId) {
      this._focusedItemId = `dx-${new guid_default2()}`;
    }
    return this._focusedItemId;
  }
  itemElements() {
    return this._itemElements();
  }
  itemsContainer() {
    return this._itemContainer();
  }
};
CollectionWidget.include(data_helper_default);
CollectionWidget.ItemClass = item_default;
var collection_widget_base_default = CollectionWidget;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.js
var EditStrategy = class extends class_default.inherit({}) {
  constructor(collectionWidget) {
    super();
    this._collectionWidget = collectionWidget;
  }
  getIndexByItemData(value2) {
    return class_default.abstract();
  }
  getItemDataByIndex(index2) {
    class_default.abstract();
  }
  getKeysByItems(items) {
    class_default.abstract();
  }
  getItemsByKeys(keys, items) {
    class_default.abstract();
  }
  itemsGetter() {
    class_default.abstract();
  }
  getKeyByIndex(index2) {
    const resultIndex = this._denormalizeItemIndex(index2);
    return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0];
  }
  _equalKeys(key1, key2) {
    if (this._collectionWidget._isKeySpecified()) {
      return equalByValue(key1, key2);
    }
    return key1 === key2;
  }
  beginCache() {
    this._cache = {};
  }
  endCache() {
    this._cache = null;
  }
  getIndexByKey(key) {
    return class_default.abstract();
  }
  getNormalizedIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return value2;
    }
    if (this._isItemIndex(value2)) {
      return this._normalizeItemIndex(value2);
    }
    if (this._isNode(value2)) {
      return this._getNormalizedItemIndex(value2);
    }
    return this._normalizeItemIndex(this.getIndexByItemData(value2));
  }
  getIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._denormalizeItemIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return value2;
    }
    if (this._isNode(value2)) {
      return this._denormalizeItemIndex(this._getNormalizedItemIndex(value2));
    }
    return this.getIndexByItemData(value2);
  }
  getItemElement(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._getItemByNormalizedIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return this._getItemByNormalizedIndex(this._normalizeItemIndex(value2));
    }
    if (this._isNode(value2)) {
      return renderer_default(value2);
    }
    const normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value2));
    return this._getItemByNormalizedIndex(normalizedItemIndex);
  }
  _isNode(el) {
    return dom_adapter_default.isNode(el && isRenderer(el) ? el.get(0) : el);
  }
  deleteItemAtIndex(index2) {
    class_default.abstract();
  }
  itemPlacementFunc(movingIndex, destinationIndex) {
    return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before";
  }
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    class_default.abstract();
  }
  _isNormalizedItemIndex(index2) {
    return "number" === typeof index2 && Math.round(index2) === index2;
  }
  _isItemIndex(index2) {
    return class_default.abstract();
  }
  _getNormalizedItemIndex(value2) {
    return class_default.abstract();
  }
  _normalizeItemIndex(index2) {
    return class_default.abstract();
  }
  _denormalizeItemIndex(index2) {
    return class_default.abstract();
  }
  _getItemByNormalizedIndex(value2) {
    return class_default.abstract();
  }
  _itemsFromSameParent(movingIndex, destinationIndex) {
    return class_default.abstract();
  }
};
var m_collection_widget_edit_strategy_default = EditStrategy;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.plain.js
var PlainEditStrategy = class extends m_collection_widget_edit_strategy_default {
  _getPlainItems() {
    return this._collectionWidget.option("items") || [];
  }
  getIndexByItemData(itemData) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    if (keyOf) {
      return this.getIndexByKey(keyOf(itemData));
    }
    return this._getPlainItems().indexOf(itemData);
  }
  getItemDataByIndex(index2) {
    return this._getPlainItems()[index2];
  }
  deleteItemAtIndex(index2) {
    this._getPlainItems().splice(index2, 1);
  }
  itemsGetter() {
    return this._getPlainItems();
  }
  getKeysByItems(items) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    let result2 = items;
    if (keyOf) {
      result2 = [];
      for (let i = 0; i < items.length; i++) {
        result2.push(keyOf(items[i]));
      }
    }
    return result2;
  }
  getIndexByKey(key) {
    const cache = this._cache;
    const keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
    if (cache && !cache.keys) {
      cache.keys = keys;
    }
    if ("object" === typeof key) {
      for (let i = 0, {
        length
      } = keys; i < length; i++) {
        if (this._equalKeys(key, keys[i])) {
          return i;
        }
      }
    } else {
      return keys.indexOf(key);
    }
    return -1;
  }
  getItemsByKeys(keys, items) {
    return (items || keys).slice();
  }
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    const items = this._getPlainItems();
    const movedItemData = items[movingIndex];
    items.splice(movingIndex, 1);
    items.splice(destinationIndex, 0, movedItemData);
  }
  _isItemIndex(index2) {
    return "number" === typeof index2 && Math.round(index2) === index2;
  }
  _getNormalizedItemIndex(itemElement) {
    return this._collectionWidget._itemElements().index(itemElement);
  }
  _normalizeItemIndex(index2) {
    return index2;
  }
  _denormalizeItemIndex(index2) {
    return index2;
  }
  _getItemByNormalizedIndex(index2) {
    return index2 > -1 ? this._collectionWidget._itemElements().eq(index2) : null;
  }
  _itemsFromSameParent(firstIndex, secondIndex) {
    return true;
  }
};
var m_collection_widget_edit_strategy_plain_default = PlainEditStrategy;

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.js
var SelectionStrategy = class {
  constructor(options2) {
    this._lastSelectAllPageDeferred = Deferred().reject();
    this.options = options2;
    this._setOption("disabledItemKeys", []);
    this._clearItemKeys();
  }
  _clearItemKeys() {
    this._setOption("addedItemKeys", []);
    this._setOption("removedItemKeys", []);
    this._setOption("removedItems", []);
    this._setOption("addedItems", []);
  }
  validate() {
  }
  _setOption(name2, value2) {
    this.options[name2] = value2;
  }
  onSelectionChanging() {
    const {
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems,
      onSelectionChanging = noop2
    } = this.options;
    const selectionChangingArgs = {
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems,
      cancel: false
    };
    onSelectionChanging(selectionChangingArgs);
    return selectionChangingArgs.cancel;
  }
  _callCallbackIfNotCanceled(callback, cancelCallback) {
    const cancelResult = this.onSelectionChanging();
    if (isPromise(cancelResult)) {
      cancelResult.then((cancel2) => {
        if (!cancel2) {
          callback();
        } else {
          cancelCallback();
        }
      }).catch(() => {
        callback();
      });
    } else if (!cancelResult) {
      callback();
    } else {
      cancelCallback();
    }
  }
  onSelectionChanged() {
    const {
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems,
      onSelectionChanged = noop2
    } = this.options;
    this._clearItemKeys();
    onSelectionChanged({
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems
    });
  }
  equalKeys(key1, key2) {
    if (this.options.equalByReference) {
      if (isObject(key1) && isObject(key2)) {
        return key1 === key2;
      }
    }
    return equalByValue(key1, key2);
  }
  getSelectableItems(items) {
    return items.filter((item) => !(null !== item && void 0 !== item && item.disabled));
  }
  _clearSelection(keys, preserve, isDeselect, isSelectAll) {
    keys = keys || [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll);
  }
  _removeTemplateProperty(remoteFilter) {
    if (Array.isArray(remoteFilter)) {
      return remoteFilter.map((f) => this._removeTemplateProperty(f));
    }
    if (isObject(remoteFilter)) {
      delete remoteFilter.template;
    }
    return remoteFilter;
  }
  _getQueryParams() {
    const {
      sensitivity
    } = this.options;
    if (!sensitivity) {
      return;
    }
    return {
      langParams: {
        collatorOptions: {
          sensitivity
        }
      }
    };
  }
  _loadFilteredData(remoteFilter, localFilter, select, isSelectAll) {
    const filterLength = encodeURI(JSON.stringify(this._removeTemplateProperty(remoteFilter))).length;
    const needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
    const deferred = Deferred();
    const queryParams = this._getQueryParams();
    const loadOptions = _extends({
      filter: needLoadAllData ? void 0 : remoteFilter,
      select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
    }, queryParams);
    if (remoteFilter && 0 === remoteFilter.length) {
      deferred.resolve([]);
    } else {
      this.options.load(loadOptions).done((items) => {
        let filteredItems = isPlainObject(items) ? items.data : items;
        if (localFilter && !isSelectAll) {
          filteredItems = filteredItems.filter(localFilter);
        } else if (needLoadAllData) {
          filteredItems = m_query_default(filteredItems).filter(remoteFilter).toArray();
        }
        deferred.resolve(filteredItems);
      }).fail(deferred.reject.bind(deferred));
    }
    return deferred;
  }
  updateSelectedItemKeyHash(keys) {
    for (let i = 0; i < keys.length; i++) {
      const keyHash = getKeyHash(keys[i]);
      if (!isObject(keyHash)) {
        this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
        const keyIndices = this.options.keyHashIndices[keyHash];
        keyIndices.push(i);
      }
    }
  }
  _isAnyItemSelected(items) {
    for (let i = 0; i < items.length; i++) {
      if (this.options.isItemSelected(items[i])) {
        return;
      }
    }
    return false;
  }
  _getFullSelectAllState() {
    const items = this.options.plainItems();
    const dataFilter = this.options.filter();
    let selectedItems = this.options.ignoreDisabledItems ? this.options.selectedItems : this.options.selectedItems.filter((item) => !(null !== item && void 0 !== item && item.disabled));
    if (dataFilter) {
      selectedItems = m_query_default(selectedItems).filter(dataFilter).toArray();
    }
    const selectedItemsLength = selectedItems.length;
    const disabledItemsLength = items.length - this.getSelectableItems(items).length;
    if (!selectedItemsLength) {
      return this._isAnyItemSelected(items);
    }
    if (selectedItemsLength >= this.options.totalCount() - disabledItemsLength) {
      return true;
    }
    return;
  }
  _getVisibleSelectAllState() {
    const items = this.getSelectableItems(this.options.plainItems());
    let hasSelectedItems = false;
    let hasUnselectedItems = false;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemData = this.options.getItemData(item);
      const key = this.options.keyOf(itemData);
      if (this.options.isSelectableItem(item)) {
        if (this.isItemKeySelected(key)) {
          hasSelectedItems = true;
        } else {
          hasUnselectedItems = true;
        }
      }
    }
    if (hasSelectedItems) {
      return !hasUnselectedItems ? true : void 0;
    }
    return false;
  }
  isItemKeySelected(itemKey) {
    throw new Error("isItemKeySelected method should be overriden");
  }
  addSelectedItem(itemKey, itemData) {
    throw new Error("addSelectedItem method should be overriden");
  }
  removeSelectedItem(itemKey) {
    throw new Error("removeSelectedItem method should be overriden");
  }
  _selectAllPlainItems(isDeselect) {
    const items = this.getSelectableItems(this.options.plainItems());
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (this.options.isSelectableItem(item)) {
        const itemData = this.options.getItemData(item);
        const itemKey = this.options.keyOf(itemData);
        const isSelected = this.isItemKeySelected(itemKey);
        if (!isSelected && !isDeselect) {
          this.addSelectedItem(itemKey, itemData);
        }
        if (isSelected && isDeselect) {
          this.removeSelectedItem(itemKey);
        }
      }
    }
  }
};

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.deferred.js
var DeferredStrategy = class extends SelectionStrategy {
  getSelectedItems() {
    return this._loadFilteredData(this.options.selectionFilter);
  }
  getSelectedItemKeys() {
    const d = Deferred();
    const that = this;
    const key = this.options.key();
    const select = isString(key) ? [key] : key;
    this._loadFilteredData(this.options.selectionFilter, null, select).done((items) => {
      const keys = items.map((item) => that.options.keyOf(item));
      d.resolve(keys);
    }).fail(d.reject);
    return d.promise();
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll) {
    if (isSelectAll) {
      const filter = this.options.filter();
      const needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;
      if (needResetSelectionFilter) {
        this._setOption("selectionFilter", isDeselect ? [] : null);
      } else {
        this._addSelectionFilter(isDeselect, filter, isSelectAll);
      }
    } else {
      if (!preserve) {
        this._setOption("selectionFilter", []);
      }
      for (let i = 0; i < keys.length; i++) {
        if (isDeselect) {
          this.removeSelectedItem(keys[i]);
        } else {
          this.addSelectedItem(keys[i], isSelectAll, !preserve);
        }
      }
    }
    this.onSelectionChanged();
    return Deferred().resolve();
  }
  setSelectedItems(keys) {
    this._setOption("selectionFilter", null);
    for (let i = 0; i < keys.length; i++) {
      this.addSelectedItem(keys[i]);
    }
  }
  isItemDataSelected(itemData) {
    return this.isItemKeySelected(itemData);
  }
  isItemKeySelected(itemData) {
    const {
      selectionFilter
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    const queryParams = this._getQueryParams();
    return !!m_query_default([itemData], queryParams).filter(selectionFilter).toArray().length;
  }
  _getKeyExpr() {
    const keyField = this.options.key();
    if (Array.isArray(keyField) && 1 === keyField.length) {
      return keyField[0];
    }
    return keyField;
  }
  _normalizeKey(key) {
    const keyExpr = this.options.key();
    if (Array.isArray(keyExpr) && 1 === keyExpr.length) {
      return key[keyExpr[0]];
    }
    return key;
  }
  _getFilterByKey(key) {
    const keyField = this._getKeyExpr();
    let filter = [keyField, "=", this._normalizeKey(key)];
    if (Array.isArray(keyField)) {
      filter = [];
      for (let i = 0; i < keyField.length; i++) {
        filter.push([keyField[i], "=", key[keyField[i]]]);
        if (i !== keyField.length - 1) {
          filter.push("and");
        }
      }
    }
    return filter;
  }
  addSelectedItem(key, isSelectAll, skipFilter) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(false, filter, isSelectAll, skipFilter);
  }
  removeSelectedItem(key) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(true, filter);
  }
  validate() {
    const {
      key
    } = this.options;
    if (key && void 0 === key()) {
      throw ui_errors_default.Error("E1042", "Deferred selection");
    }
  }
  _findSubFilter(selectionFilter, filter) {
    if (!selectionFilter) {
      return -1;
    }
    const filterString = JSON.stringify(filter);
    for (let index2 = 0; index2 < selectionFilter.length; index2++) {
      const subFilter = selectionFilter[index2];
      if (subFilter && JSON.stringify(subFilter) === filterString) {
        return index2;
      }
    }
    return -1;
  }
  _isLastSubFilter(selectionFilter, filter) {
    if (selectionFilter && filter) {
      return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || 0 === this._findSubFilter([selectionFilter], filter);
    }
    return false;
  }
  _addFilterOperator(selectionFilter, filterOperator) {
    if (selectionFilter.length > 1 && isString(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
      selectionFilter = [selectionFilter];
    }
    if (selectionFilter.length) {
      selectionFilter.push(filterOperator);
    }
    return selectionFilter;
  }
  _denormalizeFilter(filter) {
    if (filter && isString(filter[0])) {
      filter = [filter];
    }
    return filter;
  }
  _isOnlyNegativeFiltersLeft(filters) {
    return filters.every((filterItem, i) => {
      if (i % 2 === 0) {
        return Array.isArray(filterItem) && "!" === filterItem[0];
      }
      return "and" === filterItem;
    });
  }
  _addSelectionFilter(isDeselect, filter, isSelectAll, skipFilter) {
    var _selectionFilter;
    const that = this;
    const currentFilter = isDeselect ? ["!", filter] : filter;
    const currentOperation = isDeselect ? "and" : "or";
    let needAddFilter = true;
    let selectionFilter = that.options.selectionFilter || [];
    selectionFilter = that._denormalizeFilter(selectionFilter);
    if (null !== (_selectionFilter = selectionFilter) && void 0 !== _selectionFilter && _selectionFilter.length && !skipFilter) {
      const removedIndex = that._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
      const filterIndex = that._removeSameFilter(selectionFilter, filter, !isDeselect);
      const shouldCleanFilter = isDeselect && (-1 !== removedIndex || -1 !== filterIndex) && this._isOnlyNegativeFiltersLeft(selectionFilter);
      if (shouldCleanFilter) {
        selectionFilter = [];
      }
      const isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
      needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
    }
    if (needAddFilter) {
      selectionFilter = that._addFilterOperator(selectionFilter, currentOperation);
      selectionFilter.push(currentFilter);
    }
    selectionFilter = that._normalizeFilter(selectionFilter);
    that._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter);
  }
  _normalizeFilter(filter) {
    if (filter && 1 === filter.length) {
      filter = filter[0];
    }
    return filter;
  }
  _removeFilterByIndex(filter, filterIndex, isSelectAll) {
    const operation = filter[1];
    if (filterIndex > 0) {
      filter.splice(filterIndex - 1, 2);
    } else {
      filter.splice(filterIndex, 2);
    }
    if (isSelectAll && "and" === operation) {
      filter.splice(0, filter.length);
    }
  }
  _isSimpleKeyFilter(filter, key) {
    return 3 === filter.length && filter[0] === key && "=" === filter[1];
  }
  _isKeyFilter(filter) {
    if (2 === filter.length && "!" === filter[0]) {
      return this._isKeyFilter(filter[1]);
    }
    const keyField = this._getKeyExpr();
    if (Array.isArray(keyField)) {
      if (filter.length !== 2 * keyField.length - 1) {
        return false;
      }
      for (let i = 0; i < keyField.length; i++) {
        if (i > 0 && "and" !== filter[2 * i - 1]) {
          return false;
        }
        if (!this._isSimpleKeyFilter(filter[2 * i], keyField[i])) {
          return false;
        }
      }
      return true;
    }
    return this._isSimpleKeyFilter(filter, keyField);
  }
  _hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex) {
    if (filterIndex >= 0) {
      for (let i = filterIndex; i < selectionFilter.length; i++) {
        if ("string" !== typeof selectionFilter[i] && !this._isKeyFilter(selectionFilter[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  _removeSameFilter(selectionFilter, filter, inverted, isSelectAll) {
    filter = inverted ? ["!", filter] : filter;
    if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
      selectionFilter.splice(0, selectionFilter.length);
      return 0;
    }
    const filterIndex = this._findSubFilter(selectionFilter, filter);
    if (filterIndex >= 0) {
      this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
      return filterIndex;
    }
    for (let i = 0; i < selectionFilter.length; i++) {
      if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
        const filterIndex2 = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
        if (filterIndex2 >= 0) {
          if (!selectionFilter[i].length) {
            this._removeFilterByIndex(selectionFilter, i, isSelectAll);
          } else if (1 === selectionFilter[i].length) {
            selectionFilter[i] = selectionFilter[i][0];
          }
          return filterIndex2;
        }
      }
    }
    return -1;
  }
  getSelectAllState() {
    const filter = this.options.filter();
    let {
      selectionFilter
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    if (!selectionFilter.length) {
      return false;
    }
    if (!filter || !filter.length) {
      return;
    }
    selectionFilter = this._denormalizeFilter(selectionFilter);
    if (this._isLastSubFilter(selectionFilter, filter)) {
      return true;
    }
    if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
      return false;
    }
    return;
  }
  loadSelectedItemsWithFilter() {
    const componentFilter = this.options.filter();
    const {
      selectionFilter
    } = this.options;
    const filter = componentFilter ? [componentFilter, "and", selectionFilter] : selectionFilter;
    return this._loadFilteredData(filter);
  }
  _onePageSelectAll(isDeselect) {
    this._selectAllPlainItems(isDeselect);
    this.onSelectionChanged();
    return Deferred().resolve();
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_array_compare.js
var isKeysEqual = function(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) {
    return false;
  }
  for (let i = 0; i < newKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      return false;
    }
  }
  return true;
};

// node_modules/devextreme/esm/__internal/core/utils/m_selection_filter.js
var SelectionFilterCreator = function(selectedItemKeys, isSelectAll) {
  this.getLocalFilter = function(keyGetter, equalKeys, equalByReference, keyExpr) {
    equalKeys = void 0 === equalKeys ? equalByValue : equalKeys;
    return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr);
  };
  this.getExpr = function(keyExpr) {
    if (!keyExpr) {
      return;
    }
    let filterExpr;
    selectedItemKeys.forEach(function(key, index2) {
      filterExpr = filterExpr || [];
      let filterExprPart;
      if (index2 > 0) {
        filterExpr.push(isSelectAll ? "and" : "or");
      }
      if (isString(keyExpr) || isFunction(keyExpr)) {
        filterExprPart = getFilterForPlainKey(keyExpr, key);
      } else {
        filterExprPart = function(keyExpr2, itemKeyValue) {
          const filterExpr2 = [];
          for (let i = 0, {
            length
          } = keyExpr2; i < length; i++) {
            const currentKeyExpr = keyExpr2[i];
            const keyValueGetter = compileGetter(currentKeyExpr);
            const currentKeyValue = itemKeyValue && keyValueGetter(itemKeyValue);
            const filterExprPart2 = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
            if (!filterExprPart2) {
              break;
            }
            if (i > 0) {
              filterExpr2.push(isSelectAll ? "or" : "and");
            }
            filterExpr2.push(filterExprPart2);
          }
          return filterExpr2;
        }(keyExpr, key);
      }
      filterExpr.push(filterExprPart);
    });
    if (filterExpr && 1 === filterExpr.length) {
      filterExpr = filterExpr[0];
    }
    return filterExpr;
  };
  this.getCombinedFilter = function(keyExpr, dataSourceFilter) {
    let forceCombinedFilter = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    const filterExpr = this.getExpr(keyExpr);
    let combinedFilter = filterExpr;
    if ((forceCombinedFilter || isSelectAll) && dataSourceFilter) {
      if (filterExpr) {
        combinedFilter = [];
        combinedFilter.push(filterExpr);
        combinedFilter.push(dataSourceFilter);
      } else {
        combinedFilter = dataSourceFilter;
      }
    }
    return combinedFilter;
  };
  let selectedItemKeyHashesMap;
  const getSelectedItemKeyHashesMap = function(keyOf, keyExpr) {
    if (!selectedItemKeyHashesMap) {
      selectedItemKeyHashesMap = {};
      const normalizedKeys = normalizeKeys(selectedItemKeys, keyOf, keyExpr);
      for (let i = 0; i < normalizedKeys.length; i++) {
        selectedItemKeyHashesMap[getKeyHash(normalizedKeys[i])] = true;
      }
    }
    return selectedItemKeyHashesMap;
  };
  const normalizeKeys = function(keys, keyOf, keyExpr) {
    return Array.isArray(keyExpr) ? keys.map((key) => keyOf(key)) : keys;
  };
  function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
    const key = keyOf(item);
    let keyHash;
    let i;
    if (!equalByReference) {
      keyHash = getKeyHash(key);
      if (!isObject(keyHash)) {
        const selectedKeyHashesMap = getSelectedItemKeyHashesMap(keyOf, keyExpr);
        if (selectedKeyHashesMap[keyHash]) {
          return !isSelectAll;
        }
        return !!isSelectAll;
      }
    }
    for (i = 0; i < selectedItemKeys.length; i++) {
      if (equalKeys(selectedItemKeys[i], key)) {
        return !isSelectAll;
      }
    }
    return !!isSelectAll;
  }
  function getFilterForPlainKey(keyExpr, keyValue) {
    if (void 0 === keyValue) {
      return;
    }
    return [keyExpr, isSelectAll ? "<>" : "=", keyValue];
  }
};

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.standard.js
var StandardStrategy = class extends SelectionStrategy {
  constructor(options2) {
    super(options2);
    this._lastSelectAllPageDeferred = Deferred().reject();
    this._initSelectedItemKeyHash();
  }
  _initSelectedItemKeyHash() {
    this._setOption("keyHashIndices", this.options.equalByReference ? null : {});
  }
  getSelectedItemKeys() {
    return this.options.selectedItemKeys.slice(0);
  }
  getSelectedItems() {
    return this.options.selectedItems.slice(0);
  }
  _preserveSelectionUpdate(items, isDeselect) {
    const {
      keyOf
    } = this.options;
    let keyIndicesToRemoveMap;
    let keyIndex;
    let i;
    if (!keyOf) {
      return;
    }
    const isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
    if (isBatchDeselect) {
      keyIndicesToRemoveMap = {};
    }
    for (i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      if (isDeselect) {
        keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap, null === item || void 0 === item ? void 0 : item.disabled);
        if (keyIndicesToRemoveMap && keyIndex >= 0) {
          keyIndicesToRemoveMap[keyIndex] = true;
        }
      } else {
        this.addSelectedItem(key, item);
      }
    }
    if (isBatchDeselect) {
      this._batchRemoveSelectedItems(keyIndicesToRemoveMap);
    }
  }
  _batchRemoveSelectedItems(keyIndicesToRemoveMap) {
    const selectedItemKeys = this.options.selectedItemKeys.slice(0);
    const selectedItems = this.options.selectedItems.slice(0);
    this.options.selectedItemKeys.length = 0;
    this.options.selectedItems.length = 0;
    for (let i = 0; i < selectedItemKeys.length; i++) {
      if (!keyIndicesToRemoveMap[i]) {
        this.options.selectedItemKeys.push(selectedItemKeys[i]);
        this.options.selectedItems.push(selectedItems[i]);
      }
    }
    this._initSelectedItemKeyHash();
    this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  }
  _loadSelectedItemsCore(keys, isDeselect, isSelectAll, filter) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    let deferred = Deferred();
    const key = this.options.key();
    if (!keys.length && !isSelectAll) {
      deferred.resolve([]);
      return deferred;
    }
    if (isSelectAll && isDeselect && !filter) {
      deferred.resolve(this.getSelectedItems());
      return deferred;
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys, isSelectAll);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter, forceCombinedFilter);
    let deselectedItems = [];
    if (isDeselect) {
      const {
        selectedItems
      } = this.options;
      deselectedItems = combinedFilter && keys.length !== selectedItems.length ? m_query_default(selectedItems).filter(combinedFilter).toArray() : selectedItems.slice(0);
    }
    let filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
    const localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
    filteredItems = filteredItems.filter(localFilter);
    if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
      deferred.resolve(filteredItems);
    } else {
      deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll);
    }
    return deferred;
  }
  _replaceSelectionUpdate(items) {
    const internalKeys = [];
    const {
      keyOf
    } = this.options;
    if (!keyOf) {
      return;
    }
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      internalKeys.push(key);
    }
    this.setSelectedItems(internalKeys, items);
  }
  _warnOnIncorrectKeys(keys) {
    const {
      allowNullValue
    } = this.options;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if ((!allowNullValue || null !== key) && !this.isItemKeySelected(key)) {
        ui_errors_default.log("W1002", key);
      }
    }
  }
  _isMultiSelectEnabled() {
    const {
      mode
    } = this.options;
    return "all" === mode || "multiple" === mode;
  }
  _requestInProgress() {
    var _this$_lastLoadDeferr;
    return "pending" === (null === (_this$_lastLoadDeferr = this._lastLoadDeferred) || void 0 === _this$_lastLoadDeferr ? void 0 : _this$_lastLoadDeferr.state());
  }
  _concatRequestsItems(keys, isDeselect, oldRequestItems, updatedKeys) {
    let selectedItems;
    const deselectedItems = isDeselect ? keys : [];
    if (updatedKeys) {
      selectedItems = updatedKeys;
    } else {
      selectedItems = removeDuplicates(keys, this.options.selectedItemKeys);
    }
    return {
      addedItems: oldRequestItems.added.concat(selectedItems),
      removedItems: oldRequestItems.removed.concat(deselectedItems),
      keys
    };
  }
  _collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys) {
    const isDeselectAll = isDeselect && isSelectAll;
    const oldRequestItems = {
      added: [],
      removed: []
    };
    const multiSelectEnabled = this._isMultiSelectEnabled();
    let lastRequestData = multiSelectEnabled ? this._lastRequestData : {};
    if (multiSelectEnabled) {
      if (this._shouldMergeWithLastRequest) {
        if (isDeselectAll) {
          this._lastLoadDeferred.reject();
          lastRequestData = {};
        } else if (!isKeysEqual(keys, this.options.selectedItemKeys)) {
          oldRequestItems.added = lastRequestData.addedItems;
          oldRequestItems.removed = lastRequestData.removedItems;
          if (!isDeselect) {
            this._lastLoadDeferred.reject();
          }
        }
      }
      lastRequestData = this._concatRequestsItems(keys, isDeselect, oldRequestItems, this._shouldMergeWithLastRequest ? void 0 : updatedKeys);
    }
    return lastRequestData;
  }
  _updateKeysByLastRequestData(keys, isDeselect, isSelectAll) {
    let currentKeys = keys;
    if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !isDeselect && !isSelectAll) {
      var _this$_lastRequestDat, _this$_lastRequestDat2;
      currentKeys = removeDuplicates(keys.concat(null === (_this$_lastRequestDat = this._lastRequestData) || void 0 === _this$_lastRequestDat ? void 0 : _this$_lastRequestDat.addedItems), null === (_this$_lastRequestDat2 = this._lastRequestData) || void 0 === _this$_lastRequestDat2 ? void 0 : _this$_lastRequestDat2.removedItems);
      currentKeys = getUniqueValues(currentKeys);
    }
    return currentKeys;
  }
  _loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    const that = this;
    const deferred = Deferred();
    const filter = that.options.filter();
    this._shouldMergeWithLastRequest = this._requestInProgress();
    this._lastRequestData = this._collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys);
    when(that._lastLoadDeferred).always(() => {
      const currentKeys = that._updateKeysByLastRequestData(keys, isDeselect, isSelectAll);
      that._shouldMergeWithLastRequest = false;
      that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll, filter, forceCombinedFilter).done(deferred.resolve).fail(deferred.reject);
    });
    that._lastLoadDeferred = deferred;
    return deferred;
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : false;
    if (this._isCancelingInProgress) {
      return Deferred().reject();
    }
    const loadingDeferred = this._loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys, forceCombinedFilter);
    const selectionDeferred = Deferred();
    loadingDeferred.done((items) => {
      this._storeSelectionState();
      if (preserve) {
        this._preserveSelectionUpdate(items, isDeselect);
      } else {
        this._replaceSelectionUpdate(items);
      }
      this._isCancelingInProgress = true;
      this._callCallbackIfNotCanceled(() => {
        this._isCancelingInProgress = false;
        this.onSelectionChanged();
        selectionDeferred.resolve(items);
      }, () => {
        this._isCancelingInProgress = false;
        this._restoreSelectionState();
        selectionDeferred.reject();
      });
    });
    return selectionDeferred;
  }
  addSelectedItem(key, itemData) {
    if (isDefined(itemData) && !this.options.ignoreDisabledItems && itemData.disabled) {
      if (-1 === this.options.disabledItemKeys.indexOf(key)) {
        this.options.disabledItemKeys.push(key);
      }
      return;
    }
    const keyHash = this._getKeyHash(key);
    if (-1 === this._indexOfSelectedItemKey(keyHash)) {
      if (!isObject(keyHash) && this.options.keyHashIndices) {
        this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length];
      }
      this.options.selectedItemKeys.push(key);
      this.options.addedItemKeys.push(key);
      this.options.addedItems.push(itemData);
      this.options.selectedItems.push(itemData);
    }
  }
  _getSelectedIndexByKey(key, ignoreIndicesMap) {
    const {
      selectedItemKeys
    } = this.options;
    for (let index2 = 0; index2 < selectedItemKeys.length; index2++) {
      if ((!ignoreIndicesMap || !ignoreIndicesMap[index2]) && this.equalKeys(selectedItemKeys[index2], key)) {
        return index2;
      }
    }
    return -1;
  }
  _getSelectedIndexByHash(key, ignoreIndicesMap) {
    let indices = this.options.keyHashIndices[key];
    if (indices && indices.length > 1 && ignoreIndicesMap) {
      indices = indices.filter((index2) => !ignoreIndicesMap[index2]);
    }
    return indices && indices[0] >= 0 ? indices[0] : -1;
  }
  _indexOfSelectedItemKey(key, ignoreIndicesMap) {
    let selectedIndex;
    if (this.options.equalByReference) {
      selectedIndex = this.options.selectedItemKeys.indexOf(key);
    } else if (isObject(key)) {
      selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap);
    } else {
      selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap);
    }
    return selectedIndex;
  }
  _shiftSelectedKeyIndices(keyIndex) {
    for (let currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
      const currentKey = this.options.selectedItemKeys[currentKeyIndex];
      const currentKeyHash = getKeyHash(currentKey);
      const currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
      if (!currentKeyIndices) {
        continue;
      }
      for (let i = 0; i < currentKeyIndices.length; i++) {
        if (currentKeyIndices[i] > keyIndex) {
          currentKeyIndices[i]--;
        }
      }
    }
  }
  removeSelectedItem(key, keyIndicesToRemoveMap, isDisabled) {
    if (!this.options.ignoreDisabledItems && isDisabled) {
      return;
    }
    const keyHash = this._getKeyHash(key);
    const isBatchDeselect = !!keyIndicesToRemoveMap;
    const keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
    if (keyIndex < 0) {
      return keyIndex;
    }
    this.options.removedItemKeys.push(key);
    this.options.removedItems.push(this.options.selectedItems[keyIndex]);
    if (isBatchDeselect) {
      return keyIndex;
    }
    this.options.selectedItemKeys.splice(keyIndex, 1);
    this.options.selectedItems.splice(keyIndex, 1);
    if (isObject(keyHash) || !this.options.keyHashIndices) {
      return keyIndex;
    }
    const keyIndices = this.options.keyHashIndices[keyHash];
    if (!keyIndices) {
      return keyIndex;
    }
    keyIndices.shift();
    if (!keyIndices.length) {
      delete this.options.keyHashIndices[keyHash];
    }
    this._shiftSelectedKeyIndices(keyIndex);
    return keyIndex;
  }
  _updateAddedItemKeys(keys, items) {
    for (let i = 0; i < keys.length; i++) {
      if (!this.isItemKeySelected(keys[i])) {
        this.options.addedItemKeys.push(keys[i]);
        this.options.addedItems.push(items[i]);
      }
    }
  }
  _updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems) {
    for (let i = 0; i < oldSelectedKeys.length; i++) {
      if (!this.isItemKeySelected(oldSelectedKeys[i])) {
        this.options.removedItemKeys.push(oldSelectedKeys[i]);
        this.options.removedItems.push(oldSelectedItems[i]);
      }
    }
  }
  _isItemSelectionInProgress(key, checkPending) {
    const shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();
    if (shouldCheckPending) {
      const addedItems = this._lastRequestData.addedItems ?? [];
      return addedItems.includes(key);
    }
    return false;
  }
  _getKeyHash(key) {
    return this.options.equalByReference ? key : getKeyHash(key);
  }
  setSelectedItems(keys, items) {
    this._updateAddedItemKeys(keys, items);
    const oldSelectedKeys = this.options.selectedItemKeys;
    const oldSelectedItems = this.options.selectedItems;
    if (!this.options.equalByReference) {
      this._initSelectedItemKeyHash();
      this.updateSelectedItemKeyHash(keys);
    }
    this._setOption("selectedItemKeys", keys);
    this._setOption("selectedItems", items);
    this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems);
  }
  isItemDataSelected(itemData) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const key = this.options.keyOf(itemData);
    return this.isItemKeySelected(key, options2);
  }
  isItemKeySelected(key) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    let result2 = this._isItemSelectionInProgress(key, options2.checkPending);
    if (!result2) {
      const keyHash = this._getKeyHash(key);
      const index2 = this._indexOfSelectedItemKey(keyHash);
      result2 = -1 !== index2;
    }
    return result2;
  }
  getSelectAllState(visibleOnly) {
    if (visibleOnly) {
      return this._getVisibleSelectAllState();
    }
    return this._getFullSelectAllState();
  }
  loadSelectedItemsWithFilter() {
    const keyExpr = this.options.key();
    const keys = this.getSelectedItemKeys();
    const filter = this.options.filter();
    if (!keys.length) {
      return Deferred().resolve([]);
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(keyExpr, filter, true);
    return this._loadFilteredData(combinedFilter);
  }
  _storeSelectionState() {
    const {
      selectedItems,
      selectedItemKeys,
      keyHashIndices
    } = this.options;
    this._storedSelectionState = {
      keyHashIndices: JSON.stringify(keyHashIndices),
      selectedItems: [...selectedItems],
      selectedItemKeys: [...selectedItemKeys]
    };
  }
  _restoreSelectionState() {
    this._clearItemKeys();
    const {
      selectedItemKeys,
      selectedItems,
      keyHashIndices
    } = this._storedSelectionState;
    this._setOption("selectedItemKeys", selectedItemKeys);
    this._setOption("selectedItems", selectedItems);
    this._setOption("keyHashIndices", JSON.parse(keyHashIndices));
  }
  _onePageSelectAll(isDeselect) {
    if ("pending" === this._lastSelectAllPageDeferred.state()) {
      return Deferred().reject();
    }
    this._storeSelectionState();
    this._selectAllPlainItems(isDeselect);
    this._lastSelectAllPageDeferred = Deferred();
    this._callCallbackIfNotCanceled(() => {
      this.onSelectionChanged();
      this._lastSelectAllPageDeferred.resolve();
    }, () => {
      this._restoreSelectionState();
      this._lastSelectAllPageDeferred.reject();
    });
    return this._lastSelectAllPageDeferred;
  }
};

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.js
var Selection = class {
  constructor(options2) {
    this.options = extend(this._getDefaultOptions(), options2, {
      selectedItemKeys: options2.selectedKeys || []
    });
    this._selectionStrategy = this.options.deferred ? new DeferredStrategy(this.options) : new StandardStrategy(this.options);
    this._focusedItemIndex = -1;
    if (!this.options.equalByReference) {
      this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
    }
  }
  _getDefaultOptions() {
    return {
      allowNullValue: false,
      deferred: false,
      equalByReference: false,
      mode: "multiple",
      selectedItems: [],
      selectionFilter: [],
      maxFilterLengthInRequest: 0,
      onSelectionChanged: noop2,
      key: noop2,
      keyOf: (item) => item,
      load: () => Deferred().resolve([]),
      totalCount: () => -1,
      isSelectableItem: () => true,
      isItemSelected: () => false,
      getItemData: (item) => item,
      dataFields: noop2,
      filter: noop2
    };
  }
  validate() {
    this._selectionStrategy.validate();
  }
  getSelectedItemKeys() {
    return this._selectionStrategy.getSelectedItemKeys();
  }
  getSelectedItems() {
    return this._selectionStrategy.getSelectedItems();
  }
  selectionFilter(value2) {
    if (void 0 === value2) {
      return this.options.selectionFilter;
    }
    const filterIsChanged = this.options.selectionFilter !== value2 && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value2);
    this.options.selectionFilter = value2;
    filterIsChanged && this.onSelectionChanged();
  }
  setSelection(keys, updatedKeys) {
    return this.selectedItemKeys(keys, false, false, false, updatedKeys);
  }
  select(keys) {
    return this.selectedItemKeys(keys, true);
  }
  deselect(keys) {
    return this.selectedItemKeys(keys, true, true);
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    keys = keys ?? [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys);
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  _addSelectedItem(itemData, key) {
    this._selectionStrategy.addSelectedItem(key, itemData);
  }
  _removeSelectedItem(key) {
    this._selectionStrategy.removeSelectedItem(key);
  }
  _setSelectedItems(keys, items) {
    this._selectionStrategy.setSelectedItems(keys, items);
  }
  onSelectionChanged() {
    this._selectionStrategy.onSelectionChanged();
  }
  changeItemSelection(itemIndex, keys, setFocusOnly) {
    var _this$options$allowLo, _this$options;
    let isSelectedItemsChanged;
    const items = this.options.plainItems();
    const item = items[itemIndex];
    let deferred;
    const {
      isVirtualPaging
    } = this.options;
    const allowLoadByRange = null === (_this$options$allowLo = (_this$options = this.options).allowLoadByRange) || void 0 === _this$options$allowLo ? void 0 : _this$options$allowLo.call(_this$options);
    const {
      alwaysSelectByShift
    } = this.options;
    let indexOffset;
    let focusedItemNotInLoadedRange = false;
    let shiftFocusedItemNotInLoadedRange = false;
    const itemIsNotInLoadedRange = (index2) => index2 >= 0 && !items.filter((it) => it.loadIndex === index2).length;
    if (isVirtualPaging && isDefined(item)) {
      if (allowLoadByRange) {
        indexOffset = item.loadIndex - itemIndex;
        itemIndex = item.loadIndex;
      }
      focusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._focusedItemIndex);
      if (isDefined(this._shiftFocusedItemIndex)) {
        shiftFocusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._shiftFocusedItemIndex);
      }
    }
    if (!this.isSelectable() || !this.isDataItem(item)) {
      return false;
    }
    const itemData = this.options.getItemData(item);
    const itemKey = this.options.keyOf(itemData);
    keys = keys || {};
    let allowSelectByShift = keys.shift;
    if (false === alwaysSelectByShift && allowSelectByShift) {
      allowSelectByShift = false !== allowLoadByRange || !focusedItemNotInLoadedRange && !shiftFocusedItemNotInLoadedRange;
    }
    if (allowSelectByShift && "multiple" === this.options.mode && this._focusedItemIndex >= 0) {
      if (allowLoadByRange && (focusedItemNotInLoadedRange || shiftFocusedItemNotInLoadedRange)) {
        isSelectedItemsChanged = itemIndex !== this._shiftFocusedItemIndex || this._focusedItemIndex !== this._shiftFocusedItemIndex;
        if (isSelectedItemsChanged) {
          deferred = this.changeItemSelectionWhenShiftKeyInVirtualPaging(itemIndex);
        }
      } else {
        isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset);
      }
    } else if (keys.control) {
      this._resetItemSelectionWhenShiftKeyPressed();
      if (!setFocusOnly) {
        const isSelected = this._selectionStrategy.isItemDataSelected(itemData);
        if ("single" === this.options.mode) {
          this.clearSelectedItems();
        }
        if (isSelected) {
          this._removeSelectedItem(itemKey);
        } else {
          this._addSelectedItem(itemData, itemKey);
        }
      }
      isSelectedItemsChanged = true;
    } else {
      this._resetItemSelectionWhenShiftKeyPressed();
      const isKeysEqual2 = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
      if (1 !== this.options.selectedItemKeys.length || !isKeysEqual2) {
        this._setSelectedItems([itemKey], [itemData]);
        isSelectedItemsChanged = true;
      }
    }
    if (isSelectedItemsChanged) {
      when(deferred).done(() => {
        this._focusedItemIndex = itemIndex;
        !setFocusOnly && this.onSelectionChanged();
      });
      return true;
    }
  }
  isDataItem(item) {
    return this.options.isSelectableItem(item);
  }
  isSelectable() {
    return "single" === this.options.mode || "multiple" === this.options.mode;
  }
  isItemDataSelected(data2) {
    return this._selectionStrategy.isItemDataSelected(data2, {
      checkPending: true
    });
  }
  isItemSelected(arg, options2) {
    return this._selectionStrategy.isItemKeySelected(arg, options2);
  }
  _resetItemSelectionWhenShiftKeyPressed() {
    delete this._shiftFocusedItemIndex;
  }
  _resetFocusedItemIndex() {
    this._focusedItemIndex = -1;
  }
  changeItemSelectionWhenShiftKeyInVirtualPaging(loadIndex) {
    const loadOptions = this.options.getLoadOptions(loadIndex, this._focusedItemIndex, this._shiftFocusedItemIndex);
    const deferred = Deferred();
    const indexOffset = loadOptions.skip;
    this.options.load(loadOptions).done((items) => {
      this.changeItemSelectionWhenShiftKeyPressed(loadIndex, items, indexOffset);
      deferred.resolve();
    });
    return deferred.promise();
  }
  changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset) {
    let isSelectedItemsChanged = false;
    let itemIndexStep;
    const indexOffsetDefined = isDefined(indexOffset);
    let index2 = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
    const {
      keyOf
    } = this.options;
    const focusedItem = items[index2];
    const focusedData = this.options.getItemData(focusedItem);
    const focusedKey = keyOf(focusedData);
    const isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
    if (!isDefined(this._shiftFocusedItemIndex)) {
      this._shiftFocusedItemIndex = this._focusedItemIndex;
    }
    let data2;
    let itemKey;
    let startIndex;
    let endIndex;
    if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
      itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index2 = startIndex; index2 !== endIndex; index2 += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index2])) {
          itemKey = keyOf(this.options.getItemData(items[index2]));
          this._removeSelectedItem(itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if (itemIndex !== this._shiftFocusedItemIndex) {
      itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? itemIndex - indexOffset : itemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index2 = startIndex; index2 !== endIndex; index2 += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index2])) {
          data2 = this.options.getItemData(items[index2]);
          itemKey = keyOf(data2);
          this._addSelectedItem(data2, itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if ((indexOffsetDefined || this.isDataItem(focusedItem)) && !isFocusedItemSelected) {
      this._addSelectedItem(focusedData, focusedKey);
      isSelectedItemsChanged = true;
    }
    return isSelectedItemsChanged;
  }
  clearSelectedItems() {
    this._setSelectedItems([], []);
  }
  selectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._selectionStrategy._onePageSelectAll(false);
    }
    return this.selectedItemKeys([], true, false, true);
  }
  deselectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._selectionStrategy._onePageSelectAll(true);
    }
    return this.selectedItemKeys([], true, true, true);
  }
  getSelectAllState(visibleOnly) {
    return this._selectionStrategy.getSelectAllState(visibleOnly);
  }
  loadSelectedItemsWithFilter() {
    return this._selectionStrategy.loadSelectedItemsWithFilter();
  }
};

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.js
var NOT_EXISTING_INDEX = -1;
var indexExists = (index2) => index2 !== NOT_EXISTING_INDEX;
var CollectionWidget2 = class extends collection_widget_base_default {
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      selectionMode: "none",
      selectionRequired: false,
      selectByClick: true,
      selectedItems: [],
      selectedItemKeys: [],
      maxFilterLengthInRequest: 1500,
      keyExpr: null,
      selectedIndex: NOT_EXISTING_INDEX,
      focusOnSelectedItem: true,
      selectedItem: null,
      onSelectionChanging: null,
      onSelectionChanged: null,
      onItemReordered: null,
      onItemDeleting: null,
      onItemDeleted: null
    });
  }
  ctor(element, options2) {
    this._userOptions = options2 || {};
    super.ctor(element, options2);
  }
  _init() {
    this._initEditStrategy();
    super._init();
    this._initKeyGetter();
    this._initActions();
    this._initSelectionModule();
  }
  _initKeyGetter() {
    this._keyGetter = compileGetter(this.option("keyExpr"));
  }
  _selectedItemClass() {
    return "dx-item-selected";
  }
  _getActionsList() {
    return ["onSelectionChanging", "onSelectionChanged"];
  }
  _initActions() {
    this._actions = {};
    const actions = this._getActionsList();
    actions.forEach((action) => {
      this._actions[action] = this._createActionByOption(action, {
        excludeValidators: ["disabled", "readOnly"]
      }) ?? noop2;
    });
  }
  _getKeysByItems(selectedItems) {
    return this._editStrategy.getKeysByItems(selectedItems);
  }
  _getItemsByKeys(selectedItemKeys, selectedItems) {
    return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems);
  }
  _getKeyByIndex(index2) {
    return this._editStrategy.getKeyByIndex(index2);
  }
  _getIndexByKey(key) {
    return this._editStrategy.getIndexByKey(key);
  }
  _getIndexByItemData(itemData) {
    return this._editStrategy.getIndexByItemData(itemData);
  }
  _isKeySpecified() {
    return !!this._dataController.key();
  }
  _getCombinedFilter() {
    return this._dataController.filter();
  }
  key() {
    const {
      keyExpr
    } = this.option();
    if (keyExpr) {
      return keyExpr;
    }
    return this._dataController.key();
  }
  keyOf(item) {
    let key = item;
    if (this.option("keyExpr")) {
      key = this._keyGetter(item);
    } else if (this._dataController.store()) {
      key = this._dataController.keyOf(item);
    }
    return key;
  }
  _nullValueSelectionSupported() {
    return false;
  }
  _initSelectionModule() {
    const that = this;
    const {
      itemsGetter
    } = this._editStrategy;
    this._selection = new Selection({
      allowNullValue: this._nullValueSelectionSupported(),
      mode: this.option("selectionMode"),
      maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
      equalByReference: !this._isKeySpecified(),
      onSelectionChanging: (args) => {
        var _this$_actions$onSele, _this$_actions;
        const isSelectionChanged = args.addedItemKeys.length || args.removedItemKeys.length;
        if (!this._rendered || !isSelectionChanged) {
          return;
        }
        const selectionChangingArgs = {
          removedItems: args.removedItems,
          addedItems: args.addedItems,
          cancel: false
        };
        null === (_this$_actions$onSele = (_this$_actions = this._actions).onSelectionChanging) || void 0 === _this$_actions$onSele || _this$_actions$onSele.call(_this$_actions, selectionChangingArgs);
        args.cancel = selectionChangingArgs.cancel;
      },
      onSelectionChanged: (args) => {
        if (args.addedItemKeys.length || args.removedItemKeys.length) {
          this.option("selectedItems", this._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
          this._updateSelectedItems(args);
        }
      },
      filter: this._getCombinedFilter.bind(this),
      totalCount: () => {
        const {
          items
        } = this.option();
        const totalCount = this._dataController.totalCount();
        return totalCount >= 0 ? totalCount : this._getItemsCount(items);
      },
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this),
      load(options2) {
        var _dataController$loadO;
        const dataController = that._dataController;
        options2.customQueryParams = null === (_dataController$loadO = dataController.loadOptions()) || void 0 === _dataController$loadO ? void 0 : _dataController$loadO.customQueryParams;
        options2.userData = dataController.userData();
        if (dataController.store()) {
          return dataController.loadFromStore(options2).done((loadResult) => {
            if (that._disposed) {
              return;
            }
            const items = normalizeLoadResult(loadResult).data;
            dataController.applyMapFunction(items);
          });
        }
        return Deferred().resolve(this.plainItems());
      },
      dataFields: () => this._dataController.select(),
      plainItems: itemsGetter.bind(this._editStrategy)
    });
  }
  _getItemsCount(items) {
    return items.reduce((itemsCount, item) => itemsCount + (item.items ? this._getItemsCount(item.items) : 1), 0);
  }
  _initEditStrategy() {
    this._editStrategy = new m_collection_widget_edit_strategy_plain_default(this);
  }
  _getSelectedItemIndices(keys) {
    const indices = [];
    keys = keys || this._selection.getSelectedItemKeys();
    this._editStrategy.beginCache();
    each(keys, (_, key) => {
      const selectedIndex = this._getIndexByKey(key);
      if (indexExists(selectedIndex)) {
        indices.push(selectedIndex);
      }
    });
    this._editStrategy.endCache();
    return indices;
  }
  _initMarkup() {
    this._rendering = true;
    if (!this._dataController.isLoading()) {
      this._syncSelectionOptions().done(() => this._normalizeSelectedItems());
    }
    super._initMarkup();
  }
  _render() {
    super._render();
    this._rendering = false;
  }
  _fireContentReadyAction() {
    this._rendering = false;
    this._rendered = true;
    super._fireContentReadyAction();
  }
  _syncSelectionOptions(byOption) {
    byOption = byOption ?? this._chooseSelectOption();
    let selectedItem;
    let selectedIndex;
    let selectedItemKeys;
    let selectedItems;
    switch (byOption) {
      case "selectedIndex":
        selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedItem", selectedItem);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedItem", null);
        }
        break;
      case "selectedItems":
        selectedItems = this.option("selectedItems") || [];
        selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : NOT_EXISTING_INDEX;
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        this._setOptionWithoutOptionChange("selectedItem", selectedItems[0]);
        this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
        this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
        break;
      case "selectedItem":
        selectedItem = this.option("selectedItem");
        selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedIndex", NOT_EXISTING_INDEX);
        }
        break;
      case "selectedItemKeys":
        selectedItemKeys = this.option("selectedItemKeys");
        if (this.option("selectionRequired")) {
          const selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
          if (!indexExists(selectedItemIndex)) {
            return this._syncSelectionOptions("selectedIndex");
          }
        }
        return this._selection.setSelection(selectedItemKeys);
    }
    return Deferred().resolve().promise();
  }
  _chooseSelectOption() {
    let optionName = "selectedIndex";
    const isOptionDefined = (name2) => {
      const optionValue = this.option(name2);
      const length = isDefined(optionValue) && optionValue.length;
      return length || name2 in this._userOptions;
    };
    if (isOptionDefined("selectedItems")) {
      optionName = "selectedItems";
    } else if (isOptionDefined("selectedItem")) {
      optionName = "selectedItem";
    } else if (isOptionDefined("selectedItemKeys")) {
      optionName = "selectedItemKeys";
    }
    return optionName;
  }
  _compareKeys(oldKeys, newKeys) {
    if (oldKeys.length !== newKeys.length) {
      return false;
    }
    for (let i = 0; i < newKeys.length; i++) {
      if (oldKeys[i] !== newKeys[i]) {
        return false;
      }
    }
    return true;
  }
  _normalizeSelectedItems() {
    const {
      selectionMode,
      selectedItems,
      items
    } = this.option();
    if ("none" === selectionMode) {
      this._setOptionWithoutOptionChange("selectedItems", []);
      this._syncSelectionOptions("selectedItems");
    } else if ("single" === selectionMode) {
      const newSelection = selectedItems ?? [];
      if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && null !== items && void 0 !== items && items.length) {
        var _normalizedSelection;
        const currentSelection = this._selection.getSelectedItems();
        let normalizedSelection = void 0 === newSelection[0] ? currentSelection[0] : newSelection[0];
        if (void 0 === normalizedSelection) {
          normalizedSelection = this._editStrategy.itemsGetter()[0];
        }
        if (this.option("grouped") && null !== (_normalizedSelection = normalizedSelection) && void 0 !== _normalizedSelection && _normalizedSelection.items) {
          normalizedSelection.items = [normalizedSelection.items[0]];
        }
        this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
        this._setOptionWithoutOptionChange("selectedItems", [normalizedSelection]);
        return this._syncSelectionOptions("selectedItems");
      }
      this._selection.setSelection(this._getKeysByItems(newSelection));
    } else {
      const newKeys = this._getKeysByItems(this.option("selectedItems"));
      const oldKeys = this._selection.getSelectedItemKeys();
      if (!this._compareKeys(oldKeys, newKeys)) {
        this._selection.setSelection(newKeys);
      }
    }
    return Deferred().resolve().promise();
  }
  _itemClickHandler(e, args, config3) {
    let itemSelectPromise = Deferred().resolve();
    this._createAction((e2) => {
      itemSelectPromise = this._itemSelectHandler(e2.event) ?? itemSelectPromise;
    }, {
      validatingTargetName: "itemElement"
    })({
      itemElement: renderer_default(e.currentTarget),
      event: e
    });
    itemSelectPromise.always(() => {
      super._itemClickHandler(e, args, config3);
    });
  }
  _itemSelectHandler(e, shouldIgnoreSelectByClick) {
    if (!shouldIgnoreSelectByClick && !this.option("selectByClick")) {
      return;
    }
    const $itemElement = e.currentTarget;
    if (this.isItemSelected($itemElement)) {
      this.unselectItem(e.currentTarget);
    } else {
      const itemSelectPromise = this.selectItem(e.currentTarget);
      return null === itemSelectPromise || void 0 === itemSelectPromise ? void 0 : itemSelectPromise.promise();
    }
  }
  _selectedItemElement(index2) {
    return this._itemElements().eq(index2);
  }
  _postprocessRenderItem(args) {
    const {
      selectionMode
    } = this.option();
    if ("none" !== selectionMode) {
      const $itemElement = renderer_default(args.itemElement);
      const normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
      const isItemSelected = this._isItemSelected(normalizedItemIndex);
      this._processSelectableItem($itemElement, isItemSelected);
    }
  }
  _processSelectableItem($itemElement, isSelected) {
    $itemElement.toggleClass(this._selectedItemClass(), isSelected);
    this._setAriaSelectionAttribute($itemElement, String(isSelected));
  }
  _updateSelectedItems(args) {
    const {
      addedItemKeys,
      removedItemKeys
    } = args;
    if (this._rendered && (addedItemKeys.length || removedItemKeys.length)) {
      if (!this._rendering) {
        const addedSelection = [];
        const removedSelection = [];
        this._editStrategy.beginCache();
        for (let i = 0; i < addedItemKeys.length; i += 1) {
          const normalizedIndex = this._getIndexByKey(addedItemKeys[i]);
          addedSelection.push(normalizedIndex);
          this._addSelection(normalizedIndex);
        }
        for (let i = 0; i < removedItemKeys.length; i += 1) {
          const normalizedIndex = this._getIndexByKey(removedItemKeys[i]);
          removedSelection.push(normalizedIndex);
          this._removeSelection(normalizedIndex);
        }
        this._editStrategy.endCache();
        this._updateSelection(addedSelection, removedSelection);
      }
      this._actions.onSelectionChanged({
        addedItems: args.addedItems,
        removedItems: args.removedItems
      });
    }
  }
  _updateSelection(addedSelection, removedSelection) {
  }
  _setAriaSelectionAttribute($target, value2) {
    this.setAria("selected", value2, $target);
  }
  _getFocusedElementIndex() {
    const {
      focusOnSelectedItem
    } = this.option();
    return focusOnSelectedItem ? this._getFlatIndex() : super._getFocusedElementIndex();
  }
  _getFlatIndex() {
    const {
      selectedIndex = NOT_EXISTING_INDEX
    } = this.option();
    return selectedIndex;
  }
  _removeSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, false);
      m_events_engine_default.triggerHandler($itemElement, "stateChanged", false);
    }
  }
  _addSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, true);
      m_events_engine_default.triggerHandler($itemElement, "stateChanged", true);
    }
  }
  _isItemSelected(index2) {
    const key = this._getKeyByIndex(index2);
    return this._selection.isItemSelected(key, {
      checkPending: true
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "selectionMode":
        this._invalidate();
        break;
      case "dataSource":
        if (!args.value || Array.isArray(args.value) && !args.value.length) {
          this.option("selectedItemKeys", []);
        }
        super._optionChanged(args);
        break;
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
      case "selectedItemKeys":
        this._syncSelectionOptions(args.name).done(() => this._normalizeSelectedItems());
        break;
      case "keyExpr":
        this._initKeyGetter();
        break;
      case "selectionRequired":
        this._normalizeSelectedItems();
        break;
      case "onSelectionChanging":
      case "onSelectionChanged":
        this._initActions();
        break;
      case "selectByClick":
      case "onItemDeleting":
      case "onItemDeleted":
      case "onItemReordered":
      case "maxFilterLengthInRequest":
      case "focusOnSelectedItem":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clearSelectedItems() {
    this._setOptionWithoutOptionChange("selectedItems", []);
    this._syncSelectionOptions("selectedItems");
  }
  _waitDeletingPrepare($itemElement) {
    if ($itemElement.data("dxItemDeleting")) {
      return Deferred().resolve().promise();
    }
    $itemElement.data("dxItemDeleting", true);
    const deferred = Deferred();
    const deletingActionArgs = {
      cancel: false
    };
    const deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
      excludeValidators: ["disabled", "readOnly"]
    });
    when(deletePromise).always(function(value2) {
      const deletePromiseExists = !deletePromise;
      const deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state();
      const argumentsSpecified = !!arguments.length;
      const shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value2;
      when(fromPromise(deletingActionArgs.cancel)).always(() => {
        $itemElement.data("dxItemDeleting", false);
      }).done((cancel2) => {
        if (shouldDelete && !cancel2) {
          deferred.resolve();
        } else {
          deferred.reject();
        }
      }).fail(deferred.reject);
    });
    return deferred.promise();
  }
  _deleteItemFromDS($item) {
    const dataController = this._dataController;
    const deferred = Deferred();
    const disabledState = this.option("disabled");
    const dataStore = dataController.store();
    if (!dataStore) {
      return Deferred().resolve().promise();
    }
    if (!dataStore.remove) {
      throw ui_errors_default.Error("E1011");
    }
    this.option("disabled", true);
    dataStore.remove(dataController.keyOf(this._getItemData($item))).done((key) => {
      if (void 0 !== key) {
        deferred.resolve();
      } else {
        deferred.reject();
      }
    }).fail(() => {
      deferred.reject();
    });
    deferred.always(() => {
      this.option("disabled", disabledState);
    });
    return deferred;
  }
  _tryRefreshLastPage() {
    const deferred = Deferred();
    if (this._isLastPage() || this.option("grouped")) {
      deferred.resolve();
    } else {
      this._refreshLastPage().done(() => {
        deferred.resolve();
      });
    }
    return deferred.promise();
  }
  _refreshLastPage() {
    this._expectLastItemLoading();
    return this._dataController.load();
  }
  _updateSelectionAfterDelete(index2) {
    const key = this._getKeyByIndex(index2);
    this._selection.deselect([key]);
  }
  _updateIndicesAfterIndex(index2) {
    const itemElements = this._itemElements();
    for (let i = index2 + 1; i < itemElements.length; i += 1) {
      renderer_default(itemElements[i]).data(this._itemIndexKey(), i - 1);
    }
  }
  _simulateOptionChange(optionName) {
    var _this$_optionChangedA;
    const optionValue = this.option(optionName);
    if (optionValue instanceof DataSource) {
      return;
    }
    null === (_this$_optionChangedA = this._optionChangedAction) || void 0 === _this$_optionChangedA || _this$_optionChangedA.call(this, {
      name: optionName,
      fullName: optionName,
      value: optionValue
    });
  }
  isItemSelected(itemElement) {
    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement));
  }
  selectItem(itemElement) {
    const {
      selectionMode
    } = this.option();
    if ("none" === selectionMode) {
      return Deferred().resolve();
    }
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return Deferred().resolve();
    }
    const key = this._getKeyByIndex(itemIndex);
    if (this._selection.isItemSelected(key)) {
      return Deferred().resolve();
    }
    if ("single" === selectionMode) {
      return this._selection.setSelection([key]);
    }
    const {
      selectedItemKeys
    } = this.option();
    return this._selection.setSelection([...selectedItemKeys ?? [], key], [key]);
  }
  unselectItem(itemElement) {
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    const selectedItemKeys = this._selection.getSelectedItemKeys();
    if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
      return;
    }
    const key = this._getKeyByIndex(itemIndex);
    if (!this._selection.isItemSelected(key, {
      checkPending: true
    })) {
      return;
    }
    this._selection.deselect([key]);
  }
  _deleteItemElementByIndex(index2) {
    this._updateSelectionAfterDelete(index2);
    this._updateIndicesAfterIndex(index2);
    this._editStrategy.deleteItemAtIndex(index2);
  }
  _afterItemElementDeleted($item, deletedActionArgs) {
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    this._simulateOptionChange(changingOption);
    this._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
      beforeExecute() {
        $item.remove();
      },
      excludeValidators: ["disabled", "readOnly"]
    });
    this._renderEmptyMessage();
  }
  deleteItem(itemElement) {
    const deferred = Deferred();
    const $item = this._editStrategy.getItemElement(itemElement);
    const index2 = this._editStrategy.getNormalizedIndex(itemElement);
    const itemResponseWaitClass = this._itemResponseWaitClass();
    if (indexExists(index2)) {
      this._waitDeletingPrepare($item).done(() => {
        $item.addClass(itemResponseWaitClass);
        const deletedActionArgs = this._extendActionArgs($item);
        this._deleteItemFromDS($item).done(() => {
          this._deleteItemElementByIndex(index2);
          this._afterItemElementDeleted($item, deletedActionArgs);
          this._tryRefreshLastPage().done(() => {
            deferred.resolveWith(this);
          });
        }).fail(() => {
          $item.removeClass(itemResponseWaitClass);
          deferred.rejectWith(this);
        });
      }).fail(() => {
        deferred.rejectWith(this);
      });
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise();
  }
  reorderItem(itemElement, toItemElement) {
    const deferred = Deferred();
    const strategy3 = this._editStrategy;
    const $movingItem = strategy3.getItemElement(itemElement);
    const $destinationItem = strategy3.getItemElement(toItemElement);
    const movingIndex = strategy3.getNormalizedIndex(itemElement);
    const destinationIndex = strategy3.getNormalizedIndex(toItemElement);
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    const canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
    if (canMoveItems) {
      deferred.resolveWith(this);
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise().done(() => {
      $destinationItem[strategy3.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
      strategy3.moveItemAtIndexToIndex(movingIndex, destinationIndex);
      this._updateIndicesAfterIndex(movingIndex);
      this.option("selectedItems", this._getItemsByKeys(this._selection.getSelectedItemKeys(), this._selection.getSelectedItems()));
      if ("items" === changingOption) {
        this._simulateOptionChange(changingOption);
      }
      this._itemEventHandler($movingItem, "onItemReordered", {
        fromIndex: strategy3.getIndex(movingIndex),
        toIndex: strategy3.getIndex(destinationIndex)
      }, {
        excludeValidators: ["disabled", "readOnly"]
      });
    });
  }
};
var m_collection_widget_edit_default = CollectionWidget2;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.async.js
var CollectionWidgetAsync = class extends m_collection_widget_edit_default {
  _initMarkup() {
    this._asyncTemplateItemsMap = {};
    super._initMarkup();
  }
  _render() {
    super._render();
    this._planPostRenderActions();
  }
  _renderItemContent(args) {
    const renderContentDeferred = Deferred();
    const itemDeferred = Deferred();
    const uniqueKey = `dx${new guid_default2()}`;
    this._asyncTemplateItemsMap[uniqueKey] = itemDeferred;
    const $itemContent = super._renderItemContent(_extends({}, args, {
      uniqueKey
    }));
    itemDeferred.done(() => {
      renderContentDeferred.resolve($itemContent);
    });
    return renderContentDeferred.promise();
  }
  _onItemTemplateRendered(itemTemplate, renderArgs) {
    return () => {
      const {
        uniqueKey
      } = renderArgs;
      if (uniqueKey) {
        var _this$_asyncTemplateI;
        null === (_this$_asyncTemplateI = this._asyncTemplateItemsMap[uniqueKey]) || void 0 === _this$_asyncTemplateI || _this$_asyncTemplateI.resolve();
      }
    };
  }
  _postProcessRenderItems() {
  }
  _planPostRenderActions() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const d = Deferred();
    const asyncTemplateItems = Object.values(this._asyncTemplateItemsMap);
    when.apply(this, asyncTemplateItems).done(() => {
      this._postProcessRenderItems(...args);
      d.resolve().done(() => {
        this._asyncTemplateItemsMap = {};
      });
    });
    return d.promise();
  }
  _clean() {
    super._clean();
    const asyncTemplateItems = Object.values(this._asyncTemplateItemsMap);
    asyncTemplateItems.forEach((item) => {
      item.reject();
    });
    this._asyncTemplateItemsMap = {};
  }
};
var m_collection_widget_async_default = CollectionWidgetAsync;

// node_modules/devextreme/esm/__internal/ui/toolbar/m_constants.js
var TOOLBAR_CLASS = "dx-toolbar";

// node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.base.js
var TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
var ToolbarBase = class extends m_collection_widget_async_default {
  _getSynchronizableOptionsForCreateComponent() {
    return super._getSynchronizableOptionsForCreateComponent().filter((item) => "disabled" !== item);
  }
  _initTemplates() {
    super._initTemplates();
    const template = new BindableTemplate(($container, data2, rawModel) => {
      if (isPlainObject(data2)) {
        const {
          text,
          html,
          widget
        } = data2;
        if (text) {
          $container.text(text).wrapInner("<div>");
        }
        if (html) {
          $container.html(html);
        }
        if ("dxDropDownButton" === widget) {
          data2.options = data2.options ?? {};
          if (!isDefined(data2.options.stylingMode)) {
            data2.options.stylingMode = this.option("useFlatButtons") ? "text" : "contained";
          }
        }
        if ("dxButton" === widget) {
          if (this.option("useFlatButtons")) {
            data2.options = data2.options ?? {};
            data2.options.stylingMode = data2.options.stylingMode ?? "text";
          }
          if (this.option("useDefaultButtons")) {
            data2.options = data2.options ?? {};
            data2.options.type = data2.options.type ?? "default";
          }
        }
      } else {
        $container.text(String(data2));
      }
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: rawModel,
        parent: this
      });
    }, ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
    this._templateManager.addDefaultTemplates({
      item: template,
      menuItem: template
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      renderAs: "topToolbar",
      grouped: false,
      useFlatButtons: false,
      useDefaultButtons: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterialBased(),
      options: {
        useFlatButtons: true
      }
    }]);
  }
  _itemContainer() {
    return this._$toolbarItemsContainer.find([".dx-toolbar-before", ".dx-toolbar-center", ".dx-toolbar-after"].join(","));
  }
  _itemClass() {
    return "dx-toolbar-item";
  }
  _itemDataKey() {
    return TOOLBAR_ITEM_DATA_KEY;
  }
  _dimensionChanged(dimension) {
    if (this._disposed) {
      return;
    }
    this._arrangeItems();
    this._applyCompactMode();
  }
  _initMarkup() {
    this._renderToolbar();
    this._renderSections();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._updateDimensionsInMaterial();
  }
  _postProcessRenderItems() {
    this._arrangeItems();
  }
  _renderToolbar() {
    this.$element().addClass(TOOLBAR_CLASS);
    this._$toolbarItemsContainer = renderer_default("<div>").addClass("dx-toolbar-items-container").appendTo(this.$element());
    this.setAria("role", "toolbar");
  }
  _renderSections() {
    const $container = this._$toolbarItemsContainer;
    each(["before", "center", "after"], (_, section) => {
      const sectionClass = `dx-toolbar-${section}`;
      const $section = $container.find(`.${sectionClass}`);
      if (!$section.length) {
        this[`_$${section}Section`] = renderer_default("<div>").addClass(sectionClass).attr("role", "presentation").appendTo($container);
      }
    });
  }
  _arrangeItems(width) {
    var _this$_$beforeSection, _this$_$afterSection;
    const elementWidth = width ?? getWidth(this.$element());
    this._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    const beforeRect = getBoundingRect(null === (_this$_$beforeSection = this._$beforeSection) || void 0 === _this$_$beforeSection ? void 0 : _this$_$beforeSection.get(0));
    const afterRect = getBoundingRect(null === (_this$_$afterSection = this._$afterSection) || void 0 === _this$_$afterSection ? void 0 : _this$_$afterSection.get(0));
    this._alignCenterSection(beforeRect, afterRect, elementWidth);
    const $label = this._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    const $section = $label.parent();
    if (!$label.length) {
      return;
    }
    const labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;
    const widthBeforeSection = $section.hasClass("dx-toolbar-before") ? 0 : labelOffset;
    const widthAfterSection = $section.hasClass("dx-toolbar-after") ? 0 : afterRect.width;
    let elemsAtSectionWidth = 0;
    $section.children().not(".dx-toolbar-label").each((index2, element) => {
      elemsAtSectionWidth += getOuterWidth(element);
    });
    const freeSpace = elementWidth - elemsAtSectionWidth;
    const sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);
    if ($section.hasClass("dx-toolbar-before")) {
      this._alignSection(this._$beforeSection, sectionMaxWidth);
    } else {
      const labelPaddings = getOuterWidth($label) - getWidth($label);
      $label.css("maxWidth", sectionMaxWidth - labelPaddings);
    }
  }
  _alignCenterSection(beforeRect, afterRect, elementWidth) {
    var _this$_$centerSection;
    this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);
    const isRTL = this.option("rtlEnabled");
    const leftRect = isRTL ? afterRect : beforeRect;
    const rightRect = isRTL ? beforeRect : afterRect;
    const centerRect = getBoundingRect(null === (_this$_$centerSection = this._$centerSection) || void 0 === _this$_$centerSection ? void 0 : _this$_$centerSection.get(0));
    if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {
      this._$centerSection.css({
        marginLeft: leftRect.width,
        marginRight: rightRect.width,
        float: leftRect.width > rightRect.width ? "none" : "right"
      });
    }
  }
  _alignSection($section, maxWidth) {
    const $labels = $section.find(".dx-toolbar-label");
    let labels = $labels.toArray();
    maxWidth -= this._getCurrentLabelsPaddings(labels);
    const currentWidth = this._getCurrentLabelsWidth(labels);
    const difference = Math.abs(currentWidth - maxWidth);
    if (maxWidth < currentWidth) {
      labels = labels.reverse();
      this._alignSectionLabels(labels, difference, false);
    } else {
      this._alignSectionLabels(labels, difference, true);
    }
  }
  _alignSectionLabels(labels, difference, expanding) {
    const getRealLabelWidth = function(label) {
      return getBoundingRect(label).width;
    };
    for (let i = 0; i < labels.length; i++) {
      const $label = renderer_default(labels[i]);
      const currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));
      let labelMaxWidth;
      if (expanding) {
        $label.css("maxWidth", "inherit");
      }
      const possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);
      if (possibleLabelWidth < difference) {
        labelMaxWidth = expanding ? possibleLabelWidth : 0;
        difference -= possibleLabelWidth;
      } else {
        labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;
        $label.css("maxWidth", labelMaxWidth);
        break;
      }
      $label.css("maxWidth", labelMaxWidth);
    }
  }
  _applyCompactMode() {
    const $element = renderer_default(this.element());
    $element.removeClass("dx-toolbar-compact");
    if (this.option("compactMode") && this._getSummaryItemsSize("width", this._itemElements(), true) > getWidth($element)) {
      $element.addClass("dx-toolbar-compact");
    }
  }
  _getCurrentLabelsWidth(labels) {
    let width = 0;
    labels.forEach((label) => {
      width += getOuterWidth(label);
    });
    return width;
  }
  _getCurrentLabelsPaddings(labels) {
    let padding = 0;
    labels.forEach((label) => {
      padding += getOuterWidth(label) - getWidth(label);
    });
    return padding;
  }
  _renderItem(index2, item, itemContainer, $after) {
    const location = item.location ?? "center";
    const container = itemContainer ?? this[`_$${location}Section`];
    const itemHasText = !!(item.text ?? item.html);
    const itemElement = super._renderItem(index2, item, container, $after);
    itemElement.toggleClass("dx-toolbar-button", !itemHasText).toggleClass("dx-toolbar-label", itemHasText).addClass(item.cssClass);
    return itemElement;
  }
  _renderGroupedItems() {
    each(this.option("items"), (groupIndex, group) => {
      const groupItems = group.items;
      const $container = renderer_default("<div>").addClass("dx-toolbar-group");
      const location = group.location ?? "center";
      if (!groupItems || !groupItems.length) {
        return;
      }
      each(groupItems, (itemIndex, item) => {
        this._renderItem(itemIndex, item, $container, null);
      });
      this._$toolbarItemsContainer.find(`.dx-toolbar-${location}`).append($container);
    });
  }
  _renderItems(items) {
    const grouped = this.option("grouped") && items.length && items[0].items;
    grouped ? this._renderGroupedItems() : super._renderItems(items);
  }
  _getToolbarItems() {
    return this.option("items") ?? [];
  }
  _renderContentImpl() {
    const items = this._getToolbarItems();
    this.$element().toggleClass("dx-toolbar-mini", 0 === items.length);
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
    this._applyCompactMode();
  }
  _renderEmptyMessage() {
  }
  _clean() {
    this._$toolbarItemsContainer.children().empty();
    this.$element().empty();
    delete this._$beforeSection;
    delete this._$centerSection;
    delete this._$afterSection;
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._arrangeItems();
    }
  }
  _isVisible() {
    return getWidth(this.$element()) > 0 && getHeight(this.$element()) > 0;
  }
  _getIndexByItem(item) {
    return this._getToolbarItems().indexOf(item);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    super._itemOptionChanged(item, property, value2, prevValue);
    this._arrangeItems();
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "width":
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "renderAs":
      case "useFlatButtons":
      case "useDefaultButtons":
        this._invalidate();
        break;
      case "compactMode":
        this._applyCompactMode();
        break;
      case "grouped":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._waitParentAnimationTimeout);
  }
  _updateDimensionsInMaterial() {
    if (isMaterial()) {
      const _waitParentAnimationFinished = () => new Promise((resolve) => {
        const check = () => {
          let readyToResolve = true;
          this.$element().parents().each((_, parent) => {
            if (fx_default.isAnimating(renderer_default(parent))) {
              readyToResolve = false;
              return false;
            }
          });
          if (readyToResolve) {
            resolve();
          }
          return readyToResolve;
        };
        const runCheck = () => {
          clearTimeout(this._waitParentAnimationTimeout);
          this._waitParentAnimationTimeout = setTimeout(() => check() || runCheck(), 15);
        };
        runCheck();
      });
      const _checkWebFontForLabelsLoaded = () => {
        const $labels = this.$element().find(".dx-toolbar-label");
        const promises = [];
        $labels.each((_, label) => {
          const text = renderer_default(label).text();
          const fontWeight = renderer_default(label).css("fontWeight");
          promises.push(waitWebFont(text, fontWeight));
        });
        return Promise.all(promises);
      };
      Promise.all([_waitParentAnimationFinished(), _checkWebFontForLabelsLoaded()]).then(() => {
        this._dimensionChanged();
      });
    }
  }
};
component_registrator_default("dxToolbarBase", ToolbarBase);

// node_modules/devextreme/esm/__internal/core/m_resize_observer.js
var window16 = m_window_default.getWindow();
var ResizeObserverMock = {
  observe: noop2,
  unobserve: noop2,
  disconnect: noop2
};
var ResizeObserverSingleton = class {
  constructor() {
    if (!m_window_default.hasWindow() || !window16.ResizeObserver) {
      return ResizeObserverMock;
    }
    this._callbacksMap = /* @__PURE__ */ new Map();
    this._observer = new window16.ResizeObserver((entries) => {
      entries.forEach((entry) => {
        var _this$_callbacksMap$g;
        null === (_this$_callbacksMap$g = this._callbacksMap.get(entry.target)) || void 0 === _this$_callbacksMap$g || _this$_callbacksMap$g(entry);
      });
    });
  }
  observe(element, callback) {
    this._callbacksMap.set(element, callback);
    this._observer.observe(element);
  }
  unobserve(element) {
    this._callbacksMap.delete(element);
    this._observer.unobserve(element);
  }
  disconnect() {
    this._callbacksMap.clear();
    this._observer.disconnect();
  }
};
var resizeObserverSingleton = new ResizeObserverSingleton();

// node_modules/devextreme/esm/core/resize_observer.js
var resize_observer_default = resizeObserverSingleton;

// node_modules/devextreme/esm/__internal/core/utils/m_icon.js
var getImageSourceType = (source) => {
  if (!source || "string" !== typeof source) {
    return false;
  }
  if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
    return "svg";
  }
  if (/data:.*base64|\.|[^<\s]\/{1,1}/.test(source)) {
    return "image";
  }
  if (/^[\w-_]+$/.test(source)) {
    return "dxIcon";
  }
  if (/^\s?([\w-_:]\s?)+$/.test(source)) {
    return "fontIcon";
  }
  return false;
};

// node_modules/devextreme/esm/common/core/localization/utils.js
function roundByAbs(value2) {
  const valueSign = sign(value2);
  return valueSign * Math.round(Math.abs(value2));
}
function adjustValue(value2, precision) {
  const precisionMultiplier = Math.pow(10, precision);
  const intermediateValue = multiplyInExponentialForm(value2, precision);
  return roundByAbs(intermediateValue) / precisionMultiplier;
}
function toFixed(value2, precision) {
  const valuePrecision = precision || 0;
  const adjustedValue = valuePrecision > 0 ? adjustValue(...arguments) : value2;
  return adjustedValue.toFixed(valuePrecision);
}

// node_modules/devextreme/esm/common/core/localization/ldml/number.js
var DEFAULT_CONFIG = {
  thousandsSeparator: ",",
  decimalSeparator: "."
};
function getGroupSizes(formatString) {
  return formatString.split(",").slice(1).map(function(str) {
    let singleQuotesLeft = 0;
    return str.split("").filter(function(char, index2) {
      singleQuotesLeft += "'" === char;
      const isDigit = "#" === char || "0" === char;
      const isInStub = singleQuotesLeft % 2;
      return isDigit && !isInStub;
    }).length;
  });
}
function splitSignParts(format2) {
  let separatorChar = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ";";
  let escapingChar = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "'";
  const parts = [];
  let currentPart = "";
  let state = "searchingSeparator";
  for (let i = 0; i < format2.length; i++) {
    const char = format2[i];
    if ("searchingSeparator" === state && char === escapingChar) {
      state = "skippingSeparationInsideEscaping";
    } else if ("skippingSeparationInsideEscaping" === state && char === escapingChar) {
      state = "searchingSeparator";
    } else if ("searchingSeparator" === state && char === separatorChar) {
      state = "separating";
      parts.push(currentPart);
      currentPart = "";
    }
    if ("separating" !== state) {
      currentPart += char;
    } else {
      state = "searchingSeparator";
    }
  }
  parts.push(currentPart);
  return parts;
}
function getSignParts(format2) {
  const signParts = splitSignParts(format2);
  if (1 === signParts.length) {
    signParts.push("-" + signParts[0]);
  }
  return signParts;
}
function reverseString(str) {
  return str.toString().split("").reverse().join("");
}
function isPercentFormat(format2) {
  return -1 !== format2.indexOf("%") && !format2.match(/'[^']*%[^']*'/g);
}
function removeStubs(str) {
  return str.replace(/'[^']*'/g, "");
}
function getNonRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  const format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[#]/g, "").length;
}
function getRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  const format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[0]/g, "").length;
}
function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
  if (!valuePart) {
    return "";
  }
  if (valuePart.length > maxDigitCount) {
    valuePart = valuePart.substr(0, maxDigitCount);
  }
  while (valuePart.length > minDigitCount && "0" === valuePart.slice(-1)) {
    valuePart = valuePart.substr(0, valuePart.length - 1);
  }
  while (valuePart.length < minDigitCount) {
    valuePart += "0";
  }
  return valuePart;
}
function applyGroups(valueString, groupSizes, thousandsSeparator) {
  if (!groupSizes.length) {
    return valueString;
  }
  const groups = [];
  let index2 = 0;
  while (valueString) {
    const groupSize = groupSizes[index2];
    if (!groupSize) {
      break;
    }
    groups.push(valueString.slice(0, groupSize));
    valueString = valueString.slice(groupSize);
    if (index2 < groupSizes.length - 1) {
      index2++;
    }
  }
  return groups.join(thousandsSeparator);
}
function formatNumberPart(format2, valueString) {
  return format2.split("'").map(function(formatPart, escapeIndex) {
    const isEscape = escapeIndex % 2;
    if (!formatPart && isEscape) {
      return "'";
    }
    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);
  }).join("");
}
function getFloatPointIndex(format2) {
  let isEscape = false;
  for (let index2 = 0; index2 < format2.length; index2++) {
    if ("'" === format2[index2]) {
      isEscape = !isEscape;
    }
    if ("." === format2[index2] && !isEscape) {
      return index2;
    }
  }
  return format2.length;
}
function getFormatter2(format2, config3) {
  config3 = config3 || DEFAULT_CONFIG;
  return function(value2) {
    if ("number" !== typeof value2 || isNaN(value2)) {
      return "";
    }
    const signFormatParts = getSignParts(format2);
    const isPositiveZero = 1 / value2 === 1 / 0;
    const isPositive = value2 > 0 || isPositiveZero;
    const numberFormat = signFormatParts[isPositive ? 0 : 1];
    const floatPointIndex = getFloatPointIndex(numberFormat);
    const floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
    const minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
    const maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
    if (isPercentFormat(numberFormat)) {
      value2 = multiplyInExponentialForm(value2, 2);
    }
    if (!isPositive) {
      value2 = -value2;
    }
    const minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
    const maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config3.unlimitedIntegerDigits ? void 0 : minIntegerPrecision;
    const integerLength = Math.floor(value2).toString().length;
    const floatPrecision = fitIntoRange(maxFloatPrecision, 0, 15 - integerLength);
    const groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
    const valueParts = toFixed(value2, floatPrecision < 0 ? 0 : floatPrecision).split(".");
    let valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
    const valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config3.thousandsSeparator);
    const integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
    const floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : "";
    const result2 = integerString + (floatString.match(/\d/) ? config3.decimalSeparator : "") + floatString;
    return result2;
  };
}

// node_modules/devextreme/esm/common/core/localization/currency.js
var currency_default = {
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("currency" === format2) {
      formatConfig.precision = formatConfig.precision || 0;
      let result2 = this.format(value2, extend({}, formatConfig, {
        type: "fixedpoint"
      }));
      const currencyPart = this.getCurrencySymbol().symbol.replace(/\$/g, "$$$$");
      result2 = result2.replace(/^(\D*)(\d.*)/, "$1" + currencyPart + "$2");
      return result2;
    }
    return this.callBase.apply(this, arguments);
  },
  getCurrencySymbol: function() {
    return {
      symbol: "$"
    };
  },
  getOpenXmlCurrencyFormat: function() {
    return "$#,##0{0}_);\\($#,##0{0}\\)";
  }
};

// node_modules/devextreme/esm/common/core/localization/open_xml_currency_format.js
var open_xml_currency_format_default = (currencySymbol, accountingFormat) => {
  if (!accountingFormat) {
    return;
  }
  let encodedCurrencySymbol = currencySymbol;
  if ("string" === typeof currencySymbol) {
    encodedCurrencySymbol = "";
    for (let i = 0; i < currencySymbol.length; i++) {
      if ("$" !== currencySymbol[i]) {
        encodedCurrencySymbol += "\\";
      }
      encodedCurrencySymbol += currencySymbol[i];
    }
  }
  const encodeSymbols = {
    ".00": "{0}",
    "'": "\\'",
    "\\(": "\\(",
    "\\)": "\\)",
    " ": "\\ ",
    '"': "&quot;",
    "\\¤": encodedCurrencySymbol
  };
  const result2 = accountingFormat.split(";");
  for (let i = 0; i < result2.length; i++) {
    for (const symbol in encodeSymbols) {
      if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
        result2[i] = result2[i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol]);
      }
    }
  }
  return 2 === result2.length ? result2[0] + "_);" + result2[1] : result2[0];
};

// node_modules/devextreme/esm/common/core/localization/cldr-data/accounting_formats.js
var accounting_formats_default = {
  af: "¤#,##0.00;(¤#,##0.00)",
  "af-NA": "¤#,##0.00;(¤#,##0.00)",
  agq: "#,##0.00¤",
  ak: "¤#,##0.00",
  am: "¤#,##0.00;(¤#,##0.00)",
  ar: "¤#,##0.00;(¤#,##0.00)",
  "ar-AE": "¤#,##0.00;(¤#,##0.00)",
  "ar-BH": "¤#,##0.00;(¤#,##0.00)",
  "ar-DJ": "¤#,##0.00;(¤#,##0.00)",
  "ar-DZ": "¤#,##0.00;(¤#,##0.00)",
  "ar-EG": "¤#,##0.00;(¤#,##0.00)",
  "ar-EH": "¤#,##0.00;(¤#,##0.00)",
  "ar-ER": "¤#,##0.00;(¤#,##0.00)",
  "ar-IL": "¤#,##0.00;(¤#,##0.00)",
  "ar-IQ": "¤#,##0.00;(¤#,##0.00)",
  "ar-JO": "¤#,##0.00;(¤#,##0.00)",
  "ar-KM": "¤#,##0.00;(¤#,##0.00)",
  "ar-KW": "¤#,##0.00;(¤#,##0.00)",
  "ar-LB": "¤#,##0.00;(¤#,##0.00)",
  "ar-LY": "¤#,##0.00;(¤#,##0.00)",
  "ar-MA": "¤#,##0.00;(¤#,##0.00)",
  "ar-MR": "¤#,##0.00;(¤#,##0.00)",
  "ar-OM": "¤#,##0.00;(¤#,##0.00)",
  "ar-PS": "¤#,##0.00;(¤#,##0.00)",
  "ar-QA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SD": "¤#,##0.00;(¤#,##0.00)",
  "ar-SO": "¤#,##0.00;(¤#,##0.00)",
  "ar-SS": "¤#,##0.00;(¤#,##0.00)",
  "ar-SY": "¤#,##0.00;(¤#,##0.00)",
  "ar-TD": "¤#,##0.00;(¤#,##0.00)",
  "ar-TN": "¤#,##0.00;(¤#,##0.00)",
  "ar-YE": "¤#,##0.00;(¤#,##0.00)",
  as: "¤ #,##,##0.00",
  asa: "#,##0.00 ¤",
  ast: "#,##0.00 ¤",
  az: "#,##0.00 ¤",
  "az-Cyrl": "#,##0.00 ¤",
  "az-Latn": "#,##0.00 ¤",
  bas: "#,##0.00 ¤",
  be: "#,##0.00 ¤",
  "be-tarask": "#,##0.00 ¤",
  bem: "¤#,##0.00;(¤#,##0.00)",
  bez: "#,##0.00¤",
  bg: "0.00 ¤;(0.00 ¤)",
  bm: "¤#,##0.00;(¤#,##0.00)",
  bn: "#,##,##0.00¤;(#,##,##0.00¤)",
  "bn-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  bo: "¤ #,##0.00",
  "bo-IN": "¤ #,##0.00",
  br: "#,##0.00 ¤",
  brx: "¤ #,##,##0.00",
  bs: "#,##0.00 ¤",
  "bs-Cyrl": "#,##0.00 ¤",
  "bs-Latn": "#,##0.00 ¤",
  ca: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-AD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-ES-valencia": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-FR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-IT": "#,##0.00 ¤;(#,##0.00 ¤)",
  ccp: "#,##,##0.00¤;(#,##,##0.00¤)",
  "ccp-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  ce: "#,##0.00 ¤",
  ceb: "¤#,##0.00;(¤#,##0.00)",
  cgg: "¤#,##0.00",
  chr: "¤#,##0.00;(¤#,##0.00)",
  ckb: "¤ #,##0.00",
  "ckb-IR": "¤ #,##0.00",
  cs: "#,##0.00 ¤",
  cy: "¤#,##0.00;(¤#,##0.00)",
  da: "#,##0.00 ¤",
  "da-GL": "#,##0.00 ¤",
  dav: "¤#,##0.00;(¤#,##0.00)",
  de: "#,##0.00 ¤",
  "de-AT": "#,##0.00 ¤",
  "de-BE": "#,##0.00 ¤",
  "de-CH": "#,##0.00 ¤",
  "de-IT": "#,##0.00 ¤",
  "de-LI": "#,##0.00 ¤",
  "de-LU": "#,##0.00 ¤",
  dje: "#,##0.00¤",
  doi: "¤#,##0.00",
  dsb: "#,##0.00 ¤",
  dua: "#,##0.00 ¤",
  dyo: "#,##0.00 ¤",
  dz: "¤#,##,##0.00",
  ebu: "¤#,##0.00;(¤#,##0.00)",
  ee: "¤#,##0.00;(¤#,##0.00)",
  "ee-TG": "¤#,##0.00;(¤#,##0.00)",
  el: "#,##0.00 ¤",
  "el-CY": "#,##0.00 ¤",
  en: "¤#,##0.00;(¤#,##0.00)",
  "en-001": "¤#,##0.00;(¤#,##0.00)",
  "en-150": "#,##0.00 ¤",
  "en-AE": "¤#,##0.00;(¤#,##0.00)",
  "en-AG": "¤#,##0.00;(¤#,##0.00)",
  "en-AI": "¤#,##0.00;(¤#,##0.00)",
  "en-AS": "¤#,##0.00;(¤#,##0.00)",
  "en-AT": "¤ #,##0.00",
  "en-AU": "¤#,##0.00;(¤#,##0.00)",
  "en-BB": "¤#,##0.00;(¤#,##0.00)",
  "en-BE": "#,##0.00 ¤",
  "en-BI": "¤#,##0.00;(¤#,##0.00)",
  "en-BM": "¤#,##0.00;(¤#,##0.00)",
  "en-BS": "¤#,##0.00;(¤#,##0.00)",
  "en-BW": "¤#,##0.00;(¤#,##0.00)",
  "en-BZ": "¤#,##0.00;(¤#,##0.00)",
  "en-CA": "¤#,##0.00;(¤#,##0.00)",
  "en-CC": "¤#,##0.00;(¤#,##0.00)",
  "en-CH": "¤ #,##0.00;¤-#,##0.00",
  "en-CK": "¤#,##0.00;(¤#,##0.00)",
  "en-CM": "¤#,##0.00;(¤#,##0.00)",
  "en-CX": "¤#,##0.00;(¤#,##0.00)",
  "en-CY": "¤#,##0.00;(¤#,##0.00)",
  "en-DE": "#,##0.00 ¤",
  "en-DG": "¤#,##0.00;(¤#,##0.00)",
  "en-DK": "#,##0.00 ¤",
  "en-DM": "¤#,##0.00;(¤#,##0.00)",
  "en-ER": "¤#,##0.00;(¤#,##0.00)",
  "en-FI": "#,##0.00 ¤",
  "en-FJ": "¤#,##0.00;(¤#,##0.00)",
  "en-FK": "¤#,##0.00;(¤#,##0.00)",
  "en-FM": "¤#,##0.00;(¤#,##0.00)",
  "en-GB": "¤#,##0.00;(¤#,##0.00)",
  "en-GD": "¤#,##0.00;(¤#,##0.00)",
  "en-GG": "¤#,##0.00;(¤#,##0.00)",
  "en-GH": "¤#,##0.00;(¤#,##0.00)",
  "en-GI": "¤#,##0.00;(¤#,##0.00)",
  "en-GM": "¤#,##0.00;(¤#,##0.00)",
  "en-GU": "¤#,##0.00;(¤#,##0.00)",
  "en-GY": "¤#,##0.00;(¤#,##0.00)",
  "en-HK": "¤#,##0.00;(¤#,##0.00)",
  "en-IE": "¤#,##0.00;(¤#,##0.00)",
  "en-IL": "¤#,##0.00;(¤#,##0.00)",
  "en-IM": "¤#,##0.00;(¤#,##0.00)",
  "en-IN": "¤#,##0.00;(¤#,##0.00)",
  "en-IO": "¤#,##0.00;(¤#,##0.00)",
  "en-JE": "¤#,##0.00;(¤#,##0.00)",
  "en-JM": "¤#,##0.00;(¤#,##0.00)",
  "en-KE": "¤#,##0.00;(¤#,##0.00)",
  "en-KI": "¤#,##0.00;(¤#,##0.00)",
  "en-KN": "¤#,##0.00;(¤#,##0.00)",
  "en-KY": "¤#,##0.00;(¤#,##0.00)",
  "en-LC": "¤#,##0.00;(¤#,##0.00)",
  "en-LR": "¤#,##0.00;(¤#,##0.00)",
  "en-LS": "¤#,##0.00;(¤#,##0.00)",
  "en-MG": "¤#,##0.00;(¤#,##0.00)",
  "en-MH": "¤#,##0.00;(¤#,##0.00)",
  "en-MO": "¤#,##0.00;(¤#,##0.00)",
  "en-MP": "¤#,##0.00;(¤#,##0.00)",
  "en-MS": "¤#,##0.00;(¤#,##0.00)",
  "en-MT": "¤#,##0.00;(¤#,##0.00)",
  "en-MU": "¤#,##0.00;(¤#,##0.00)",
  "en-MV": "¤ #,##0.00",
  "en-MW": "¤#,##0.00;(¤#,##0.00)",
  "en-MY": "¤#,##0.00;(¤#,##0.00)",
  "en-NA": "¤#,##0.00;(¤#,##0.00)",
  "en-NF": "¤#,##0.00;(¤#,##0.00)",
  "en-NG": "¤#,##0.00;(¤#,##0.00)",
  "en-NL": "¤ #,##0.00;(¤ #,##0.00)",
  "en-NR": "¤#,##0.00;(¤#,##0.00)",
  "en-NU": "¤#,##0.00;(¤#,##0.00)",
  "en-NZ": "¤#,##0.00;(¤#,##0.00)",
  "en-PG": "¤#,##0.00;(¤#,##0.00)",
  "en-PH": "¤#,##0.00;(¤#,##0.00)",
  "en-PK": "¤#,##0.00;(¤#,##0.00)",
  "en-PN": "¤#,##0.00;(¤#,##0.00)",
  "en-PR": "¤#,##0.00;(¤#,##0.00)",
  "en-PW": "¤#,##0.00;(¤#,##0.00)",
  "en-RW": "¤#,##0.00;(¤#,##0.00)",
  "en-SB": "¤#,##0.00;(¤#,##0.00)",
  "en-SC": "¤#,##0.00;(¤#,##0.00)",
  "en-SD": "¤#,##0.00;(¤#,##0.00)",
  "en-SE": "#,##0.00 ¤",
  "en-SG": "¤#,##0.00;(¤#,##0.00)",
  "en-SH": "¤#,##0.00;(¤#,##0.00)",
  "en-SI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "en-SL": "¤#,##0.00;(¤#,##0.00)",
  "en-SS": "¤#,##0.00;(¤#,##0.00)",
  "en-SX": "¤#,##0.00;(¤#,##0.00)",
  "en-SZ": "¤#,##0.00;(¤#,##0.00)",
  "en-TC": "¤#,##0.00;(¤#,##0.00)",
  "en-TK": "¤#,##0.00;(¤#,##0.00)",
  "en-TO": "¤#,##0.00;(¤#,##0.00)",
  "en-TT": "¤#,##0.00;(¤#,##0.00)",
  "en-TV": "¤#,##0.00;(¤#,##0.00)",
  "en-TZ": "¤#,##0.00;(¤#,##0.00)",
  "en-UG": "¤#,##0.00;(¤#,##0.00)",
  "en-UM": "¤#,##0.00;(¤#,##0.00)",
  "en-VC": "¤#,##0.00;(¤#,##0.00)",
  "en-VG": "¤#,##0.00;(¤#,##0.00)",
  "en-VI": "¤#,##0.00;(¤#,##0.00)",
  "en-VU": "¤#,##0.00;(¤#,##0.00)",
  "en-WS": "¤#,##0.00;(¤#,##0.00)",
  "en-ZA": "¤#,##0.00;(¤#,##0.00)",
  "en-ZM": "¤#,##0.00;(¤#,##0.00)",
  "en-ZW": "¤#,##0.00;(¤#,##0.00)",
  eo: "¤ #,##0.00",
  es: "#,##0.00 ¤",
  "es-419": "¤#,##0.00",
  "es-AR": "¤ #,##0.00;(¤ #,##0.00)",
  "es-BO": "¤#,##0.00",
  "es-BR": "¤#,##0.00",
  "es-BZ": "¤#,##0.00",
  "es-CL": "¤#,##0.00",
  "es-CO": "¤#,##0.00",
  "es-CR": "¤#,##0.00",
  "es-CU": "¤#,##0.00",
  "es-DO": "¤#,##0.00;(¤#,##0.00)",
  "es-EA": "#,##0.00 ¤",
  "es-EC": "¤#,##0.00",
  "es-GQ": "#,##0.00 ¤",
  "es-GT": "¤#,##0.00",
  "es-HN": "¤#,##0.00",
  "es-IC": "#,##0.00 ¤",
  "es-MX": "¤#,##0.00",
  "es-NI": "¤#,##0.00",
  "es-PA": "¤#,##0.00",
  "es-PE": "¤#,##0.00",
  "es-PH": "#,##0.00 ¤",
  "es-PR": "¤#,##0.00",
  "es-PY": "¤#,##0.00",
  "es-SV": "¤#,##0.00",
  "es-US": "¤#,##0.00",
  "es-UY": "¤ #,##0.00;(¤ #,##0.00)",
  "es-VE": "¤#,##0.00",
  et: "#,##0.00 ¤;(#,##0.00 ¤)",
  eu: "#,##0.00 ¤;(#,##0.00 ¤)",
  ewo: "#,##0.00 ¤",
  fa: "‎¤ #,##0.00;‎(¤ #,##0.00)",
  "fa-AF": "¤ #,##0.00;‎(¤ #,##0.00)",
  ff: "#,##0.00 ¤",
  "ff-Adlm": "¤ #,##0.00",
  "ff-Adlm-BF": "¤ #,##0.00",
  "ff-Adlm-CM": "¤ #,##0.00",
  "ff-Adlm-GH": "¤ #,##0.00",
  "ff-Adlm-GM": "¤ #,##0.00",
  "ff-Adlm-GW": "¤ #,##0.00",
  "ff-Adlm-LR": "¤ #,##0.00",
  "ff-Adlm-MR": "¤ #,##0.00",
  "ff-Adlm-NE": "¤ #,##0.00",
  "ff-Adlm-NG": "¤ #,##0.00",
  "ff-Adlm-SL": "¤ #,##0.00",
  "ff-Adlm-SN": "¤ #,##0.00",
  "ff-Latn": "#,##0.00 ¤",
  "ff-Latn-BF": "#,##0.00 ¤",
  "ff-Latn-CM": "#,##0.00 ¤",
  "ff-Latn-GH": "#,##0.00 ¤",
  "ff-Latn-GM": "#,##0.00 ¤",
  "ff-Latn-GN": "#,##0.00 ¤",
  "ff-Latn-GW": "#,##0.00 ¤",
  "ff-Latn-LR": "#,##0.00 ¤",
  "ff-Latn-MR": "#,##0.00 ¤",
  "ff-Latn-NE": "#,##0.00 ¤",
  "ff-Latn-NG": "#,##0.00 ¤",
  "ff-Latn-SL": "#,##0.00 ¤",
  fi: "#,##0.00 ¤",
  fil: "¤#,##0.00;(¤#,##0.00)",
  fo: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fo-DK": "#,##0.00 ¤;(#,##0.00 ¤)",
  fr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BL": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GP": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-HT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-KM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-ML": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SY": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-VU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-WF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-YT": "#,##0.00 ¤;(#,##0.00 ¤)",
  fur: "¤ #,##0.00",
  fy: "¤ #,##0.00;(¤ #,##0.00)",
  ga: "¤#,##0.00;(¤#,##0.00)",
  "ga-GB": "¤#,##0.00;(¤#,##0.00)",
  gd: "¤#,##0.00;(¤#,##0.00)",
  gl: "#,##0.00 ¤",
  gsw: "#,##0.00 ¤",
  "gsw-FR": "#,##0.00 ¤",
  "gsw-LI": "#,##0.00 ¤",
  gu: "¤#,##,##0.00;(¤#,##,##0.00)",
  guz: "¤#,##0.00;(¤#,##0.00)",
  gv: "¤#,##0.00",
  ha: "¤ #,##0.00",
  "ha-GH": "¤ #,##0.00",
  "ha-NE": "¤ #,##0.00",
  haw: "¤#,##0.00;(¤#,##0.00)",
  he: "#,##0.00 ¤",
  hi: "¤#,##,##0.00",
  "hi-Latn": "¤#,##,##0.00",
  hr: "#,##0.00 ¤",
  "hr-BA": "#,##0.00 ¤",
  hsb: "#,##0.00 ¤",
  hu: "#,##0.00 ¤",
  hy: "#,##0.00 ¤",
  ia: "¤ #,##0.00;(¤ #,##0.00)",
  id: "¤#,##0.00",
  ig: "¤#,##0.00;(¤#,##0.00)",
  ii: "¤ #,##0.00",
  is: "#,##0.00 ¤",
  it: "#,##0.00 ¤",
  "it-CH": "#,##0.00 ¤",
  "it-SM": "#,##0.00 ¤",
  "it-VA": "#,##0.00 ¤",
  ja: "¤#,##0.00;(¤#,##0.00)",
  jgo: "¤ #,##0.00",
  jmc: "¤#,##0.00",
  jv: "¤ #,##0.00",
  ka: "#,##0.00 ¤",
  kab: "#,##0.00¤",
  kam: "¤#,##0.00;(¤#,##0.00)",
  kde: "¤#,##0.00;(¤#,##0.00)",
  kea: "#,##0.00 ¤;(#,##0.00 ¤)",
  kgp: "¤ #,##0.00",
  khq: "#,##0.00¤",
  ki: "¤#,##0.00;(¤#,##0.00)",
  kk: "#,##0.00 ¤",
  kkj: "¤ #,##0.00",
  kl: "¤#,##0.00;¤-#,##0.00",
  kln: "¤#,##0.00;(¤#,##0.00)",
  km: "#,##0.00¤;(#,##0.00¤)",
  kn: "¤#,##0.00;(¤#,##0.00)",
  ko: "¤#,##0.00;(¤#,##0.00)",
  "ko-KP": "¤#,##0.00;(¤#,##0.00)",
  kok: "¤#,##0.00;(¤#,##0.00)",
  ks: "¤#,##0.00",
  "ks-Arab": "¤#,##0.00",
  "ks-Deva": "¤ #,##0.00",
  ksb: "#,##0.00¤",
  ksf: "#,##0.00 ¤",
  ksh: "#,##0.00 ¤",
  ku: "#,##0.00 ¤;(#,##0.00 ¤)",
  kw: "¤#,##0.00",
  ky: "#,##0.00 ¤",
  lag: "¤ #,##0.00",
  lb: "#,##0.00 ¤",
  lg: "#,##0.00¤",
  lkt: "¤ #,##0.00",
  ln: "#,##0.00 ¤",
  "ln-AO": "#,##0.00 ¤",
  "ln-CF": "#,##0.00 ¤",
  "ln-CG": "#,##0.00 ¤",
  lo: "¤#,##0.00;¤-#,##0.00",
  lrc: "¤ #,##0.00",
  "lrc-IQ": "¤ #,##0.00",
  lt: "#,##0.00 ¤",
  lu: "#,##0.00¤",
  luo: "#,##0.00¤",
  luy: "¤#,##0.00;¤- #,##0.00",
  lv: "#,##0.00 ¤",
  mai: "¤ #,##0.00",
  mas: "¤#,##0.00;(¤#,##0.00)",
  "mas-TZ": "¤#,##0.00;(¤#,##0.00)",
  mer: "¤#,##0.00;(¤#,##0.00)",
  mfe: "¤ #,##0.00",
  mg: "¤#,##0.00",
  mgh: "¤ #,##0.00",
  mgo: "¤ #,##0.00",
  mi: "¤ #,##0.00",
  mk: "#,##0.00 ¤",
  ml: "¤#,##0.00;(¤#,##0.00)",
  mn: "¤ #,##0.00",
  mni: "¤ #,##0.00",
  "mni-Beng": "¤ #,##0.00",
  mr: "¤#,##0.00;(¤#,##0.00)",
  ms: "¤#,##0.00;(¤#,##0.00)",
  "ms-BN": "¤#,##0.00;(¤#,##0.00)",
  "ms-ID": "¤#,##0.00",
  "ms-SG": "¤#,##0.00;(¤#,##0.00)",
  mt: "¤#,##0.00",
  mua: "¤#,##0.00;(¤#,##0.00)",
  my: "¤ #,##0.00",
  mzn: "¤ #,##0.00",
  naq: "¤#,##0.00",
  nb: "¤ #,##0.00;(¤ #,##0.00)",
  "nb-SJ": "¤ #,##0.00;(¤ #,##0.00)",
  nd: "¤#,##0.00;(¤#,##0.00)",
  nds: "¤ #,##0.00",
  "nds-NL": "¤ #,##0.00",
  ne: "¤ #,##,##0.00",
  "ne-IN": "¤ #,##,##0.00",
  nl: "¤ #,##0.00;(¤ #,##0.00)",
  "nl-AW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BE": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BQ": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-CW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SR": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SX": "¤ #,##0.00;(¤ #,##0.00)",
  nmg: "#,##0.00 ¤",
  nn: "#,##0.00 ¤",
  nnh: "¤ #,##0.00",
  no: "¤ #,##0.00;(¤ #,##0.00)",
  nus: "¤#,##0.00;(¤#,##0.00)",
  nyn: "¤#,##0.00",
  om: "¤#,##0.00",
  "om-KE": "¤#,##0.00",
  or: "¤#,##0.00;(¤#,##0.00)",
  os: "¤ #,##0.00",
  "os-RU": "¤ #,##0.00",
  pa: "¤ #,##0.00",
  "pa-Arab": "¤ #,##0.00",
  "pa-Guru": "¤ #,##0.00",
  pcm: "¤#,##0.00",
  pl: "#,##0.00 ¤;(#,##0.00 ¤)",
  ps: "¤#,##0.00;(¤#,##0.00)",
  "ps-PK": "¤#,##0.00;(¤#,##0.00)",
  pt: "¤ #,##0.00",
  "pt-AO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CV": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-PT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-ST": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-TL": "#,##0.00 ¤;(#,##0.00 ¤)",
  qu: "¤ #,##0.00",
  "qu-BO": "¤ #,##0.00",
  "qu-EC": "¤ #,##0.00",
  rm: "#,##0.00 ¤",
  rn: "#,##0.00¤",
  ro: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ro-MD": "#,##0.00 ¤;(#,##0.00 ¤)",
  rof: "¤#,##0.00",
  ru: "#,##0.00 ¤",
  "ru-BY": "#,##0.00 ¤",
  "ru-KG": "#,##0.00 ¤",
  "ru-KZ": "#,##0.00 ¤",
  "ru-MD": "#,##0.00 ¤",
  "ru-UA": "#,##0.00 ¤",
  rw: "¤ #,##0.00",
  rwk: "#,##0.00¤",
  sa: "¤ #,##0.00",
  sah: "#,##0.00 ¤",
  saq: "¤#,##0.00;(¤#,##0.00)",
  sat: "¤ #,##0.00",
  "sat-Olck": "¤ #,##0.00",
  sbp: "#,##0.00¤",
  sc: "#,##0.00 ¤",
  sd: "¤ #,##0.00",
  "sd-Arab": "¤ #,##0.00",
  "sd-Deva": "¤ #,##0.00",
  se: "#,##0.00 ¤",
  "se-FI": "#,##0.00 ¤",
  "se-SE": "#,##0.00 ¤",
  seh: "#,##0.00¤",
  ses: "#,##0.00¤",
  sg: "¤#,##0.00;¤-#,##0.00",
  shi: "#,##0.00¤",
  "shi-Latn": "#,##0.00¤",
  "shi-Tfng": "#,##0.00¤",
  si: "¤#,##0.00;(¤#,##0.00)",
  sk: "#,##0.00 ¤;(#,##0.00 ¤)",
  sl: "#,##0.00 ¤;(#,##0.00 ¤)",
  smn: "#,##0.00 ¤",
  sn: "¤#,##0.00;(¤#,##0.00)",
  so: "¤#,##0.00;(¤#,##0.00)",
  "so-DJ": "¤#,##0.00;(¤#,##0.00)",
  "so-ET": "¤#,##0.00;(¤#,##0.00)",
  "so-KE": "¤#,##0.00;(¤#,##0.00)",
  sq: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-MK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  sr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  su: "¤#,##0.00",
  "su-Latn": "¤#,##0.00",
  sv: "#,##0.00 ¤",
  "sv-AX": "#,##0.00 ¤",
  "sv-FI": "#,##0.00 ¤",
  sw: "¤ #,##0.00",
  "sw-CD": "¤ #,##0.00",
  "sw-KE": "¤ #,##0.00",
  "sw-UG": "¤ #,##0.00",
  ta: "¤#,##0.00;(¤#,##0.00)",
  "ta-LK": "¤#,##0.00;(¤#,##0.00)",
  "ta-MY": "¤#,##0.00;(¤#,##0.00)",
  "ta-SG": "¤#,##0.00;(¤#,##0.00)",
  te: "¤#,##0.00;(¤#,##0.00)",
  teo: "¤#,##0.00;(¤#,##0.00)",
  "teo-KE": "¤#,##0.00;(¤#,##0.00)",
  tg: "#,##0.00 ¤",
  th: "¤#,##0.00;(¤#,##0.00)",
  ti: "¤#,##0.00",
  "ti-ER": "¤#,##0.00",
  tk: "#,##0.00 ¤",
  to: "¤ #,##0.00",
  tr: "¤#,##0.00;(¤#,##0.00)",
  "tr-CY": "¤#,##0.00;(¤#,##0.00)",
  tt: "#,##0.00 ¤",
  twq: "#,##0.00¤",
  tzm: "#,##0.00 ¤",
  ug: "¤#,##0.00;(¤#,##0.00)",
  uk: "#,##0.00 ¤",
  und: "¤ #,##0.00",
  ur: "¤#,##0.00;(¤#,##0.00)",
  "ur-IN": "¤#,##0.00;(¤#,##0.00)",
  uz: "#,##0.00 ¤",
  "uz-Arab": "¤ #,##0.00",
  "uz-Cyrl": "#,##0.00 ¤",
  "uz-Latn": "#,##0.00 ¤",
  vai: "¤#,##0.00;(¤#,##0.00)",
  "vai-Latn": "¤#,##0.00;(¤#,##0.00)",
  "vai-Vaii": "¤#,##0.00;(¤#,##0.00)",
  vi: "#,##0.00 ¤",
  vun: "¤#,##0.00",
  wae: "¤ #,##0.00",
  wo: "¤ #,##0.00",
  xh: "¤#,##0.00",
  xog: "#,##0.00 ¤",
  yav: "#,##0.00 ¤;(#,##0.00 ¤)",
  yi: "¤ #,##0.00",
  yo: "¤#,##0.00;(¤#,##0.00)",
  "yo-BJ": "¤#,##0.00;(¤#,##0.00)",
  yrl: "¤ #,##0.00",
  "yrl-CO": "¤ #,##0.00",
  "yrl-VE": "¤ #,##0.00",
  yue: "¤#,##0.00;(¤#,##0.00)",
  "yue-Hans": "¤#,##0.00;(¤#,##0.00)",
  "yue-Hant": "¤#,##0.00;(¤#,##0.00)",
  zgh: "#,##0.00¤",
  zh: "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-MO": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-SG": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-MO": "¤#,##0.00;(¤#,##0.00)",
  zu: "¤#,##0.00;(¤#,##0.00)"
};

// node_modules/devextreme/esm/common/core/localization/intl/number.js
var CURRENCY_STYLES = ["standard", "accounting"];
var detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
var formattersCache = {};
var getFormatter3 = (format2) => {
  const key = core_default.locale() + "/" + JSON.stringify(format2);
  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.NumberFormat(core_default.locale(), format2).format;
  }
  return formattersCache[key];
};
var getCurrencyFormatter = (currency) => new Intl.NumberFormat(core_default.locale(), {
  style: "currency",
  currency
});
var number_default = {
  engine: function() {
    return "intl";
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("exponential" === format2) {
      return this.callBase.apply(this, arguments);
    }
    return getFormatter3(this._normalizeFormatConfig(format2, formatConfig, value2))(value2);
  },
  _normalizeFormatConfig: function(format2, formatConfig, value2) {
    let config3;
    if ("decimal" === format2) {
      const fractionDigits = String(value2).split(".")[1];
      config3 = {
        minimumIntegerDigits: formatConfig.precision || void 0,
        useGrouping: false,
        maximumFractionDigits: fractionDigits && fractionDigits.length,
        round: value2 < 0 ? "ceil" : "floor"
      };
    } else {
      config3 = this._getPrecisionConfig(formatConfig.precision);
    }
    if ("percent" === format2) {
      config3.style = "percent";
    } else if ("currency" === format2) {
      const useAccountingStyle = formatConfig.useCurrencyAccountingStyle ?? config_default().defaultUseCurrencyAccountingStyle;
      config3.style = "currency";
      config3.currency = formatConfig.currency || config_default().defaultCurrency;
      config3.currencySign = CURRENCY_STYLES[+useAccountingStyle];
    }
    return config3;
  },
  _getPrecisionConfig: function(precision) {
    let config3;
    if (null === precision) {
      config3 = {
        minimumFractionDigits: 0,
        maximumFractionDigits: 20
      };
    } else {
      config3 = {
        minimumFractionDigits: precision || 0,
        maximumFractionDigits: precision || 0
      };
    }
    return config3;
  },
  format: function(value2, format2) {
    if ("number" !== typeof value2) {
      return value2;
    }
    format2 = this._normalizeFormat(format2);
    if ("default" === format2.currency) {
      format2.currency = config_default().defaultCurrency;
    }
    if (!format2 || "function" !== typeof format2 && !format2.type && !format2.formatter) {
      return getFormatter3(format2)(value2);
    }
    const result2 = this.callBase.apply(this, arguments);
    return result2;
  },
  _getCurrencySymbolInfo: function(currency) {
    const formatter = getCurrencyFormatter(currency);
    return this._extractCurrencySymbolInfo(formatter.format(0));
  },
  _extractCurrencySymbolInfo: function(currencyValueString) {
    const match2 = detectCurrencySymbolRegex.exec(currencyValueString) || [];
    const position2 = match2[1] ? "before" : "after";
    const symbol = match2[1] || match2[4] || "";
    const delimiter = match2[2] || match2[3] || "";
    return {
      position: position2,
      symbol,
      delimiter
    };
  },
  getCurrencySymbol: function(currency) {
    if (!currency) {
      currency = config_default().defaultCurrency;
    }
    const symbolInfo = this._getCurrencySymbolInfo(currency);
    return {
      symbol: symbolInfo.symbol
    };
  },
  getOpenXmlCurrencyFormat: function(currency) {
    const targetCurrency = currency || config_default().defaultCurrency;
    const currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
    const closestAccountingFormat = core_default.getValueByClosestLocale((locale) => accounting_formats_default[locale]);
    return open_xml_currency_format_default(currencySymbol, closestAccountingFormat);
  }
};

// node_modules/devextreme/esm/common/core/localization/number.js
var hasIntl = "undefined" !== typeof Intl;
var NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
var LargeNumberFormatPostfixes = {
  1: "K",
  2: "M",
  3: "B",
  4: "T"
};
var LargeNumberFormatPowers = {
  largenumber: "auto",
  thousands: 1,
  millions: 2,
  billions: 3,
  trillions: 4
};
var numberLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  numericFormats: NUMERIC_FORMATS,
  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
  _parseNumberFormatString: function(formatType) {
    const formatObject = {};
    if (!formatType || "string" !== typeof formatType) {
      return;
    }
    const formatList = formatType.toLowerCase().split(" ");
    each(formatList, (index2, value2) => {
      if (NUMERIC_FORMATS.includes(value2)) {
        formatObject.formatType = value2;
      } else if (value2 in LargeNumberFormatPowers) {
        formatObject.power = LargeNumberFormatPowers[value2];
      }
    });
    if (formatObject.power && !formatObject.formatType) {
      formatObject.formatType = "fixedpoint";
    }
    if (formatObject.formatType) {
      return formatObject;
    }
  },
  _calculateNumberPower: function(value2, base2, minPower, maxPower) {
    let number = Math.abs(value2);
    let power = 0;
    if (number > 1) {
      while (number && number >= base2 && (void 0 === maxPower || power < maxPower)) {
        power++;
        number /= base2;
      }
    } else if (number > 0 && number < 1) {
      while (number < 1 && (void 0 === minPower || power > minPower)) {
        power--;
        number *= base2;
      }
    }
    return power;
  },
  _getNumberByPower: function(number, power, base2) {
    let result2 = number;
    while (power > 0) {
      result2 /= base2;
      power--;
    }
    while (power < 0) {
      result2 *= base2;
      power++;
    }
    return result2;
  },
  _formatNumber: function(value2, formatObject, formatConfig) {
    if ("auto" === formatObject.power) {
      formatObject.power = this._calculateNumberPower(value2, 1e3, 0, 4);
    }
    if (formatObject.power) {
      value2 = this._getNumberByPower(value2, formatObject.power, 1e3);
    }
    const powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
    let result2 = this._formatNumberCore(value2, formatObject.formatType, formatConfig);
    result2 = result2.replace(/(\d|.$)(\D*)$/, "$1" + powerPostfix + "$2");
    return result2;
  },
  _formatNumberExponential: function(value2, formatConfig) {
    let power = this._calculateNumberPower(value2, 10);
    let number = this._getNumberByPower(value2, power, 10);
    if (void 0 === formatConfig.precision) {
      formatConfig.precision = 1;
    }
    if (number.toFixed(formatConfig.precision || 0) >= 10) {
      power++;
      number /= 10;
    }
    const powString = (power >= 0 ? "+" : "") + power.toString();
    return this._formatNumberCore(number, "fixedpoint", formatConfig) + "E" + powString;
  },
  _addZeroes: function(value2, precision) {
    const multiplier = Math.pow(10, precision);
    const sign2 = value2 < 0 ? "-" : "";
    value2 = (Math.abs(value2) * multiplier >>> 0) / multiplier;
    let result2 = value2.toString();
    while (result2.length < precision) {
      result2 = "0" + result2;
    }
    return sign2 + result2;
  },
  _addGroupSeparators: function(value2) {
    const parts = value2.toString().split(".");
    return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, config_default2().thousandsSeparator) + (parts[1] ? config_default2().decimalSeparator + parts[1] : "");
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("exponential" === format2) {
      return this._formatNumberExponential(value2, formatConfig);
    }
    if ("decimal" !== format2 && null !== formatConfig.precision) {
      formatConfig.precision = formatConfig.precision || 0;
    }
    if ("percent" === format2) {
      value2 *= 100;
    }
    if (void 0 !== formatConfig.precision) {
      if ("decimal" === format2) {
        value2 = this._addZeroes(value2, formatConfig.precision);
      } else {
        value2 = null === formatConfig.precision ? value2.toPrecision() : toFixed(value2, formatConfig.precision);
      }
    }
    if ("decimal" !== format2) {
      value2 = this._addGroupSeparators(value2);
    } else {
      value2 = value2.toString().replace(".", config_default2().decimalSeparator);
    }
    if ("percent" === format2) {
      value2 += "%";
    }
    return value2;
  },
  _normalizeFormat: function(format2) {
    if (!format2) {
      return {};
    }
    if ("function" === typeof format2) {
      return format2;
    }
    if (!isPlainObject(format2)) {
      format2 = {
        type: format2
      };
    }
    return format2;
  },
  _getSeparators: function() {
    return {
      decimalSeparator: this.getDecimalSeparator(),
      thousandsSeparator: this.getThousandsSeparator()
    };
  },
  getThousandsSeparator: function() {
    return this.format(1e4, "fixedPoint")[2];
  },
  getDecimalSeparator: function() {
    return this.format(1.2, {
      type: "fixedPoint",
      precision: 1
    })[1];
  },
  convertDigits: function(value2, toStandard) {
    const digits = this.format(90, "decimal");
    if ("string" !== typeof value2 || "0" === digits[1]) {
      return value2;
    }
    const fromFirstDigit = toStandard ? digits[1] : "0";
    const toFirstDigit = toStandard ? "0" : digits[1];
    const fromLastDigit = toStandard ? digits[0] : "9";
    const regExp = new RegExp("[" + fromFirstDigit + "-" + fromLastDigit + "]", "g");
    return value2.replace(regExp, (char) => String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0))));
  },
  getNegativeEtalonRegExp: function(format2) {
    const separators = this._getSeparators();
    const digitalRegExp = new RegExp("[0-9" + escapeRegExp(separators.decimalSeparator + separators.thousandsSeparator) + "]+", "g");
    let negativeEtalon = this.format(-1, format2).replace(digitalRegExp, "1");
    ["\\", "(", ")", "[", "]", "*", "+", "$", "^", "?", "|", "{", "}"].forEach((char) => {
      negativeEtalon = negativeEtalon.replace(new RegExp(`\\${char}`, "g"), `\\${char}`);
    });
    negativeEtalon = negativeEtalon.replace(/ /g, "\\s");
    negativeEtalon = negativeEtalon.replace(/1/g, ".*");
    return new RegExp(negativeEtalon, "g");
  },
  getSign: function(text, format2) {
    if (!format2) {
      if ("-" === text.replace(/[^0-9-]/g, "").charAt(0)) {
        return -1;
      }
      return 1;
    }
    const negativeEtalon = this.getNegativeEtalonRegExp(format2);
    return text.match(negativeEtalon) ? -1 : 1;
  },
  format: function(value2, format2) {
    if ("number" !== typeof value2) {
      return value2;
    }
    if ("number" === typeof format2) {
      return value2;
    }
    format2 = format2 && format2.formatter || format2;
    if ("function" === typeof format2) {
      return format2(value2);
    }
    format2 = this._normalizeFormat(format2);
    if (!format2.type) {
      format2.type = "decimal";
    }
    const numberConfig = this._parseNumberFormatString(format2.type);
    if (!numberConfig) {
      const formatterConfig = this._getSeparators();
      formatterConfig.unlimitedIntegerDigits = format2.unlimitedIntegerDigits;
      const formatter = getFormatter2(format2.type, formatterConfig)(value2);
      const result2 = this.convertDigits(formatter);
      return result2;
    }
    return this._formatNumber(value2, numberConfig, format2);
  },
  parse: function(text, format2) {
    if (!text) {
      return;
    }
    if (format2 && format2.parser) {
      return format2.parser(text);
    }
    text = this.convertDigits(text, true);
    if (format2 && "string" !== typeof format2) {
      errors_default.log("W0011");
    }
    const decimalSeparator = this.getDecimalSeparator();
    const regExp = new RegExp("[^0-9" + escapeRegExp(decimalSeparator) + "]", "g");
    const cleanedText = text.replace(regExp, "").replace(decimalSeparator, ".").replace(/\.$/g, "");
    if ("." === cleanedText || "" === cleanedText) {
      return null;
    }
    if (this._calcSignificantDigits(cleanedText) > 15) {
      return NaN;
    }
    let parsed = +cleanedText * this.getSign(text, format2);
    format2 = this._normalizeFormat(format2);
    const formatConfig = this._parseNumberFormatString(format2.type);
    let power = null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.power;
    if (power) {
      if ("auto" === power) {
        const match2 = text.match(/\d(K|M|B|T)/);
        if (match2) {
          power = Object.keys(LargeNumberFormatPostfixes).find((power2) => LargeNumberFormatPostfixes[power2] === match2[1]);
        }
      }
      parsed *= Math.pow(10, 3 * power);
    }
    if ("percent" === (null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.formatType)) {
      parsed /= 100;
    }
    return parsed;
  },
  _calcSignificantDigits: function(text) {
    const [integer, fractional] = text.split(".");
    const calcDigitsAfterLeadingZeros = (digits) => {
      let index2 = -1;
      for (let i = 0; i < digits.length; i++) {
        if ("0" !== digits[i]) {
          index2 = i;
          break;
        }
      }
      return index2 > -1 ? digits.length - index2 : 0;
    };
    let result2 = 0;
    if (integer) {
      result2 += calcDigitsAfterLeadingZeros(integer.split(""));
    }
    if (fractional) {
      result2 += calcDigitsAfterLeadingZeros(fractional.split("").reverse());
    }
    return result2;
  }
});
numberLocalization.inject(currency_default);
if (hasIntl) {
  numberLocalization.inject(number_default);
}
var number_default2 = numberLocalization;

// node_modules/devextreme/esm/__internal/ui/m_validation_engine.js
var EMAIL_VALIDATION_REGEX = /^[\d\w.+_-]+@[\d\w._-]+\.[\w]+$/i;
var STATUS = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
var BaseRuleValidator = class {
  constructor() {
    this.NAME = "base";
  }
  defaultMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}`)(value2);
  }
  defaultFormattedMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}-formatted`)(value2);
  }
  _isValueEmpty(value2) {
    return !rulesValidators.required.validate(value2, {});
  }
  validate(value2, rule) {
    const valueArray = Array.isArray(value2) ? value2 : [value2];
    let result2 = true;
    if (valueArray.length) {
      valueArray.every((itemValue) => {
        result2 = this._validate(itemValue, rule);
        return result2;
      });
    } else {
      result2 = this._validate(null, rule);
    }
    return result2;
  }
};
var RequiredRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "required";
  }
  _validate(value2, rule) {
    if (!isDefined(value2)) {
      return false;
    }
    if (false === value2) {
      return false;
    }
    value2 = String(value2);
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    return "" !== value2;
  }
};
var NumericRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "numeric";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    if (rule.useCultureSettings && isString(value2)) {
      return !isNaN(number_default2.parse(value2));
    }
    return isNumeric(value2);
  }
};
var RangeRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "range";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const validNumber = rulesValidators.numeric.validate(value2, rule);
    const validValue = isDefined(value2) && "" !== value2;
    const number = validNumber ? parseFloat(value2) : validValue && value2.valueOf();
    const {
      min
    } = rule;
    const {
      max
    } = rule;
    if (!(validNumber || isDate(value2)) && !validValue) {
      return false;
    }
    if (isDefined(min)) {
      if (isDefined(max)) {
        return number >= min && number <= max;
      }
      return number >= min;
    }
    if (isDefined(max)) {
      return number <= max;
    }
    throw errors_default.Error("E0101");
  }
};
var StringLengthRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "stringLength";
  }
  _validate(value2, rule) {
    value2 = String(value2 ?? "");
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.range.validate(value2.length, extend({}, rule));
  }
};
var CustomRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "custom";
  }
  validate(value2, rule) {
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    return rule.validationCallback(params);
  }
};
var AsyncRuleValidator = class extends CustomRuleValidator {
  constructor() {
    super();
    this.NAME = "async";
  }
  validate(value2, rule) {
    if (!isDefined(rule.reevaluate)) {
      extend(rule, {
        reevaluate: true
      });
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    const callbackResult = rule.validationCallback(params);
    if (!isPromise(callbackResult)) {
      throw errors_default.Error("E0103");
    }
    return this._getWrappedPromise(fromPromise(callbackResult).promise());
  }
  _getWrappedPromise(promise) {
    const deferred = Deferred();
    promise.then((res) => {
      deferred.resolve(res);
    }, (err) => {
      const res = {
        isValid: false
      };
      if (isDefined(err)) {
        if (isString(err)) {
          res.message = err;
        } else if (isObject(err) && isDefined(err.message) && isString(err.message)) {
          res.message = err.message;
        }
      }
      deferred.resolve(res);
    });
    return deferred.promise();
  }
};
var CompareRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "compare";
  }
  _validate(value2, rule) {
    if (!rule.comparisonTarget) {
      throw errors_default.Error("E0102");
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    extend(rule, {
      reevaluate: true
    });
    const otherValue = rule.comparisonTarget();
    const type2 = rule.comparisonType || "==";
    switch (type2) {
      case "==":
        return value2 == otherValue;
      case "!=":
        return value2 != otherValue;
      case "===":
        return value2 === otherValue;
      case "!==":
        return value2 !== otherValue;
      case ">":
        return value2 > otherValue;
      case ">=":
        return value2 >= otherValue;
      case "<":
        return value2 < otherValue;
      case "<=":
        return value2 <= otherValue;
    }
  }
};
var PatternRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "pattern";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    let {
      pattern
    } = rule;
    if (isString(pattern)) {
      pattern = new RegExp(pattern);
    }
    return pattern.test(value2);
  }
};
var EmailRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "email";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.pattern.validate(value2, extend({}, rule, {
      pattern: EMAIL_VALIDATION_REGEX
    }));
  }
};
var rulesValidators = {
  required: new RequiredRuleValidator(),
  numeric: new NumericRuleValidator(),
  range: new RangeRuleValidator(),
  stringLength: new StringLengthRuleValidator(),
  custom: new CustomRuleValidator(),
  async: new AsyncRuleValidator(),
  compare: new CompareRuleValidator(),
  pattern: new PatternRuleValidator(),
  email: new EmailRuleValidator()
};
var GroupConfig = class extends class_default.inherit({}) {
  ctor(group, isRemovable) {
    this.group = group;
    this.validators = [];
    this._isRemovable = isRemovable;
    this._pendingValidators = [];
    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
    this._resetValidationInfo();
    this._eventsStrategy = new EventsStrategy(this);
  }
  validate() {
    const result2 = {
      isValid: true,
      brokenRules: [],
      validators: [],
      status: STATUS.valid,
      complete: null
    };
    this._unsubscribeFromAllChangeEvents();
    this._pendingValidators = [];
    this._resetValidationInfo();
    each(this.validators, (_, validator) => {
      const validatorResult = validator.validate();
      result2.isValid = result2.isValid && validatorResult.isValid;
      if (validatorResult.brokenRules) {
        result2.brokenRules = result2.brokenRules.concat(validatorResult.brokenRules);
      }
      result2.validators.push(validator);
      if (validatorResult.status === STATUS.pending) {
        this._addPendingValidator(validator);
      }
      this._subscribeToChangeEvents(validator);
    });
    if (this._pendingValidators.length) {
      result2.status = STATUS.pending;
    } else {
      result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
      this._unsubscribeFromAllChangeEvents();
      this._raiseValidatedEvent(result2);
    }
    this._updateValidationInfo(result2);
    return extend({}, this._validationInfo.result);
  }
  _subscribeToChangeEvents(validator) {
    validator.on("validating", this._onValidatorStatusChanged);
    validator.on("validated", this._onValidatorStatusChanged);
  }
  _unsubscribeFromChangeEvents(validator) {
    validator.off("validating", this._onValidatorStatusChanged);
    validator.off("validated", this._onValidatorStatusChanged);
  }
  _unsubscribeFromAllChangeEvents() {
    each(this.validators, (_, validator) => {
      this._unsubscribeFromChangeEvents(validator);
    });
  }
  _updateValidationInfo(result2) {
    this._validationInfo.result = result2;
    if (result2.status !== STATUS.pending) {
      return;
    }
    if (!this._validationInfo.deferred) {
      this._validationInfo.deferred = Deferred();
      this._validationInfo.result.complete = this._validationInfo.deferred.promise();
    }
  }
  _addPendingValidator(validator) {
    const foundValidator = grep(this._pendingValidators, (val) => val === validator)[0];
    if (!foundValidator) {
      this._pendingValidators.push(validator);
    }
  }
  _removePendingValidator(validator) {
    const index2 = this._pendingValidators.indexOf(validator);
    if (index2 >= 0) {
      this._pendingValidators.splice(index2, 1);
    }
  }
  _orderBrokenRules(brokenRules) {
    let orderedRules = [];
    each(this.validators, (_, validator) => {
      const foundRules = grep(brokenRules, (rule) => rule.validator === validator);
      if (foundRules.length) {
        orderedRules = orderedRules.concat(foundRules);
      }
    });
    return orderedRules;
  }
  _updateBrokenRules(result2) {
    if (!this._validationInfo.result) {
      return;
    }
    let {
      brokenRules
    } = this._validationInfo.result;
    const rules = grep(brokenRules, (rule) => rule.validator !== result2.validator);
    if (result2.brokenRules) {
      brokenRules = rules.concat(result2.brokenRules);
    }
    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
  }
  _onValidatorStatusChanged(result2) {
    if (result2.status === STATUS.pending) {
      this._addPendingValidator(result2.validator);
      return;
    }
    this._resolveIfComplete(result2);
  }
  _resolveIfComplete(result2) {
    this._removePendingValidator(result2.validator);
    this._updateBrokenRules(result2);
    if (!this._pendingValidators.length) {
      this._unsubscribeFromAllChangeEvents();
      if (!this._validationInfo.result) {
        return;
      }
      this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;
      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
      const res = extend({}, this._validationInfo.result, {
        complete: null
      });
      const {
        deferred
      } = this._validationInfo;
      this._validationInfo.deferred = null;
      this._raiseValidatedEvent(res);
      deferred && setTimeout(() => {
        deferred.resolve(res);
      });
    }
  }
  _raiseValidatedEvent(result2) {
    this._eventsStrategy.fireEvent("validated", [result2]);
  }
  _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  }
  _synchronizeValidationInfo() {
    if (this._validationInfo.result) {
      this._validationInfo.result.validators = this.validators;
    }
  }
  removeRegisteredValidator(validator) {
    const index2 = this.validators.indexOf(validator);
    if (index2 > -1) {
      this.validators.splice(index2, 1);
      this._synchronizeValidationInfo();
      this._resolveIfComplete({
        validator
      });
    }
  }
  registerValidator(validator) {
    if (!this.validators.includes(validator)) {
      this.validators.push(validator);
      this._synchronizeValidationInfo();
    }
  }
  reset() {
    each(this.validators, (_, validator) => {
      validator.reset();
    });
    this._pendingValidators = [];
    this._resetValidationInfo();
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
};
var ValidationEngine = {
  groups: [],
  getGroupConfig(group) {
    const result2 = grep(this.groups, (config3) => config3.group === group);
    if (result2.length) {
      return result2[0];
    }
  },
  findGroup($element, model) {
    var _$element$data;
    const hasValidationGroup = null === (_$element$data = $element.data()) || void 0 === _$element$data || null === (_$element$data = _$element$data.dxComponents) || void 0 === _$element$data ? void 0 : _$element$data.includes("dxValidationGroup");
    const validationGroup = hasValidationGroup && $element.dxValidationGroup("instance");
    if (validationGroup) {
      return validationGroup;
    }
    const $dxGroup = $element.parents(".dx-validationgroup").first();
    if ($dxGroup.length) {
      return $dxGroup.dxValidationGroup("instance");
    }
    return model;
  },
  initGroups() {
    this.groups = [];
    this.addGroup(void 0, false);
  },
  addGroup(group) {
    let isRemovable = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
    let config3 = this.getGroupConfig(group);
    if (!config3) {
      config3 = new GroupConfig(group, isRemovable);
      this.groups.push(config3);
    }
    return config3;
  },
  removeGroup(group) {
    const config3 = this.getGroupConfig(group);
    const index2 = this.groups.indexOf(config3);
    if (index2 > -1) {
      this.groups.splice(index2, 1);
    }
    return config3;
  },
  _setDefaultMessage(info) {
    const {
      rule,
      validator,
      name: name2
    } = info;
    if (!isDefined(rule.message)) {
      if (validator.defaultFormattedMessage && isDefined(name2)) {
        rule.message = validator.defaultFormattedMessage(name2);
      } else {
        rule.message = validator.defaultMessage();
      }
    }
  },
  _addBrokenRule(info) {
    const {
      result: result2,
      rule
    } = info;
    if (!result2.brokenRule) {
      result2.brokenRule = rule;
    }
    if (!result2.brokenRules) {
      result2.brokenRules = [];
    }
    result2.brokenRules.push(rule);
  },
  validate(value2, rules, name2) {
    var _rules$;
    let result2 = {
      name: name2,
      value: value2,
      brokenRule: null,
      brokenRules: null,
      isValid: true,
      validationRules: rules,
      pendingRules: null,
      status: STATUS.valid,
      complete: null
    };
    const validator = null === rules || void 0 === rules || null === (_rules$ = rules[0]) || void 0 === _rules$ ? void 0 : _rules$.validator;
    const asyncRuleItems = [];
    each(rules || [], (_, rule) => {
      const ruleValidator = rulesValidators[rule.type];
      let ruleValidationResult;
      if (ruleValidator) {
        if (isDefined(rule.isValid) && rule.value === value2 && !rule.reevaluate) {
          if (!rule.isValid) {
            result2.isValid = false;
            this._addBrokenRule({
              result: result2,
              rule
            });
            return false;
          }
          return true;
        }
        rule.value = value2;
        if ("async" === rule.type) {
          asyncRuleItems.push({
            rule,
            ruleValidator
          });
          return true;
        }
        ruleValidationResult = ruleValidator.validate(value2, rule);
        rule.isValid = ruleValidationResult;
        if (!ruleValidationResult) {
          result2.isValid = false;
          this._setDefaultMessage({
            rule,
            validator: ruleValidator,
            name: name2
          });
          this._addBrokenRule({
            result: result2,
            rule
          });
        }
        if (!rule.isValid) {
          return false;
        }
      } else {
        throw errors_default.Error("E0100");
      }
    });
    if (result2.isValid && !result2.brokenRules && asyncRuleItems.length) {
      result2 = this._validateAsyncRules({
        value: value2,
        items: asyncRuleItems,
        result: result2,
        name: name2
      });
    }
    this._synchronizeGroupValidationInfo(validator, result2);
    result2.status = result2.pendingRules ? STATUS.pending : result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  _synchronizeGroupValidationInfo(validator, result2) {
    if (!validator) {
      return;
    }
    const groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);
    groupConfig._updateBrokenRules.call(groupConfig, {
      validator,
      brokenRules: result2.brokenRules ?? []
    });
  },
  _validateAsyncRules(_ref) {
    let {
      result: result2,
      value: value2,
      items,
      name: name2
    } = _ref;
    const asyncResults = [];
    each(items, (_, item) => {
      const validateResult = item.ruleValidator.validate(value2, item.rule);
      if (!isPromise(validateResult)) {
        this._updateRuleConfig({
          rule: item.rule,
          ruleResult: this._getPatchedRuleResult(validateResult),
          validator: item.ruleValidator,
          name: name2
        });
      } else {
        if (!result2.pendingRules) {
          result2.pendingRules = [];
        }
        result2.pendingRules.push(item.rule);
        const asyncResult = validateResult.then((res) => {
          const ruleResult = this._getPatchedRuleResult(res);
          this._updateRuleConfig({
            rule: item.rule,
            ruleResult,
            validator: item.ruleValidator,
            name: name2
          });
          return ruleResult;
        });
        asyncResults.push(asyncResult);
      }
    });
    if (asyncResults.length) {
      result2.complete = Promise.all(asyncResults).then((values) => this._getAsyncRulesResult({
        result: result2,
        values
      }));
    }
    return result2;
  },
  _updateRuleConfig(_ref2) {
    let {
      rule,
      ruleResult,
      validator,
      name: name2
    } = _ref2;
    rule.isValid = ruleResult.isValid;
    if (!ruleResult.isValid) {
      if (isDefined(ruleResult.message) && isString(ruleResult.message) && ruleResult.message.length) {
        rule.message = ruleResult.message;
      } else {
        this._setDefaultMessage({
          rule,
          validator,
          name: name2
        });
      }
    }
  },
  _getPatchedRuleResult(ruleResult) {
    let result2;
    if (isObject(ruleResult)) {
      result2 = extend({}, ruleResult);
      if (!isDefined(result2.isValid)) {
        result2.isValid = true;
      }
    } else {
      result2 = {
        isValid: isBoolean(ruleResult) ? ruleResult : true
      };
    }
    return result2;
  },
  _getAsyncRulesResult(_ref3) {
    let {
      values,
      result: result2
    } = _ref3;
    each(values, (index2, val) => {
      if (false === val.isValid) {
        result2.isValid = val.isValid;
        const rule = result2.pendingRules[index2];
        this._addBrokenRule({
          result: result2,
          rule
        });
      }
    });
    result2.pendingRules = null;
    result2.complete = null;
    result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  registerValidatorInGroup(group, validator) {
    const groupConfig = ValidationEngine.addGroup(group);
    groupConfig.registerValidator.call(groupConfig, validator);
  },
  removeRegisteredValidator(group, validator) {
    const config3 = ValidationEngine.getGroupConfig(group);
    if (config3) {
      config3.removeRegisteredValidator.call(config3, validator);
      const validatorsInGroup = config3.validators;
      const isRemovable = config3._isRemovable;
      const shouldRemoveGroup = 0 === validatorsInGroup.length && isRemovable;
      if (shouldRemoveGroup) {
        this.removeGroup(group);
      }
    }
  },
  initValidationOptions(options2) {
    const initedOptions = {};
    if (options2) {
      const syncOptions = ["isValid", "validationStatus", "validationError", "validationErrors"];
      syncOptions.forEach((prop) => {
        if (prop in options2) {
          extend(initedOptions, this.synchronizeValidationOptions({
            name: prop,
            value: options2[prop]
          }, options2));
        }
      });
    }
    return initedOptions;
  },
  synchronizeValidationOptions(_ref4, options2) {
    let {
      name: name2,
      value: value2
    } = _ref4;
    switch (name2) {
      case "validationStatus": {
        const isValid = value2 === STATUS.valid || value2 === STATUS.pending;
        return options2.isValid !== isValid ? {
          isValid
        } : {};
      }
      case "isValid": {
        const {
          validationStatus
        } = options2;
        let newStatus = validationStatus;
        if (value2 && validationStatus === STATUS.invalid) {
          newStatus = STATUS.valid;
        } else if (!value2 && validationStatus !== STATUS.invalid) {
          newStatus = STATUS.invalid;
        }
        return newStatus !== validationStatus ? {
          validationStatus: newStatus
        } : {};
      }
      case "validationErrors": {
        const validationError = !(null !== value2 && void 0 !== value2 && value2.length) ? null : value2[0];
        return options2.validationError !== validationError ? {
          validationError
        } : {};
      }
      case "validationError": {
        const {
          validationErrors
        } = options2;
        if (!value2 && validationErrors) {
          return {
            validationErrors: null
          };
        }
        if (value2 && !validationErrors) {
          return {
            validationErrors: [value2]
          };
        }
        if (value2 && validationErrors && value2 !== validationErrors[0]) {
          validationErrors[0] = value2;
          return {
            validationErrors: validationErrors.slice()
          };
        }
      }
    }
    return {};
  },
  validateGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.validate();
  },
  resetGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.reset();
  }
};
ValidationEngine.initGroups();
var m_validation_engine_default = ValidationEngine;

// node_modules/devextreme/esm/ui/validation_engine.js
var validation_engine_default = m_validation_engine_default;

// node_modules/devextreme/esm/core/dom_component.js
var dom_component_default2 = dom_component_default;

// node_modules/inferno/dist/index.esm.js
var isArray = Array.isArray;
function isStringOrNumber(o) {
  var type2 = typeof o;
  return type2 === "string" || type2 === "number";
}
function isNullOrUndef(o) {
  return o === void 0 || o === null;
}
function isInvalid(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction2(o) {
  return typeof o === "function";
}
function isString2(o) {
  return typeof o === "string";
}
function isNumber(o) {
  return typeof o === "number";
}
function isNull(o) {
  return o === null;
}
function isUndefined(o) {
  return o === void 0;
}
function combineFrom(first, second) {
  var out = {};
  if (first) {
    for (var key in first) {
      out[key] = first[key];
    }
  }
  if (second) {
    for (var _key in second) {
      out[_key] = second[_key];
    }
  }
  return out;
}
function isLinkEventObject(o) {
  return !isNull(o) && typeof o === "object";
}
var EMPTY_OBJ = {};
var Fragment = "$F";
var AnimationQueues = function AnimationQueues2() {
  this.componentDidAppear = [];
  this.componentWillDisappear = [];
  this.componentWillMove = [];
};
function normalizeEventName(name2) {
  return name2.substring(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
  parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
  if (isNull(nextNode)) {
    appendChild(parentDOM, newNode);
  } else {
    parentDOM.insertBefore(newNode, nextNode);
  }
}
function documentCreateElement(tag, isSVG) {
  if (isSVG) {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
  }
  return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
  parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
  parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
  for (var i = 0; i < arrayFn.length; i++) {
    arrayFn[i]();
  }
}
function findChildVNode(vNode, startEdge, flags) {
  var children = vNode.children;
  if (flags & 4) {
    return children.$LI;
  }
  if (flags & 8192) {
    return vNode.childFlags === 2 ? children : children[startEdge ? 0 : children.length - 1];
  }
  return children;
}
function findDOMFromVNode(vNode, startEdge) {
  var flags;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 1521) {
      return vNode.dom;
    }
    vNode = findChildVNode(vNode, startEdge, flags);
  }
  return null;
}
function callAllAnimationHooks(animationQueue, callback) {
  var animationsLeft = animationQueue.length;
  var fn;
  while ((fn = animationQueue.pop()) !== void 0) {
    fn(function() {
      if (--animationsLeft <= 0 && isFunction2(callback)) {
        callback();
      }
    });
  }
}
function callAllMoveAnimationHooks(animationQueue) {
  for (var i = 0; i < animationQueue.length; i++) {
    animationQueue[i].fn();
  }
  for (var _i = 0; _i < animationQueue.length; _i++) {
    var tmp = animationQueue[_i];
    insertOrAppend(tmp.parent, tmp.dom, tmp.next);
  }
  animationQueue.splice(0, animationQueue.length);
}
function clearVNodeDOM(vNode, parentDOM, deferredRemoval) {
  do {
    var flags = vNode.flags;
    if (flags & 1521) {
      if (!deferredRemoval || vNode.dom.parentNode === parentDOM) {
        removeChild(parentDOM, vNode.dom);
      }
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          clearVNodeDOM(children[i], parentDOM, false);
        }
        return;
      }
    }
  } while (vNode);
}
function createDeferComponentClassRemovalCallback(vNode, parentDOM) {
  return function() {
    clearVNodeDOM(vNode, parentDOM, true);
  };
}
function removeVNodeDOM(vNode, parentDOM, animations) {
  if (animations.componentWillDisappear.length > 0) {
    callAllAnimationHooks(animations.componentWillDisappear, createDeferComponentClassRemovalCallback(vNode, parentDOM));
  } else {
    clearVNodeDOM(vNode, parentDOM, false);
  }
}
function addMoveAnimationHook(animations, parentVNode, refOrInstance, dom, parentDOM, nextNode, flags, props) {
  animations.componentWillMove.push({
    dom,
    fn: function fn() {
      if (flags & 4) {
        refOrInstance.componentWillMove(parentVNode, parentDOM, dom);
      } else if (flags & 8) {
        refOrInstance.onComponentWillMove(parentVNode, parentDOM, dom, props);
      }
    },
    next: nextNode,
    parent: parentDOM
  });
}
function moveVNodeDOM(parentVNode, vNode, parentDOM, nextNode, animations) {
  var refOrInstance;
  var instanceProps;
  var instanceFlags = vNode.flags;
  do {
    var flags = vNode.flags;
    if (flags & 1521) {
      if (!isNullOrUndef(refOrInstance) && (isFunction2(refOrInstance.componentWillMove) || isFunction2(refOrInstance.onComponentWillMove))) {
        addMoveAnimationHook(animations, parentVNode, refOrInstance, vNode.dom, parentDOM, nextNode, instanceFlags, instanceProps);
      } else {
        insertOrAppend(parentDOM, vNode.dom, nextNode);
      }
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      refOrInstance = vNode.children;
      instanceProps = vNode.props;
      vNode = children.$LI;
    } else if (flags & 8) {
      refOrInstance = vNode.ref;
      instanceProps = vNode.props;
      vNode = children;
    } else if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          moveVNodeDOM(parentVNode, children[i], parentDOM, nextNode, animations);
        }
        return;
      }
    }
  } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
  if (instance.constructor.getDerivedStateFromProps) {
    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
  }
  return state;
}
var renderCheck = {
  v: false
};
var options = {
  componentComparator: null,
  createVNode: null,
  renderComplete: null
};
function setTextContent(dom, children) {
  dom.textContent = children;
}
function isLastValueSameLinkEvent(lastValue, nextValue) {
  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;
}
function mergeUnsetProperties(to, from) {
  for (var propName in from) {
    if (isUndefined(to[propName])) {
      to[propName] = from[propName];
    }
  }
  return to;
}
function safeCall1(method, arg1) {
  return !!isFunction2(method) && (method(arg1), true);
}
var keyPrefix = "$";
function V(childFlags, children, className, flags, key, props, ref, type2) {
  this.childFlags = childFlags;
  this.children = children;
  this.className = className;
  this.dom = null;
  this.flags = flags;
  this.key = key === void 0 ? null : key;
  this.props = props === void 0 ? null : props;
  this.ref = ref === void 0 ? null : ref;
  this.type = type2;
}
function createVNode(flags, type2, className, children, childFlags, props, key, ref) {
  var childFlag = childFlags === void 0 ? 1 : childFlags;
  var vNode = new V(childFlag, children, className, flags, key, props, ref, type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  if (childFlag === 0) {
    normalizeChildren(vNode, vNode.children);
  }
  return vNode;
}
function mergeDefaultHooks(flags, type2, ref) {
  if (flags & 4) {
    return ref;
  }
  var defaultHooks = (flags & 32768 ? type2.render : type2).defaultHooks;
  if (isNullOrUndef(defaultHooks)) {
    return ref;
  }
  if (isNullOrUndef(ref)) {
    return defaultHooks;
  }
  return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type2, props) {
  var defaultProps = (flags & 32768 ? type2.render : type2).defaultProps;
  if (isNullOrUndef(defaultProps)) {
    return props;
  }
  if (isNullOrUndef(props)) {
    return combineFrom(defaultProps, null);
  }
  return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type2) {
  if (flags & 12) {
    return flags;
  }
  if (type2.prototype && type2.prototype.render) {
    return 4;
  }
  if (type2.render) {
    return 32776;
  }
  return 8;
}
function createComponentVNode(flags, type2, props, key, ref) {
  flags = resolveComponentFlags(flags, type2);
  var vNode = new V(1, null, null, flags, key, mergeDefaultProps(flags, type2, props), mergeDefaultHooks(flags, type2, ref), type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  return vNode;
}
function createTextVNode(text, key) {
  return new V(1, isNullOrUndef(text) || text === true || text === false ? "" : text, null, 16, key, null, null, null);
}
function createFragment(children, childFlags, key) {
  var fragment = createVNode(8192, 8192, null, children, childFlags, null, key, null);
  switch (fragment.childFlags) {
    case 1:
      fragment.children = createVoidVNode();
      fragment.childFlags = 2;
      break;
    case 16:
      fragment.children = [createTextVNode(children)];
      fragment.childFlags = 4;
      break;
  }
  return fragment;
}
function normalizeProps(vNode) {
  var props = vNode.props;
  if (props) {
    var flags = vNode.flags;
    if (flags & 481) {
      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
        normalizeChildren(vNode, props.children);
      }
      if (props.className !== void 0) {
        if (isNullOrUndef(vNode.className)) {
          vNode.className = props.className || null;
        }
        props.className = void 0;
      }
    }
    if (props.key !== void 0) {
      vNode.key = props.key;
      props.key = void 0;
    }
    if (props.ref !== void 0) {
      if (flags & 8) {
        vNode.ref = combineFrom(vNode.ref, props.ref);
      } else {
        vNode.ref = props.ref;
      }
      props.ref = void 0;
    }
  }
  return vNode;
}
function cloneFragment(vNodeToClone) {
  var oldChildren = vNodeToClone.children;
  var childFlags = vNodeToClone.childFlags;
  return createFragment(childFlags === 2 ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
  var flags = vNodeToClone.flags & -16385;
  var props = vNodeToClone.props;
  if (flags & 14) {
    if (!isNull(props)) {
      var propsToClone = props;
      props = {};
      for (var key in propsToClone) {
        props[key] = propsToClone[key];
      }
    }
  }
  if ((flags & 8192) === 0) {
    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
  }
  return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
  return createTextVNode("", null);
}
function _normalizeVNodes(nodes, result2, index2, currentKey) {
  for (var len = nodes.length; index2 < len; index2++) {
    var n = nodes[index2];
    if (!isInvalid(n)) {
      var newKey = currentKey + keyPrefix + index2;
      if (isArray(n)) {
        _normalizeVNodes(n, result2, 0, newKey);
      } else {
        if (isStringOrNumber(n)) {
          n = createTextVNode(n, newKey);
        } else {
          var oldKey = n.key;
          var isPrefixedKey = isString2(oldKey) && oldKey[0] === keyPrefix;
          if (n.flags & 81920 || isPrefixedKey) {
            n = directClone(n);
          }
          n.flags |= 65536;
          if (!isPrefixedKey) {
            if (isNull(oldKey)) {
              n.key = newKey;
            } else {
              n.key = currentKey + oldKey;
            }
          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {
            n.key = currentKey + oldKey;
          }
        }
        result2.push(n);
      }
    }
  }
}
function getFlagsForElementVnode(type2) {
  switch (type2) {
    case "svg":
      return 32;
    case "input":
      return 64;
    case "select":
      return 256;
    case "textarea":
      return 128;
    // @ts-ignore
    case Fragment:
      return 8192;
    default:
      return 1;
  }
}
function normalizeChildren(vNode, children) {
  var newChildren;
  var newChildFlags = 1;
  if (isInvalid(children)) {
    newChildren = children;
  } else if (isStringOrNumber(children)) {
    newChildFlags = 16;
    newChildren = children;
  } else if (isArray(children)) {
    var len = children.length;
    for (var i = 0; i < len; ++i) {
      var n = children[i];
      if (isInvalid(n) || isArray(n)) {
        newChildren = newChildren || children.slice(0, i);
        _normalizeVNodes(children, newChildren, i, "");
        break;
      } else if (isStringOrNumber(n)) {
        newChildren = newChildren || children.slice(0, i);
        newChildren.push(createTextVNode(n, keyPrefix + i));
      } else {
        var key = n.key;
        var needsCloning = (n.flags & 81920) > 0;
        var isNullKey = isNull(key);
        var isPrefixed = isString2(key) && key[0] === keyPrefix;
        if (needsCloning || isNullKey || isPrefixed) {
          newChildren = newChildren || children.slice(0, i);
          if (needsCloning || isPrefixed) {
            n = directClone(n);
          }
          if (isNullKey || isPrefixed) {
            n.key = keyPrefix + i;
          }
          newChildren.push(n);
        } else if (newChildren) {
          newChildren.push(n);
        }
        n.flags |= 65536;
      }
    }
    newChildren = newChildren || children;
    if (newChildren.length === 0) {
      newChildFlags = 1;
    } else {
      newChildFlags = 8;
    }
  } else {
    newChildren = children;
    newChildren.flags |= 65536;
    if (children.flags & 81920) {
      newChildren = directClone(children);
    }
    newChildFlags = 2;
  }
  vNode.children = newChildren;
  vNode.childFlags = newChildFlags;
  return vNode;
}
function normalizeRoot(input) {
  if (isInvalid(input) || isStringOrNumber(input)) {
    return createTextVNode(input, null);
  }
  if (isArray(input)) {
    return createFragment(input, 0, null);
  }
  return input.flags & 16384 ? directClone(input) : input;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
var xmlNS = "http://www.w3.org/XML/1998/namespace";
var namespaces = {
  "xlink:actuate": xlinkNS,
  "xlink:arcrole": xlinkNS,
  "xlink:href": xlinkNS,
  "xlink:role": xlinkNS,
  "xlink:show": xlinkNS,
  "xlink:title": xlinkNS,
  "xlink:type": xlinkNS,
  "xml:base": xmlNS,
  "xml:lang": xmlNS,
  "xml:space": xmlNS
};
function getDelegatedEventObject(v) {
  return {
    onClick: v,
    onDblClick: v,
    onFocusIn: v,
    onFocusOut: v,
    onKeyDown: v,
    onKeyPress: v,
    onKeyUp: v,
    onMouseDown: v,
    onMouseMove: v,
    onMouseUp: v,
    onTouchEnd: v,
    onTouchMove: v,
    onTouchStart: v
  };
}
var attachedEventCounts = getDelegatedEventObject(0);
var attachedEvents = getDelegatedEventObject(null);
var syntheticEvents = getDelegatedEventObject(true);
function updateOrAddSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (!eventsObject) {
    eventsObject = dom.$EV = getDelegatedEventObject(null);
  }
  if (!eventsObject[name2]) {
    if (++attachedEventCounts[name2] === 1) {
      attachedEvents[name2] = attachEventToDocument(name2);
    }
  }
  return eventsObject;
}
function unmountSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (eventsObject && eventsObject[name2]) {
    if (--attachedEventCounts[name2] === 0) {
      document.removeEventListener(normalizeEventName(name2), attachedEvents[name2]);
      attachedEvents[name2] = null;
    }
    eventsObject[name2] = null;
  }
}
function handleSyntheticEvent(name2, lastEvent, nextEvent, dom) {
  if (isFunction2(nextEvent)) {
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else if (isLinkEventObject(nextEvent)) {
    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
      return;
    }
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else {
    unmountSyntheticEvent(name2, dom);
  }
}
function getTargetNode(event) {
  return isFunction2(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name2, eventData2) {
  var dom = getTargetNode(event);
  do {
    if (isClick && dom.disabled) {
      return;
    }
    var eventsObject = dom.$EV;
    if (eventsObject) {
      var currentEvent = eventsObject[name2];
      if (currentEvent) {
        eventData2.dom = dom;
        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
        if (event.cancelBubble) {
          return;
        }
      }
    }
    dom = dom.parentNode;
  } while (!isNull(dom));
}
function stopPropagation() {
  this.cancelBubble = true;
  if (!this.immediatePropagationStopped) {
    this.stopImmediatePropagation();
  }
}
function isDefaultPrevented() {
  return this.defaultPrevented;
}
function isPropagationStopped() {
  return this.cancelBubble;
}
function extendEventProperties(event) {
  var eventData2 = {
    dom: document
  };
  event.isDefaultPrevented = isDefaultPrevented;
  event.isPropagationStopped = isPropagationStopped;
  event.stopPropagation = stopPropagation;
  Object.defineProperty(event, "currentTarget", {
    configurable: true,
    get: function get() {
      return eventData2.dom;
    }
  });
  return eventData2;
}
function rootClickEvent(name2) {
  return function(event) {
    if (event.button !== 0) {
      event.stopPropagation();
      return;
    }
    dispatchEvents(event, true, name2, extendEventProperties(event));
  };
}
function rootEvent(name2) {
  return function(event) {
    dispatchEvents(event, false, name2, extendEventProperties(event));
  };
}
function attachEventToDocument(name2) {
  var attachedEvent = name2 === "onClick" || name2 === "onDblClick" ? rootClickEvent(name2) : rootEvent(name2);
  document.addEventListener(normalizeEventName(name2), attachedEvent);
  return attachedEvent;
}
function isSameInnerHTML(dom, innerHTML) {
  var tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function triggerEventListener(props, methodName, e) {
  if (props[methodName]) {
    var listener = props[methodName];
    if (listener.event) {
      listener.event(listener.data, e);
    } else {
      listener(e);
    }
  } else {
    var nativeListenerName = methodName.toLowerCase();
    if (props[nativeListenerName]) {
      props[nativeListenerName](e);
    }
  }
}
function createWrappedFunction(methodName, applyValue) {
  var fnMethod = function fnMethod2(e) {
    var vNode = this.$V;
    if (!vNode) {
      return;
    }
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    if (isString2(methodName)) {
      triggerEventListener(props, methodName, e);
    } else {
      for (var i = 0; i < methodName.length; ++i) {
        triggerEventListener(props, methodName[i], e);
      }
    }
    if (isFunction2(applyValue)) {
      var newVNode = this.$V;
      var newProps = newVNode.props || EMPTY_OBJ;
      applyValue(newProps, dom, false, newVNode);
    }
  };
  Object.defineProperty(fnMethod, "wrapped", {
    configurable: false,
    enumerable: false,
    value: true,
    writable: false
  });
  return fnMethod;
}
function attachEvent(dom, eventName, handler) {
  var previousKey = "$" + eventName;
  var previousArgs = dom[previousKey];
  if (previousArgs) {
    if (previousArgs[1].wrapped) {
      return;
    }
    dom.removeEventListener(previousArgs[0], previousArgs[1]);
    dom[previousKey] = null;
  }
  if (isFunction2(handler)) {
    dom.addEventListener(eventName, handler);
    dom[previousKey] = [eventName, handler];
  }
}
function isCheckedType(type2) {
  return type2 === "checkbox" || type2 === "radio";
}
var onTextInputChange = createWrappedFunction("onInput", applyValueInput);
var wrappedOnChange$1 = createWrappedFunction(["onClick", "onChange"], applyValueInput);
function emptywrapper(event) {
  event.stopPropagation();
}
emptywrapper.wrapped = true;
function inputEvents(dom, nextPropsOrEmpty) {
  if (isCheckedType(nextPropsOrEmpty.type)) {
    attachEvent(dom, "change", wrappedOnChange$1);
    attachEvent(dom, "click", emptywrapper);
  } else {
    attachEvent(dom, "input", onTextInputChange);
  }
}
function applyValueInput(nextPropsOrEmpty, dom) {
  var type2 = nextPropsOrEmpty.type;
  var value2 = nextPropsOrEmpty.value;
  var checked = nextPropsOrEmpty.checked;
  var multiple = nextPropsOrEmpty.multiple;
  var defaultValue = nextPropsOrEmpty.defaultValue;
  var hasValue = !isNullOrUndef(value2);
  if (type2 && type2 !== dom.type) {
    dom.setAttribute("type", type2);
  }
  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
    dom.multiple = multiple;
  }
  if (!isNullOrUndef(defaultValue) && !hasValue) {
    dom.defaultValue = defaultValue + "";
  }
  if (isCheckedType(type2)) {
    if (hasValue) {
      dom.value = value2;
    }
    if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  } else {
    if (hasValue && dom.value !== value2) {
      dom.defaultValue = value2;
      dom.value = value2;
    } else if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  }
}
function updateChildOptions(vNode, value2) {
  if (vNode.type === "option") {
    updateChildOption(vNode, value2);
  } else {
    var children = vNode.children;
    var flags = vNode.flags;
    if (flags & 4) {
      updateChildOptions(children.$LI, value2);
    } else if (flags & 8) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags === 2) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags & 12) {
      for (var i = 0, len = children.length; i < len; ++i) {
        updateChildOptions(children[i], value2);
      }
    }
  }
}
function updateChildOption(vNode, value2) {
  var props = vNode.props || EMPTY_OBJ;
  var dom = vNode.dom;
  dom.value = props.value;
  if (props.value === value2 || isArray(value2) && value2.indexOf(props.value) !== -1) {
    dom.selected = true;
  } else if (!isNullOrUndef(value2) || !isNullOrUndef(props.selected)) {
    dom.selected = props.selected || false;
  }
}
var onSelectChange = createWrappedFunction("onChange", applyValueSelect);
function selectEvents(dom) {
  attachEvent(dom, "change", onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
    dom.multiple = multiplePropInBoolean;
  }
  var index2 = nextPropsOrEmpty.selectedIndex;
  if (index2 === -1) {
    dom.selectedIndex = -1;
  }
  var childFlags = vNode.childFlags;
  if (childFlags !== 1) {
    var value2 = nextPropsOrEmpty.value;
    if (isNumber(index2) && index2 > -1 && dom.options[index2]) {
      value2 = dom.options[index2].value;
    }
    if (mounting && isNullOrUndef(value2)) {
      value2 = nextPropsOrEmpty.defaultValue;
    }
    updateChildOptions(vNode, value2);
  }
}
var onTextareaInputChange = createWrappedFunction("onInput", applyValueTextArea);
var wrappedOnChange = createWrappedFunction("onChange");
function textAreaEvents(dom, nextPropsOrEmpty) {
  attachEvent(dom, "input", onTextareaInputChange);
  if (nextPropsOrEmpty.onChange) {
    attachEvent(dom, "change", wrappedOnChange);
  }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
  var value2 = nextPropsOrEmpty.value;
  var domValue = dom.value;
  if (isNullOrUndef(value2)) {
    if (mounting) {
      var defaultValue = nextPropsOrEmpty.defaultValue;
      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
        dom.defaultValue = defaultValue;
        dom.value = defaultValue;
      }
    }
  } else if (domValue !== value2) {
    dom.defaultValue = value2;
    dom.value = value2;
  }
}
function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
  if (flags & 64) {
    applyValueInput(nextPropsOrEmpty, dom);
  } else if (flags & 256) {
    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
  } else if (flags & 128) {
    applyValueTextArea(nextPropsOrEmpty, dom, mounting);
  }
  if (isControlled) {
    dom.$V = vNode;
  }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
  if (flags & 64) {
    inputEvents(dom, nextPropsOrEmpty);
  } else if (flags & 256) {
    selectEvents(dom);
  } else if (flags & 128) {
    textAreaEvents(dom, nextPropsOrEmpty);
  }
}
function isControlledFormElement(nextPropsOrEmpty) {
  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}
function createRef() {
  return {
    current: null
  };
}
function unmountRef(ref) {
  if (ref) {
    if (!safeCall1(ref, null) && ref.current) {
      ref.current = null;
    }
  }
}
function mountRef(ref, value2, lifecycle) {
  if (ref && (isFunction2(ref) || ref.current !== void 0)) {
    lifecycle.push(function() {
      if (!safeCall1(ref, value2) && ref.current !== void 0) {
        ref.current = value2;
      }
    });
  }
}
function remove2(vNode, parentDOM, animations) {
  unmount(vNode, animations);
  removeVNodeDOM(vNode, parentDOM, animations);
}
function unmount(vNode, animations) {
  var flags = vNode.flags;
  var children = vNode.children;
  var ref;
  if (flags & 481) {
    ref = vNode.ref;
    var props = vNode.props;
    unmountRef(ref);
    var childFlags = vNode.childFlags;
    if (!isNull(props)) {
      var keys = Object.keys(props);
      for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        if (syntheticEvents[key]) {
          unmountSyntheticEvent(key, vNode.dom);
        }
      }
    }
    if (childFlags & 12) {
      unmountAllChildren(children, animations);
    } else if (childFlags === 2) {
      unmount(children, animations);
    }
  } else if (children) {
    if (flags & 4) {
      if (isFunction2(children.componentWillUnmount)) {
        children.componentWillUnmount();
      }
      var childAnimations = animations;
      if (isFunction2(children.componentWillDisappear)) {
        childAnimations = new AnimationQueues();
        addDisappearAnimationHook(animations, children, children.$LI.dom, flags, void 0);
      }
      unmountRef(vNode.ref);
      children.$UN = true;
      unmount(children.$LI, childAnimations);
    } else if (flags & 8) {
      var _childAnimations = animations;
      ref = vNode.ref;
      if (!isNullOrUndef(ref)) {
        var domEl = null;
        if (isFunction2(ref.onComponentWillUnmount)) {
          domEl = findDOMFromVNode(vNode, true);
          ref.onComponentWillUnmount(domEl, vNode.props || EMPTY_OBJ);
        }
        if (isFunction2(ref.onComponentWillDisappear)) {
          _childAnimations = new AnimationQueues();
          domEl = domEl || findDOMFromVNode(vNode, true);
          addDisappearAnimationHook(animations, ref, domEl, flags, vNode.props);
        }
      }
      unmount(children, _childAnimations);
    } else if (flags & 1024) {
      remove2(children, vNode.ref, animations);
    } else if (flags & 8192) {
      if (vNode.childFlags & 12) {
        unmountAllChildren(children, animations);
      }
    }
  }
}
function unmountAllChildren(children, animations) {
  for (var i = 0, len = children.length; i < len; ++i) {
    unmount(children[i], animations);
  }
}
function createClearAllCallback(children, parentDOM) {
  return function() {
    if (parentDOM) {
      for (var i = 0; i < children.length; i++) {
        var vNode = children[i];
        clearVNodeDOM(vNode, parentDOM, false);
      }
    }
  };
}
function clearDOM(parentDOM, children, animations) {
  if (animations.componentWillDisappear.length > 0) {
    callAllAnimationHooks(animations.componentWillDisappear, createClearAllCallback(children, parentDOM));
  } else {
    parentDOM.textContent = "";
  }
}
function removeAllChildren(dom, vNode, children, animations) {
  unmountAllChildren(children, animations);
  if (vNode.flags & 8192) {
    removeVNodeDOM(vNode, dom, animations);
  } else {
    clearDOM(dom, children, animations);
  }
}
function addDisappearAnimationHook(animations, instanceOrRef, dom, flags, props) {
  animations.componentWillDisappear.push(function(callback) {
    if (flags & 4) {
      instanceOrRef.componentWillDisappear(dom, callback);
    } else if (flags & 8) {
      instanceOrRef.onComponentWillDisappear(dom, props, callback);
    }
  });
}
function wrapLinkEvent(nextValue) {
  var ev = nextValue.event;
  return function(e) {
    ev(nextValue.data, e);
  };
}
function patchEvent(name2, lastValue, nextValue, dom) {
  if (isLinkEventObject(nextValue)) {
    if (isLastValueSameLinkEvent(lastValue, nextValue)) {
      return;
    }
    nextValue = wrapLinkEvent(nextValue);
  }
  attachEvent(dom, normalizeEventName(name2), nextValue);
}
function patchStyle(lastAttrValue, nextAttrValue, dom) {
  if (isNullOrUndef(nextAttrValue)) {
    dom.removeAttribute("style");
    return;
  }
  var domStyle = dom.style;
  var style;
  var value2;
  if (isString2(nextAttrValue)) {
    domStyle.cssText = nextAttrValue;
    return;
  }
  if (!isNullOrUndef(lastAttrValue) && !isString2(lastAttrValue)) {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      if (value2 !== lastAttrValue[style]) {
        domStyle.setProperty(style, value2);
      }
    }
    for (style in lastAttrValue) {
      if (isNullOrUndef(nextAttrValue[style])) {
        domStyle.removeProperty(style);
      }
    }
  } else {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      domStyle.setProperty(style, value2);
    }
  }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom, animations) {
  var lastHtml = lastValue && lastValue.__html || "";
  var nextHtml = nextValue && nextValue.__html || "";
  if (lastHtml !== nextHtml) {
    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
      if (!isNull(lastVNode)) {
        if (lastVNode.childFlags & 12) {
          unmountAllChildren(lastVNode.children, animations);
        } else if (lastVNode.childFlags === 2) {
          unmount(lastVNode.children, animations);
        }
        lastVNode.children = null;
        lastVNode.childFlags = 1;
      }
      dom.innerHTML = nextHtml;
    }
  }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode, animations) {
  switch (prop) {
    case "children":
    case "childrenType":
    case "className":
    case "defaultValue":
    case "key":
    case "multiple":
    case "ref":
    case "selectedIndex":
      break;
    case "autoFocus":
      dom.autofocus = !!nextValue;
      break;
    case "allowfullscreen":
    case "autoplay":
    case "capture":
    case "checked":
    case "controls":
    case "default":
    case "disabled":
    case "hidden":
    case "indeterminate":
    case "loop":
    case "muted":
    case "novalidate":
    case "open":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "selected":
      dom[prop] = !!nextValue;
      break;
    case "defaultChecked":
    case "value":
    case "volume":
      if (hasControlledValue && prop === "value") {
        break;
      }
      var value2 = isNullOrUndef(nextValue) ? "" : nextValue;
      if (dom[prop] !== value2) {
        dom[prop] = value2;
      }
      break;
    case "style":
      patchStyle(lastValue, nextValue, dom);
      break;
    case "dangerouslySetInnerHTML":
      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom, animations);
      break;
    default:
      if (syntheticEvents[prop]) {
        handleSyntheticEvent(prop, lastValue, nextValue, dom);
      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
        patchEvent(prop, lastValue, nextValue, dom);
      } else if (isNullOrUndef(nextValue)) {
        dom.removeAttribute(prop);
      } else if (isSVG && namespaces[prop]) {
        dom.setAttributeNS(namespaces[prop], prop, nextValue);
      } else {
        dom.setAttribute(prop, nextValue);
      }
      break;
  }
}
function mountProps(vNode, flags, props, dom, isSVG, animations) {
  var hasControlledValue = false;
  var isFormElement = (flags & 448) > 0;
  if (isFormElement) {
    hasControlledValue = isControlledFormElement(props);
    if (hasControlledValue) {
      addFormElementEventHandlers(flags, dom, props);
    }
  }
  for (var prop in props) {
    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null, animations);
  }
  if (isFormElement) {
    processElement(flags, vNode, dom, props, true, hasControlledValue);
  }
}
function renderNewInput(instance, props, context2) {
  var nextInput = normalizeRoot(instance.render(props, instance.state, context2));
  var childContext = context2;
  if (isFunction2(instance.getChildContext)) {
    childContext = combineFrom(context2, instance.getChildContext());
  }
  instance.$CX = childContext;
  return nextInput;
}
function createClassComponentInstance(vNode, Component4, props, context2, isSVG, lifecycle) {
  var instance = new Component4(props, context2);
  var usesNewAPI = instance.$N = Boolean(Component4.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);
  instance.$SVG = isSVG;
  instance.$L = lifecycle;
  vNode.children = instance;
  instance.$BS = false;
  instance.context = context2;
  if (instance.props === EMPTY_OBJ) {
    instance.props = props;
  }
  if (!usesNewAPI) {
    if (isFunction2(instance.componentWillMount)) {
      instance.$BR = true;
      instance.componentWillMount();
      var pending = instance.$PS;
      if (!isNull(pending)) {
        var state = instance.state;
        if (isNull(state)) {
          instance.state = pending;
        } else {
          for (var key in pending) {
            state[key] = pending[key];
          }
        }
        instance.$PS = null;
      }
      instance.$BR = false;
    }
  } else {
    instance.state = createDerivedState(instance, props, instance.state);
  }
  instance.$LI = renderNewInput(instance, props, context2);
  return instance;
}
function renderFunctionalComponent(vNode, context2) {
  var props = vNode.props || EMPTY_OBJ;
  return vNode.flags & 32768 ? vNode.type.render(props, vNode.ref, context2) : vNode.type(props, context2);
}
function mount(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var flags = vNode.flags |= 16384;
  if (flags & 481) {
    mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (flags & 4) {
    mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (flags & 8) {
    mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (flags & 16) {
    mountText(vNode, parentDOM, nextNode);
  } else if (flags & 8192) {
    mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle, animations);
  } else if (flags & 1024) {
    mountPortal(vNode, context2, parentDOM, nextNode, lifecycle, animations);
  } else ;
}
function mountPortal(vNode, context2, parentDOM, nextNode, lifecycle, animations) {
  mount(vNode.children, vNode.ref, context2, false, null, lifecycle, animations);
  var placeHolderVNode = createVoidVNode();
  mountText(placeHolderVNode, parentDOM, nextNode);
  vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle, animations) {
  var children = vNode.children;
  var childFlags = vNode.childFlags;
  if (childFlags & 12 && children.length === 0) {
    childFlags = vNode.childFlags = 2;
    children = vNode.children = createVoidVNode();
  }
  if (childFlags === 2) {
    mount(children, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else {
    mountArrayChildren(children, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  }
}
function mountText(vNode, parentDOM, nextNode) {
  var dom = vNode.dom = document.createTextNode(vNode.children);
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
}
function mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var flags = vNode.flags;
  var props = vNode.props;
  var className = vNode.className;
  var childFlags = vNode.childFlags;
  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32) > 0);
  var children = vNode.children;
  if (!isNullOrUndef(className) && className !== "") {
    if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
  }
  if (childFlags === 16) {
    setTextContent(dom, children);
  } else if (childFlags !== 1) {
    var childrenIsSVG = isSVG && vNode.type !== "foreignObject";
    if (childFlags === 2) {
      if (children.flags & 16384) {
        vNode.children = children = directClone(children);
      }
      mount(children, dom, context2, childrenIsSVG, null, lifecycle, animations);
    } else if (childFlags === 8 || childFlags === 4) {
      mountArrayChildren(children, dom, context2, childrenIsSVG, null, lifecycle, animations);
    }
  }
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
  if (!isNull(props)) {
    mountProps(vNode, flags, props, dom, isSVG, animations);
  }
  mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context2, isSVG, nextNode, lifecycle, animations) {
  for (var i = 0; i < children.length; ++i) {
    var child = children[i];
    if (child.flags & 16384) {
      children[i] = child = directClone(child);
    }
    mount(child, dom, context2, isSVG, nextNode, lifecycle, animations);
  }
}
function mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context2, isSVG, lifecycle);
  var childAnimations = animations;
  if (isFunction2(instance.componentDidAppear)) {
    childAnimations = new AnimationQueues();
  }
  mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle, childAnimations);
  mountClassComponentCallbacks(vNode.ref, instance, lifecycle, animations);
}
function mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var ref = vNode.ref;
  var childAnimations = animations;
  if (!isNullOrUndef(ref) && isFunction2(ref.onComponentDidAppear)) {
    childAnimations = new AnimationQueues();
  }
  mount(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context2)), parentDOM, context2, isSVG, nextNode, lifecycle, childAnimations);
  mountFunctionalComponentCallbacks(vNode, lifecycle, animations);
}
function createClassMountCallback(instance) {
  return function() {
    instance.componentDidMount();
  };
}
function addAppearAnimationHook(animations, instanceOrRef, dom, flags, props) {
  animations.componentDidAppear.push(function() {
    if (flags & 4) {
      instanceOrRef.componentDidAppear(dom);
    } else if (flags & 8) {
      instanceOrRef.onComponentDidAppear(dom, props);
    }
  });
}
function mountClassComponentCallbacks(ref, instance, lifecycle, animations) {
  mountRef(ref, instance, lifecycle);
  if (isFunction2(instance.componentDidMount)) {
    lifecycle.push(createClassMountCallback(instance));
  }
  if (isFunction2(instance.componentDidAppear)) {
    addAppearAnimationHook(animations, instance, instance.$LI.dom, 4, void 0);
  }
}
function createOnMountCallback(ref, vNode) {
  return function() {
    ref.onComponentDidMount(findDOMFromVNode(vNode, true), vNode.props || EMPTY_OBJ);
  };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle, animations) {
  var ref = vNode.ref;
  if (!isNullOrUndef(ref)) {
    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);
    if (isFunction2(ref.onComponentDidMount)) {
      lifecycle.push(createOnMountCallback(ref, vNode));
    }
    if (isFunction2(ref.onComponentDidAppear)) {
      addAppearAnimationHook(animations, ref, findDOMFromVNode(vNode, true), 8, vNode.props);
    }
  }
}
function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle, animations) {
  unmount(lastVNode, animations);
  if ((nextVNode.flags & lastVNode.flags & 1521) !== 0) {
    mount(nextVNode, null, context2, isSVG, null, lifecycle, animations);
    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
  } else {
    mount(nextVNode, parentDOM, context2, isSVG, findDOMFromVNode(lastVNode, true), lifecycle, animations);
    removeVNodeDOM(lastVNode, parentDOM, animations);
  }
}
function patch(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var nextFlags = nextVNode.flags |= 16384;
  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048) {
    if (lastVNode.flags & 16384) {
      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle, animations);
    } else {
      mount(nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
    }
  } else if (nextFlags & 481) {
    patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle, animations);
  } else if (nextFlags & 4) {
    patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (nextFlags & 8) {
    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (nextFlags & 16) {
    patchText(lastVNode, nextVNode);
  } else if (nextFlags & 8192) {
    patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle, animations);
  } else {
    patchPortal(lastVNode, nextVNode, context2, lifecycle, animations);
  }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
  if (lastChildren !== nextChildren) {
    if (lastChildren !== "") {
      parentDOM.firstChild.nodeValue = nextChildren;
    } else {
      setTextContent(parentDOM, nextChildren);
    }
  }
}
function patchContentEditableChildren(dom, nextChildren) {
  if (dom.textContent !== nextChildren) {
    dom.textContent = nextChildren;
  }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle, animations) {
  var lastChildren = lastVNode.children;
  var nextChildren = nextVNode.children;
  var lastChildFlags = lastVNode.childFlags;
  var nextChildFlags = nextVNode.childFlags;
  var nextNode = null;
  if (nextChildFlags & 12 && nextChildren.length === 0) {
    nextChildFlags = nextVNode.childFlags = 2;
    nextChildren = nextVNode.children = createVoidVNode();
  }
  var nextIsSingle = (nextChildFlags & 2) !== 0;
  if (lastChildFlags & 12) {
    var lastLen = lastChildren.length;
    if (
      // It uses keyed algorithm
      lastChildFlags & 8 && nextChildFlags & 8 || // It transforms from many to single
      nextIsSingle || // It will append more nodes
      !nextIsSingle && nextChildren.length > lastLen
    ) {
      nextNode = findDOMFromVNode(lastChildren[lastLen - 1], false).nextSibling;
    }
  }
  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lastVNode, lifecycle, animations);
}
function patchPortal(lastVNode, nextVNode, context2, lifecycle, animations) {
  var lastContainer = lastVNode.ref;
  var nextContainer = nextVNode.ref;
  var nextChildren = nextVNode.children;
  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context2, false, null, lastVNode, lifecycle, animations);
  nextVNode.dom = lastVNode.dom;
  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
    var node = nextChildren.dom;
    removeChild(lastContainer, node);
    appendChild(nextContainer, node);
  }
}
function patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle, animations) {
  var dom = nextVNode.dom = lastVNode.dom;
  var lastProps = lastVNode.props;
  var nextProps = nextVNode.props;
  var isFormElement = false;
  var hasControlledValue = false;
  var nextPropsOrEmpty;
  isSVG = isSVG || (nextFlags & 32) > 0;
  if (lastProps !== nextProps) {
    var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
    nextPropsOrEmpty = nextProps || EMPTY_OBJ;
    if (nextPropsOrEmpty !== EMPTY_OBJ) {
      isFormElement = (nextFlags & 448) > 0;
      if (isFormElement) {
        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
      }
      for (var prop in nextPropsOrEmpty) {
        var lastValue = lastPropsOrEmpty[prop];
        var nextValue = nextPropsOrEmpty[prop];
        if (lastValue !== nextValue) {
          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode, animations);
        }
      }
    }
    if (lastPropsOrEmpty !== EMPTY_OBJ) {
      for (var _prop in lastPropsOrEmpty) {
        if (isNullOrUndef(nextPropsOrEmpty[_prop]) && !isNullOrUndef(lastPropsOrEmpty[_prop])) {
          patchProp(_prop, lastPropsOrEmpty[_prop], null, dom, isSVG, hasControlledValue, lastVNode, animations);
        }
      }
    }
  }
  var nextChildren = nextVNode.children;
  var nextClassName = nextVNode.className;
  if (lastVNode.className !== nextClassName) {
    if (isNullOrUndef(nextClassName)) {
      dom.removeAttribute("class");
    } else if (isSVG) {
      dom.setAttribute("class", nextClassName);
    } else {
      dom.className = nextClassName;
    }
  }
  if (nextFlags & 4096) {
    patchContentEditableChildren(dom, nextChildren);
  } else {
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context2, isSVG && nextVNode.type !== "foreignObject", null, lastVNode, lifecycle, animations);
  }
  if (isFormElement) {
    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
  }
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, dom, lifecycle);
  }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle, animations) {
  unmount(lastChildren, animations);
  mountArrayChildren(nextChildren, parentDOM, context2, isSVG, findDOMFromVNode(lastChildren, true), lifecycle, animations);
  removeVNodeDOM(lastChildren, parentDOM, animations);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, parentVNode, lifecycle, animations) {
  switch (lastChildFlags) {
    case 2:
      switch (nextChildFlags) {
        case 2:
          patch(lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
        case 1:
          remove2(lastChildren, parentDOM, animations);
          break;
        case 16:
          unmount(lastChildren, animations);
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle, animations);
          break;
      }
      break;
    case 1:
      switch (nextChildFlags) {
        case 2:
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
        case 1:
          break;
        case 16:
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
      }
      break;
    case 16:
      switch (nextChildFlags) {
        case 16:
          patchSingleTextChild(lastChildren, nextChildren, parentDOM);
          break;
        case 2:
          clearDOM(parentDOM, lastChildren, animations);
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
        case 1:
          clearDOM(parentDOM, lastChildren, animations);
          break;
        default:
          clearDOM(parentDOM, lastChildren, animations);
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
      }
      break;
    default:
      switch (nextChildFlags) {
        case 16:
          unmountAllChildren(lastChildren, animations);
          setTextContent(parentDOM, nextChildren);
          break;
        case 2:
          removeAllChildren(parentDOM, parentVNode, lastChildren, animations);
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
        case 1:
          removeAllChildren(parentDOM, parentVNode, lastChildren, animations);
          break;
        default:
          var lastLength = lastChildren.length | 0;
          var nextLength = nextChildren.length | 0;
          if (lastLength === 0) {
            if (nextLength > 0) {
              mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
            }
          } else if (nextLength === 0) {
            removeAllChildren(parentDOM, parentVNode, lastChildren, animations);
          } else if (nextChildFlags === 8 && lastChildFlags === 8) {
            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle, animations);
          } else {
            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, lifecycle, animations);
          }
          break;
      }
      break;
  }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
  lifecycle.push(function() {
    instance.componentDidUpdate(lastProps, lastState, snapshot);
  });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, force, nextNode, lifecycle, animations) {
  var lastState = instance.state;
  var lastProps = instance.props;
  var usesNewAPI = Boolean(instance.$N);
  var hasSCU = isFunction2(instance.shouldComponentUpdate);
  if (usesNewAPI) {
    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);
  }
  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context2)) {
    if (!usesNewAPI && isFunction2(instance.componentWillUpdate)) {
      instance.componentWillUpdate(nextProps, nextState, context2);
    }
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
    var snapshot = null;
    var nextInput = renderNewInput(instance, nextProps, context2);
    if (usesNewAPI && isFunction2(instance.getSnapshotBeforeUpdate)) {
      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
    }
    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle, animations);
    instance.$LI = nextInput;
    if (isFunction2(instance.componentDidUpdate)) {
      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
    }
  } else {
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
  }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var instance = nextVNode.children = lastVNode.children;
  if (isNull(instance)) {
    return;
  }
  instance.$L = lifecycle;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  var nextState = instance.state;
  if (!instance.$N) {
    if (isFunction2(instance.componentWillReceiveProps)) {
      instance.$BR = true;
      instance.componentWillReceiveProps(nextProps, context2);
      if (instance.$UN) {
        return;
      }
      instance.$BR = false;
    }
    if (!isNull(instance.$PS)) {
      nextState = combineFrom(nextState, instance.$PS);
      instance.$PS = null;
    }
  }
  updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, false, nextNode, lifecycle, animations);
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, instance, lifecycle);
  }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var shouldUpdate = true;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastProps = lastVNode.props;
  var nextHooksDefined = !isNullOrUndef(nextRef);
  var lastInput = lastVNode.children;
  if (nextHooksDefined && isFunction2(nextRef.onComponentShouldUpdate)) {
    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
  }
  if (shouldUpdate !== false) {
    if (nextHooksDefined && isFunction2(nextRef.onComponentWillUpdate)) {
      nextRef.onComponentWillUpdate(lastProps, nextProps);
    }
    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context2));
    patch(lastInput, nextInput, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
    nextVNode.children = nextInput;
    if (nextHooksDefined && isFunction2(nextRef.onComponentDidUpdate)) {
      nextRef.onComponentDidUpdate(lastProps, nextProps);
    }
  } else {
    nextVNode.children = lastInput;
  }
}
function patchText(lastVNode, nextVNode) {
  var nextText = nextVNode.children;
  var dom = nextVNode.dom = lastVNode.dom;
  if (nextText !== lastVNode.children) {
    dom.nodeValue = nextText;
  }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context2, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle, animations) {
  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
  var i = 0;
  var nextChild;
  var lastChild;
  for (; i < commonLength; ++i) {
    nextChild = nextChildren[i];
    lastChild = lastChildren[i];
    if (nextChild.flags & 16384) {
      nextChild = nextChildren[i] = directClone(nextChild);
    }
    patch(lastChild, nextChild, dom, context2, isSVG, nextNode, lifecycle, animations);
    lastChildren[i] = nextChild;
  }
  if (lastChildrenLength < nextChildrenLength) {
    for (i = commonLength; i < nextChildrenLength; ++i) {
      nextChild = nextChildren[i];
      if (nextChild.flags & 16384) {
        nextChild = nextChildren[i] = directClone(nextChild);
      }
      mount(nextChild, dom, context2, isSVG, nextNode, lifecycle, animations);
    }
  } else if (lastChildrenLength > nextChildrenLength) {
    for (i = commonLength; i < lastChildrenLength; ++i) {
      remove2(lastChildren[i], dom, animations);
    }
  }
}
function patchKeyedChildren(a, b, dom, context2, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle, animations) {
  var aEnd = aLength - 1;
  var bEnd = bLength - 1;
  var j = 0;
  var aNode = a[j];
  var bNode = b[j];
  var nextPos;
  var nextNode;
  outer: {
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[j] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle, animations);
      a[j] = bNode;
      ++j;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[j];
      bNode = b[j];
    }
    aNode = a[aEnd];
    bNode = b[bEnd];
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[bEnd] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle, animations);
      a[aEnd] = bNode;
      aEnd--;
      bEnd--;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[aEnd];
      bNode = b[bEnd];
    }
  }
  if (j > aEnd) {
    if (j <= bEnd) {
      nextPos = bEnd + 1;
      nextNode = nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge;
      while (j <= bEnd) {
        bNode = b[j];
        if (bNode.flags & 16384) {
          b[j] = bNode = directClone(bNode);
        }
        ++j;
        mount(bNode, dom, context2, isSVG, nextNode, lifecycle, animations);
      }
    }
  } else if (j > bEnd) {
    while (j <= aEnd) {
      remove2(a[j++], dom, animations);
    }
  } else {
    patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle, animations);
  }
}
function patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle, animations) {
  var aNode;
  var bNode;
  var nextPos = 0;
  var i = 0;
  var aStart = j;
  var bStart = j;
  var aLeft = aEnd - j + 1;
  var bLeft = bEnd - j + 1;
  var sources = new Int32Array(bLeft + 1);
  var canRemoveWholeContent = aLeft === aLength;
  var moved = false;
  var pos = 0;
  var patched = 0;
  if (bLength < 4 || (aLeft | bLeft) < 32) {
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        for (j = bStart; j <= bEnd; j++) {
          bNode = b[j];
          if (aNode.key === bNode.key) {
            sources[j - bStart] = i + 1;
            if (canRemoveWholeContent) {
              canRemoveWholeContent = false;
              while (aStart < i) {
                remove2(a[aStart++], dom, animations);
              }
            }
            if (pos > j) {
              moved = true;
            } else {
              pos = j;
            }
            if (bNode.flags & 16384) {
              b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle, animations);
            ++patched;
            break;
          }
        }
        if (!canRemoveWholeContent && j > bEnd) {
          remove2(aNode, dom, animations);
        }
      } else if (!canRemoveWholeContent) {
        remove2(aNode, dom, animations);
      }
    }
  } else {
    var keyIndex = {};
    for (i = bStart; i <= bEnd; ++i) {
      keyIndex[b[i].key] = i;
    }
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        j = keyIndex[aNode.key];
        if (j !== void 0) {
          if (canRemoveWholeContent) {
            canRemoveWholeContent = false;
            while (i > aStart) {
              remove2(a[aStart++], dom, animations);
            }
          }
          sources[j - bStart] = i + 1;
          if (pos > j) {
            moved = true;
          } else {
            pos = j;
          }
          bNode = b[j];
          if (bNode.flags & 16384) {
            b[j] = bNode = directClone(bNode);
          }
          patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle, animations);
          ++patched;
        } else if (!canRemoveWholeContent) {
          remove2(aNode, dom, animations);
        }
      } else if (!canRemoveWholeContent) {
        remove2(aNode, dom, animations);
      }
    }
  }
  if (canRemoveWholeContent) {
    removeAllChildren(dom, parentVNode, a, animations);
    mountArrayChildren(b, dom, context2, isSVG, outerEdge, lifecycle, animations);
  } else if (moved) {
    var seq = lis_algorithm(sources);
    j = seq.length - 1;
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge, lifecycle, animations);
      } else if (j < 0 || i !== seq[j]) {
        pos = i + bStart;
        bNode = b[pos];
        nextPos = pos + 1;
        moveVNodeDOM(parentVNode, bNode, dom, nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge, animations);
      } else {
        j--;
      }
    }
    if (animations.componentWillMove.length > 0) {
      callAllMoveAnimationHooks(animations.componentWillMove);
    }
  } else if (patched !== bLeft) {
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge, lifecycle, animations);
      }
    }
  }
}
var result;
var p;
var maxLen = 0;
function lis_algorithm(arr) {
  var arrI = 0;
  var i = 0;
  var j = 0;
  var k = 0;
  var u = 0;
  var v = 0;
  var c = 0;
  var len = arr.length;
  if (len > maxLen) {
    maxLen = len;
    result = new Int32Array(len);
    p = new Int32Array(len);
  }
  for (; i < len; ++i) {
    arrI = arr[i];
    if (arrI !== 0) {
      j = result[k];
      if (arr[j] < arrI) {
        p[i] = j;
        result[++k] = i;
        continue;
      }
      u = 0;
      v = k;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = k + 1;
  var seq = new Int32Array(u);
  v = result[u - 1];
  while (u-- > 0) {
    seq[u] = v;
    v = p[v];
    result[u] = 0;
  }
  return seq;
}
var hasDocumentAvailable = typeof document !== "undefined";
if (hasDocumentAvailable) {
  if (window.Node) {
    Node.prototype.$EV = null;
    Node.prototype.$V = null;
  }
}
function __render(input, parentDOM, callback, context2) {
  var lifecycle = [];
  var animations = new AnimationQueues();
  var rootInput = parentDOM.$V;
  renderCheck.v = true;
  if (isNullOrUndef(rootInput)) {
    if (!isNullOrUndef(input)) {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      mount(input, parentDOM, context2, false, null, lifecycle, animations);
      parentDOM.$V = input;
      rootInput = input;
    }
  } else {
    if (isNullOrUndef(input)) {
      remove2(rootInput, parentDOM, animations);
      parentDOM.$V = null;
    } else {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      patch(rootInput, input, parentDOM, context2, false, null, lifecycle, animations);
      rootInput = parentDOM.$V = input;
    }
  }
  callAll(lifecycle);
  callAllAnimationHooks(animations.componentDidAppear);
  renderCheck.v = false;
  if (isFunction2(callback)) {
    callback();
  }
  if (isFunction2(options.renderComplete)) {
    options.renderComplete(rootInput, parentDOM);
  }
}
function render(input, parentDOM, callback, context2) {
  if (callback === void 0) {
    callback = null;
  }
  if (context2 === void 0) {
    context2 = EMPTY_OBJ;
  }
  __render(input, parentDOM, callback, context2);
}
var COMPONENTS_QUEUE = [];
var nextTick = typeof Promise !== "undefined" ? Promise.resolve().then.bind(Promise.resolve()) : function(a) {
  window.setTimeout(a, 0);
};
var microTaskPending = false;
function queueStateChanges(component, newState, callback, force) {
  var pending = component.$PS;
  if (isFunction2(newState)) {
    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);
  }
  if (isNullOrUndef(pending)) {
    component.$PS = newState;
  } else {
    for (var stateKey in newState) {
      pending[stateKey] = newState[stateKey];
    }
  }
  if (!component.$BR) {
    if (!renderCheck.v) {
      if (COMPONENTS_QUEUE.length === 0) {
        applyState(component, force);
        if (isFunction2(callback)) {
          callback.call(component);
        }
        return;
      }
    }
    if (COMPONENTS_QUEUE.indexOf(component) === -1) {
      COMPONENTS_QUEUE.push(component);
    }
    if (force) {
      component.$F = true;
    }
    if (!microTaskPending) {
      microTaskPending = true;
      nextTick(rerender);
    }
    if (isFunction2(callback)) {
      var QU = component.$QU;
      if (!QU) {
        QU = component.$QU = [];
      }
      QU.push(callback);
    }
  } else if (isFunction2(callback)) {
    component.$L.push(callback.bind(component));
  }
}
function callSetStateCallbacks(component) {
  var queue = component.$QU;
  for (var i = 0; i < queue.length; ++i) {
    queue[i].call(component);
  }
  component.$QU = null;
}
function rerender() {
  var component;
  microTaskPending = false;
  while (component = COMPONENTS_QUEUE.shift()) {
    if (!component.$UN) {
      var force = component.$F;
      component.$F = false;
      applyState(component, force);
      if (component.$QU) {
        callSetStateCallbacks(component);
      }
    }
  }
}
function applyState(component, force) {
  if (force || !component.$BR) {
    var pendingState = component.$PS;
    component.$PS = null;
    var lifecycle = [];
    var animations = new AnimationQueues();
    renderCheck.v = true;
    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMFromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle, animations);
    callAll(lifecycle);
    callAllAnimationHooks(animations.componentDidAppear);
    renderCheck.v = false;
  } else {
    component.state = component.$PS;
    component.$PS = null;
  }
}
var Component2 = function() {
  function Component4(props, context2) {
    this.state = null;
    this.props = void 0;
    this.context = void 0;
    this.displayName = void 0;
    this.$BR = false;
    this.$BS = true;
    this.$PS = null;
    this.$LI = null;
    this.$UN = false;
    this.$CX = null;
    this.$QU = null;
    this.$N = false;
    this.$SSR = void 0;
    this.$L = null;
    this.$SVG = false;
    this.$F = false;
    this.props = props || EMPTY_OBJ;
    this.context = context2 || EMPTY_OBJ;
  }
  var _proto = Component4.prototype;
  _proto.forceUpdate = function forceUpdate(callback) {
    if (this.$UN) {
      return;
    }
    queueStateChanges(this, {}, callback, true);
  };
  _proto.setState = function setState(newState, callback) {
    if (this.$UN) {
      return;
    }
    if (!this.$BS) {
      queueStateChanges(this, newState, callback, false);
    }
  };
  _proto.render = function render2(props, state, context2) {
    return null;
  };
  return Component4;
}();
Component2.defaultProps = null;

// node_modules/inferno/index.esm.js
if (true) {
  console.warn("You are running production build of Inferno in development mode. Use dev:module entry point.");
}

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/effect_host.js
var InfernoEffectHost = {
  lockCount: 0,
  lock() {
    this.lockCount++;
  },
  callbacks: [],
  callEffects() {
    this.lockCount--;
    if (this.lockCount < 0) {
      throw new Error("Unexpected Effect Call");
    }
    if (0 === this.lockCount) {
      const effects = this.callbacks;
      this.callbacks = [];
      effects.forEach((callback) => callback());
    }
  }
};

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/base_component.js
var areObjectsEqual = (firstObject, secondObject) => {
  const bothAreObjects = firstObject instanceof Object && secondObject instanceof Object;
  if (!bothAreObjects) {
    return firstObject === secondObject;
  }
  const firstObjectKeys = Object.keys(firstObject);
  const secondObjectKeys = Object.keys(secondObject);
  if (firstObjectKeys.length !== secondObjectKeys.length) {
    return false;
  }
  const hasDifferentElement = firstObjectKeys.some((key) => firstObject[key] !== secondObject[key]);
  return !hasDifferentElement;
};
var BaseInfernoComponent = class extends Component2 {
  constructor() {
    super(...arguments);
    this._pendingContext = this.context;
  }
  componentWillReceiveProps(_, context2) {
    this._pendingContext = context2 ?? {};
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !areObjectsEqual(this.props, nextProps) || !areObjectsEqual(this.state, nextState) || !areObjectsEqual(this.context, this._pendingContext);
  }
};
var InfernoComponent = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this._effects = [];
  }
  createEffects() {
    return [];
  }
  updateEffects() {
  }
  componentWillMount() {
    InfernoEffectHost.lock();
  }
  componentWillUpdate(_nextProps, _nextState, _context) {
    InfernoEffectHost.lock();
  }
  componentDidMount() {
    InfernoEffectHost.callbacks.push(() => {
      this._effects = this.createEffects();
    });
    InfernoEffectHost.callEffects();
  }
  componentDidUpdate() {
    InfernoEffectHost.callbacks.push(() => this.updateEffects());
    InfernoEffectHost.callEffects();
  }
  destroyEffects() {
    this._effects.forEach((e) => e.dispose());
  }
  componentWillUnmount() {
    this.destroyEffects();
  }
};
var InfernoWrapperComponent = class extends InfernoComponent {
  constructor() {
    super(...arguments);
    this.vDomElement = null;
  }
  vDomUpdateClasses() {
    var _el$className;
    const el = this.vDomElement;
    const currentClasses = null !== (_el$className = el.className) && void 0 !== _el$className && _el$className.length ? el.className.split(" ") : [];
    const addedClasses = currentClasses.filter((className) => !el.dxClasses.previous.includes(className));
    const removedClasses = el.dxClasses.previous.filter((className) => !currentClasses.includes(className));
    addedClasses.forEach((value2) => {
      const indexInRemoved = el.dxClasses.removed.indexOf(value2);
      if (indexInRemoved > -1) {
        el.dxClasses.removed.splice(indexInRemoved, 1);
      } else if (!el.dxClasses.added.includes(value2)) {
        el.dxClasses.added.push(value2);
      }
    });
    removedClasses.forEach((value2) => {
      const indexInAdded = el.dxClasses.added.indexOf(value2);
      if (indexInAdded > -1) {
        el.dxClasses.added.splice(indexInAdded, 1);
      } else if (!el.dxClasses.removed.includes(value2)) {
        el.dxClasses.removed.push(value2);
      }
    });
  }
  componentDidMount() {
    var _el$className2;
    const el = findDOMFromVNode(this.$LI, true);
    this.vDomElement = el;
    super.componentDidMount();
    el.dxClasses = el.dxClasses || {
      removed: [],
      added: [],
      previous: []
    };
    el.dxClasses.previous = null !== el && void 0 !== el && null !== (_el$className2 = el.className) && void 0 !== _el$className2 && _el$className2.length ? el.className.split(" ") : [];
  }
  componentDidUpdate() {
    super.componentDidUpdate();
    const el = this.vDomElement;
    if (null !== el) {
      var _el$className3;
      el.dxClasses.added.forEach((className) => el.classList.add(className));
      el.dxClasses.removed.forEach((className) => el.classList.remove(className));
      el.dxClasses.previous = null !== (_el$className3 = el.className) && void 0 !== _el$className3 && _el$className3.length ? el.className.split(" ") : [];
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    const shouldUpdate = super.shouldComponentUpdate(nextProps, nextState);
    if (shouldUpdate) {
      this.vDomUpdateClasses();
    }
    return shouldUpdate;
  }
};

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/create_context.js
var contextId = 0;
var createContext = function(defaultValue) {
  const id = contextId++;
  return {
    id,
    defaultValue,
    Provider: class extends Component2 {
      getChildContext() {
        return _extends({}, this.context, {
          [id]: this.props.value || defaultValue
        });
      }
      render() {
        return this.props.children;
      }
    }
  };
};

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/effect.js
var InfernoEffect = class {
  constructor(effect, dependency) {
    this.dependency = dependency;
    this.effect = effect;
    this.destroy = effect();
  }
  update(dependency) {
    const currentDependency = this.dependency;
    if (dependency) {
      this.dependency = dependency;
    }
    if (!dependency || dependency.some((d, i) => currentDependency[i] !== d)) {
      this.dispose();
      this.destroy = this.effect();
    }
  }
  dispose() {
    if (this.destroy) {
      this.destroy();
    }
  }
};

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/mocked/shared.js
var ERROR_MSG = "a runtime error occured! Use Inferno in development environment to find the error.";
function isNullOrUndef2(o) {
  return void 0 === o || null === o;
}
function isInvalid2(o) {
  return null === o || false === o || true === o || void 0 === o;
}
function isFunction3(o) {
  return "function" === typeof o;
}
function isNull2(o) {
  return null === o;
}
function throwError(message) {
  if (!message) {
    message = ERROR_MSG;
  }
  throw new Error(`Inferno Error: ${message}`);
}

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/mocked/vnode-flags.js
var VNodeFlags;
!function(VNodeFlags2) {
  VNodeFlags2[VNodeFlags2.HtmlElement = 1] = "HtmlElement";
  VNodeFlags2[VNodeFlags2.ComponentUnknown = 2] = "ComponentUnknown";
  VNodeFlags2[VNodeFlags2.ComponentClass = 4] = "ComponentClass";
  VNodeFlags2[VNodeFlags2.ComponentFunction = 8] = "ComponentFunction";
  VNodeFlags2[VNodeFlags2.Text = 16] = "Text";
  VNodeFlags2[VNodeFlags2.SvgElement = 32] = "SvgElement";
  VNodeFlags2[VNodeFlags2.InputElement = 64] = "InputElement";
  VNodeFlags2[VNodeFlags2.TextareaElement = 128] = "TextareaElement";
  VNodeFlags2[VNodeFlags2.SelectElement = 256] = "SelectElement";
  VNodeFlags2[VNodeFlags2.Void = 512] = "Void";
  VNodeFlags2[VNodeFlags2.Portal = 1024] = "Portal";
  VNodeFlags2[VNodeFlags2.ReCreate = 2048] = "ReCreate";
  VNodeFlags2[VNodeFlags2.ContentEditable = 4096] = "ContentEditable";
  VNodeFlags2[VNodeFlags2.Fragment = 8192] = "Fragment";
  VNodeFlags2[VNodeFlags2.InUse = 16384] = "InUse";
  VNodeFlags2[VNodeFlags2.ForwardRef = 32768] = "ForwardRef";
  VNodeFlags2[VNodeFlags2.Normalized = 65536] = "Normalized";
  VNodeFlags2[VNodeFlags2.ForwardRefComponent = 32776] = "ForwardRefComponent";
  VNodeFlags2[VNodeFlags2.FormElement = 448] = "FormElement";
  VNodeFlags2[VNodeFlags2.Element = 481] = "Element";
  VNodeFlags2[VNodeFlags2.Component = 14] = "Component";
  VNodeFlags2[VNodeFlags2.DOMRef = 2033] = "DOMRef";
  VNodeFlags2[VNodeFlags2.InUseOrNormalized = 81920] = "InUseOrNormalized";
  VNodeFlags2[VNodeFlags2.ClearInUse = -16385] = "ClearInUse";
  VNodeFlags2[VNodeFlags2.ComponentKnown = 12] = "ComponentKnown";
}(VNodeFlags || (VNodeFlags = {}));
var ChildFlags;
!function(ChildFlags2) {
  ChildFlags2[ChildFlags2.UnknownChildren = 0] = "UnknownChildren";
  ChildFlags2[ChildFlags2.HasInvalidChildren = 1] = "HasInvalidChildren";
  ChildFlags2[ChildFlags2.HasVNodeChildren = 2] = "HasVNodeChildren";
  ChildFlags2[ChildFlags2.HasNonKeyedChildren = 4] = "HasNonKeyedChildren";
  ChildFlags2[ChildFlags2.HasKeyedChildren = 8] = "HasKeyedChildren";
  ChildFlags2[ChildFlags2.HasTextChildren = 16] = "HasTextChildren";
  ChildFlags2[ChildFlags2.MultipleChildren = 12] = "MultipleChildren";
}(ChildFlags || (ChildFlags = {}));

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/mocked/hydrate.js
function isSameInnerHTML2(dom, innerHTML) {
  const tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function findLastDOMFromVNode(vNode) {
  let flags;
  let children;
  while (vNode) {
    flags = vNode.flags;
    if (flags & VNodeFlags.DOMRef) {
      return vNode.dom;
    }
    children = vNode.children;
    if (flags & VNodeFlags.Fragment) {
      vNode = vNode.childFlags === ChildFlags.HasVNodeChildren ? children : children[children.length - 1];
    } else if (flags & VNodeFlags.ComponentClass) {
      vNode = children.$LI;
    } else {
      vNode = children;
    }
  }
  return null;
}
function isSamePropsInnerHTML(dom, props) {
  return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML2(dom, props.dangerouslySetInnerHTML.__html));
}
function hydrateComponent(vNode, parentDOM, dom, context2, isSVG, isClass, lifecycle, animations) {
  const type2 = vNode.type;
  const ref = vNode.ref;
  const props = vNode.props || EMPTY_OBJ;
  let currentNode;
  if (isClass) {
    const instance = createClassComponentInstance(vNode, type2, props, context2, isSVG, lifecycle);
    const input = instance.$LI;
    currentNode = hydrateVNode(input, parentDOM, dom, instance.$CX, isSVG, lifecycle, animations);
    mountClassComponentCallbacks(ref, instance, lifecycle, animations);
  } else {
    const input = normalizeRoot(renderFunctionalComponent(vNode, context2));
    currentNode = hydrateVNode(input, parentDOM, dom, context2, isSVG, lifecycle, animations);
    vNode.children = input;
    mountFunctionalComponentCallbacks(vNode, lifecycle, animations);
  }
  return currentNode;
}
function hydrateChildren(parentVNode, parentNode, currentNode, context2, isSVG, lifecycle, animations) {
  const childFlags = parentVNode.childFlags;
  const children = parentVNode.children;
  const props = parentVNode.props;
  const flags = parentVNode.flags;
  if (childFlags !== ChildFlags.HasInvalidChildren) {
    if (childFlags === ChildFlags.HasVNodeChildren) {
      if (isNull2(currentNode)) {
        mount(children, parentNode, context2, isSVG, null, lifecycle, animations);
      } else {
        currentNode = hydrateVNode(children, parentNode, currentNode, context2, isSVG, lifecycle, animations);
        currentNode = currentNode ? currentNode.nextSibling : null;
      }
    } else if (childFlags === ChildFlags.HasTextChildren) {
      if (isNull2(currentNode)) {
        parentNode.appendChild(document.createTextNode(children));
      } else if (1 !== parentNode.childNodes.length || 3 !== currentNode.nodeType) {
        parentNode.textContent = children;
      } else if (currentNode.nodeValue !== children) {
        currentNode.nodeValue = children;
      }
      currentNode = null;
    } else if (childFlags & ChildFlags.MultipleChildren) {
      let prevVNodeIsTextNode = false;
      for (let i = 0, len = children.length; i < len; ++i) {
        const child = children[i];
        if (isNull2(currentNode) || prevVNodeIsTextNode && (child.flags & VNodeFlags.Text) > 0) {
          mount(child, parentNode, context2, isSVG, currentNode, lifecycle, animations);
        } else {
          currentNode = hydrateVNode(child, parentNode, currentNode, context2, isSVG, lifecycle, animations);
          currentNode = currentNode ? currentNode.nextSibling : null;
        }
        prevVNodeIsTextNode = (child.flags & VNodeFlags.Text) > 0;
      }
    }
    if (0 === (flags & VNodeFlags.Fragment)) {
      let nextSibling = null;
      while (currentNode) {
        nextSibling = currentNode.nextSibling;
        parentNode.removeChild(currentNode);
        currentNode = nextSibling;
      }
    }
  } else if (!isNull2(parentNode.firstChild) && !isSamePropsInnerHTML(parentNode, props)) {
    parentNode.textContent = "";
    if (flags & VNodeFlags.FormElement) {
      parentNode.defaultValue = "";
    }
  }
}
function hydrateElement(vNode, parentDOM, dom, context2, isSVG, lifecycle, animations) {
  const props = vNode.props;
  const className = vNode.className;
  const flags = vNode.flags;
  const ref = vNode.ref;
  isSVG = isSVG || (flags & VNodeFlags.SvgElement) > 0;
  if (1 !== dom.nodeType) {
    mountElement(vNode, null, context2, isSVG, null, lifecycle, animations);
    parentDOM.replaceChild(vNode.dom, dom);
  } else {
    vNode.dom = dom;
    hydrateChildren(vNode, dom, dom.firstChild, context2, isSVG, lifecycle, animations);
    if (!isNull2(props)) {
      mountProps(vNode, flags, props, dom, isSVG, animations);
    }
    if (isNullOrUndef2(className)) {
      if ("" !== dom.className) {
        dom.removeAttribute("class");
      }
    } else if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
    mountRef(ref, dom, lifecycle);
  }
  return vNode.dom;
}
function hydrateText(vNode, parentDOM, dom) {
  if (3 !== dom.nodeType) {
    parentDOM.replaceChild(vNode.dom = document.createTextNode(vNode.children), dom);
  } else {
    const text = vNode.children;
    if (dom.nodeValue !== text) {
      dom.nodeValue = text;
    }
    vNode.dom = dom;
  }
  return vNode.dom;
}
function hydrateFragment(vNode, parentDOM, dom, context2, isSVG, lifecycle, animations) {
  const children = vNode.children;
  if (vNode.childFlags === ChildFlags.HasVNodeChildren) {
    hydrateText(children, parentDOM, dom);
    return children.dom;
  }
  hydrateChildren(vNode, parentDOM, dom, context2, isSVG, lifecycle, animations);
  return findLastDOMFromVNode(children[children.length - 1]);
}
function hydrateVNode(vNode, parentDOM, currentDom, context2, isSVG, lifecycle, animations) {
  const flags = vNode.flags |= VNodeFlags.InUse;
  if (flags & VNodeFlags.Component) {
    return hydrateComponent(vNode, parentDOM, currentDom, context2, isSVG, (flags & VNodeFlags.ComponentClass) > 0, lifecycle, animations);
  }
  if (flags & VNodeFlags.Element) {
    return hydrateElement(vNode, parentDOM, currentDom, context2, isSVG, lifecycle, animations);
  }
  if (flags & VNodeFlags.Text) {
    return hydrateText(vNode, parentDOM, currentDom);
  }
  if (flags & VNodeFlags.Void) {
    return vNode.dom = currentDom;
  }
  if (flags & VNodeFlags.Fragment) {
    return hydrateFragment(vNode, parentDOM, currentDom, context2, isSVG, lifecycle, animations);
  }
  throwError();
  return null;
}
function hydrate(input, parentDOM, callback) {
  let dom = parentDOM.firstChild;
  if (isNull2(dom)) {
    render(input, parentDOM, callback);
  } else {
    const lifecycle = [];
    const animations = new AnimationQueues();
    if (!isInvalid2(input)) {
      dom = hydrateVNode(input, parentDOM, dom, {}, false, lifecycle, animations);
    }
    while (dom && (dom = dom.nextSibling)) {
      parentDOM.removeChild(dom);
    }
    if (lifecycle.length > 0) {
      let listener;
      while (void 0 !== (listener = lifecycle.shift())) {
        listener();
      }
    }
  }
  parentDOM.$V = input;
  if (isFunction3(callback)) {
    callback();
  }
}

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/re_render_effect.js
var createReRenderEffect = () => new InfernoEffect(() => {
  rerender();
}, []);

// node_modules/inferno-create-element/dist/index.esm.js
function isNullOrUndef3(o) {
  return o === void 0 || o === null;
}
function isString3(o) {
  return typeof o === "string";
}
function isUndefined2(o) {
  return o === void 0;
}
var componentHooks = {
  onComponentDidAppear: 1,
  onComponentDidMount: 1,
  onComponentDidUpdate: 1,
  onComponentShouldUpdate: 1,
  onComponentWillDisappear: 1,
  onComponentWillMount: 1,
  onComponentWillUnmount: 1,
  onComponentWillUpdate: 1
};
function createElement(type2, props, _children) {
  var children;
  var ref = null;
  var key = null;
  var className = null;
  var flags;
  var newProps;
  var childLen = arguments.length - 2;
  if (childLen === 1) {
    children = _children;
  } else if (childLen > 1) {
    children = [];
    while (childLen-- > 0) {
      children[childLen] = arguments[childLen + 2];
    }
  }
  if (isString3(type2)) {
    flags = getFlagsForElementVnode(type2);
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var prop in props) {
        if (prop === "className" || prop === "class") {
          className = props[prop];
        } else if (prop === "key") {
          key = props.key;
        } else if (prop === "children" && isUndefined2(children)) {
          children = props.children;
        } else if (prop === "ref") {
          ref = props.ref;
        } else {
          if (prop === "contenteditable") {
            flags |= 4096;
          }
          newProps[prop] = props[prop];
        }
      }
    }
  } else {
    flags = 2;
    if (!isUndefined2(children)) {
      if (!props) {
        props = {};
      }
      props.children = children;
    }
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var _prop in props) {
        if (_prop === "key") {
          key = props.key;
        } else if (_prop === "ref") {
          ref = props.ref;
        } else if (componentHooks[_prop] === 1) {
          if (!ref) {
            ref = {};
          }
          ref[_prop] = props[_prop];
        } else {
          newProps[_prop] = props[_prop];
        }
      }
    }
    return createComponentVNode(flags, type2, newProps, key, ref);
  }
  if (flags & 8192) {
    return createFragment(childLen === 1 ? [children] : children, 0, key);
  }
  return createVNode(flags, type2, className, children, 0, newProps, key, ref);
}

// node_modules/devextreme/esm/__internal/core/m_inferno_renderer.js
var remove3 = (element) => {
  const {
    parentNode
  } = element;
  if (parentNode) {
    const {
      nextSibling
    } = element;
    cleanDataRecursive(element);
    parentNode.$V = element.$V;
    render(null, parentNode);
    parentNode.insertBefore(element, nextSibling);
    element.innerHTML = "";
    delete parentNode.$V;
  }
  delete element.$V;
};
var infernoRenderer = dependency_injector_default({
  createElement: (component, props) => createElement(component, props),
  remove: remove3,
  onAfterRender: () => {
    InfernoEffectHost.callEffects();
  },
  onPreRender: () => {
    InfernoEffectHost.lock();
  },
  render: (component, props, container, replace) => {
    if (!replace) {
      const {
        parentNode
      } = container;
      const nextNode = null === container || void 0 === container ? void 0 : container.nextSibling;
      const rootNode = dom_adapter_default.createElement("div");
      rootNode.appendChild(container);
      const mountNode = dom_adapter_default.createDocumentFragment().appendChild(rootNode);
      const vNodeAlreadyExists = !!container.$V;
      vNodeAlreadyExists && remove3(container);
      hydrate(createElement(component, props), mountNode);
      container.$V = mountNode.$V;
      if (parentNode) {
        parentNode.insertBefore(container, nextNode);
      }
    } else {
      render(createElement(component, props), container);
    }
  },
  renderIntoContainer: (jsx, container, replace) => {
    if (!replace) {
      hydrate(jsx, container);
    } else {
      render(jsx, container);
    }
  }
});

// node_modules/devextreme/esm/core/inferno_renderer.js
var inferno_renderer_default = infernoRenderer;

// node_modules/devextreme/esm/__internal/core/r1/utils/shallow_equals.js
var shallowEquals = (firstObject, secondObject) => {
  if (Object.keys(firstObject).length !== Object.keys(secondObject).length) {
    return false;
  }
  return Object.entries(firstObject).every((_ref) => {
    let [key, firstValue] = _ref;
    const secondValue = secondObject[key];
    if (firstValue instanceof Date && secondValue instanceof Date) {
      return firstValue.getTime() === secondValue.getTime();
    }
    return firstValue === secondValue;
  });
};

// node_modules/devextreme/esm/__internal/core/r1/template_wrapper.js
var _excluded3 = ["isEqual"];
var isDxElementWrapper = (element) => !!element.toArray;
var buildTemplateArgs = (model, template) => {
  const args = {
    template,
    model: _extends({}, model)
  };
  const _ref = model.data ?? {}, {
    isEqual
  } = _ref, data2 = _objectWithoutPropertiesLoose(_ref, _excluded3);
  if (isEqual) {
    args.model.data = data2;
    args.isEqual = isEqual;
  }
  return args;
};
var renderTemplateContent = (props, container) => {
  const {
    data: data2,
    index: index2
  } = props.model ?? {
    data: {}
  };
  if (data2) {
    Object.keys(data2).forEach((name2) => {
      if (data2[name2] && dom_adapter_default.isNode(data2[name2])) {
        data2[name2] = getPublicElement(renderer_default(data2[name2]));
      }
    });
  }
  const rendered = props.template.render(_extends({
    container,
    transclude: props.transclude
  }, {
    renovated: props.renovated
  }, !props.transclude ? {
    model: data2
  } : {}, !props.transclude && Number.isFinite(index2) ? {
    index: index2
  } : {}));
  if (void 0 === rendered) {
    return [];
  }
  return isDxElementWrapper(rendered) ? rendered.toArray() : [renderer_default(rendered).get(0)];
};
var removeDifferentElements = (oldChildren, newChildren) => {
  newChildren.forEach((newElement) => {
    const hasOldChild = !!oldChildren.find((oldElement) => newElement === oldElement);
    if (!hasOldChild && newElement.parentNode) {
      renderer_default(newElement).remove();
    }
  });
};
var TemplateWrapper = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.renderTemplate = this.renderTemplate.bind(this);
  }
  renderTemplate() {
    const node = findDOMFromVNode(this.$LI, true);
    if (!(null !== node && void 0 !== node && node.parentNode)) {
      return () => {
      };
    }
    const container = node.parentNode;
    const $container = renderer_default(container);
    const $oldContainerContent = $container.contents().toArray();
    const content = renderTemplateContent(this.props, getPublicElement($container));
    replaceWith(renderer_default(node), renderer_default(content));
    return () => {
      const $actualContainerContent = renderer_default(container).contents().toArray();
      removeDifferentElements($oldContainerContent, $actualContainerContent);
      container.appendChild(node);
    };
  }
  shouldComponentUpdate(nextProps) {
    const {
      template,
      model
    } = this.props;
    const {
      template: nextTemplate,
      model: nextModel,
      isEqual
    } = nextProps;
    const equalityComparer = isEqual ?? shallowEquals;
    if (template !== nextTemplate) {
      return true;
    }
    if (!isDefined(model) || !isDefined(nextModel)) {
      return model !== nextModel;
    }
    const {
      data: data2,
      index: index2
    } = model;
    const {
      data: nextData,
      index: nextIndex
    } = nextModel;
    if (index2 !== nextIndex) {
      return true;
    }
    if (!isDefined(data2) || !isDefined(nextData)) {
      return model !== nextModel;
    }
    return !equalityComparer(data2, nextData);
  }
  createEffects() {
    return [new InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
  }
  updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  }
  componentWillUnmount() {
  }
  render() {
    return null;
  }
};

// node_modules/devextreme/esm/__internal/core/r1/utils/get_template.js
var getTemplate = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);

// node_modules/devextreme/esm/__internal/core/r1/utils/update_props_immutable.js
var cloneObjectValue = (value2) => Array.isArray(value2) ? [...value2] : _extends({}, value2);
var cloneObjectProp = (value2, prevValue, fullNameParts) => {
  const result2 = fullNameParts.length > 0 && prevValue && value2 !== prevValue ? cloneObjectValue(prevValue) : cloneObjectValue(value2);
  const name2 = fullNameParts[0];
  if (fullNameParts.length > 1) {
    result2[name2] = cloneObjectProp(value2[name2], null === prevValue || void 0 === prevValue ? void 0 : prevValue[name2], fullNameParts.slice(1));
  } else if (name2) {
    if (isPlainObject(value2[name2])) {
      result2[name2] = cloneObjectValue(value2[name2]);
    } else {
      result2[name2] = value2[name2];
    }
  }
  return result2;
};
var updatePropsImmutable = (props, option, name2, fullName) => {
  const currentPropsValue = option[name2];
  const prevPropsValue = props[name2];
  const result2 = props;
  if (isPlainObject(currentPropsValue) || name2 !== fullName && Array.isArray(currentPropsValue)) {
    result2[name2] = cloneObjectProp(currentPropsValue, prevPropsValue, getPathParts(fullName).slice(1));
  } else {
    result2[name2] = currentPropsValue;
  }
};

// node_modules/devextreme/esm/__internal/core/r1/component_wrapper.js
var setDefaultOptionValue = (options2, defaultValueGetter) => (name2) => {
  if (Object.prototype.hasOwnProperty.call(options2, name2) && void 0 === options2[name2]) {
    options2[name2] = defaultValueGetter(name2);
  }
};
var ComponentWrapper = class extends dom_component_default2 {
  get _propsInfo() {
    return {
      allowNull: [],
      twoWay: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  constructor(element, options2) {
    super(element, options2);
    this._shouldRaiseContentReady = false;
    this.validateKeyDownHandler();
  }
  validateKeyDownHandler() {
    const supportedKeyNames = this.getSupportedKeyNames();
    const hasComponentDefaultKeyHandlers = supportedKeyNames.length > 0;
    const hasComponentKeyDownMethod = "function" === typeof this._viewComponent.prototype.keyDown;
    if (hasComponentDefaultKeyHandlers && !hasComponentKeyDownMethod) {
      throw Error("Component's declaration must have 'keyDown' method.");
    }
  }
  get viewRef() {
    var _this$_viewRef;
    return null === (_this$_viewRef = this._viewRef) || void 0 === _this$_viewRef ? void 0 : _this$_viewRef.current;
  }
  _checkContentReadyOption(fullName) {
    const contentReadyOptions = this._getContentReadyOptions().reduce((options2, name2) => {
      options2[name2] = true;
      return options2;
    }, {});
    this._checkContentReadyOption = (optionName) => !!contentReadyOptions[optionName];
    return this._checkContentReadyOption(fullName);
  }
  _getContentReadyOptions() {
    return ["rtlEnabled"];
  }
  _fireContentReady() {
    this._actionsMap.onContentReady({});
  }
  _getDefaultOptions() {
    const viewDefaultProps = this._getViewComponentDefaultProps();
    return extend(true, super._getDefaultOptions(), viewDefaultProps, this._propsInfo.twoWay.reduce((options2, _ref) => {
      let [name2, defaultName, eventName] = _ref;
      return _extends({}, options2, {
        [name2]: viewDefaultProps[defaultName],
        [eventName]: (value2) => this.option(name2, value2)
      });
    }, {}), this._propsInfo.templates.reduce((options2, name2) => _extends({}, options2, {
      [name2]: null
    }), {}));
  }
  _getUnwrappedOption() {
    const unwrappedProps = {};
    Object.keys(this.option()).forEach((key) => {
      unwrappedProps[key] = this.option(key);
    });
    return unwrappedProps;
  }
  _initializeComponent() {
    var _this$_templateManage;
    super._initializeComponent();
    null === (_this$_templateManage = this._templateManager) || void 0 === _this$_templateManage || _this$_templateManage.addDefaultTemplates(this.getDefaultTemplates());
    const optionProxy = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(optionProxy);
    this._propsInfo.templates.forEach((template) => {
      this._componentTemplates[template] = this._createTemplateComponent(this._props[template]);
    });
    Object.keys(this._getActionConfigsFull()).forEach((name2) => this._addAction(name2));
    this._viewRef = createRef();
    this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  }
  _initMarkup() {
    const props = this.getProps();
    this._renderWrapper(props);
  }
  _renderWrapper(props) {
    const containerNode = this.$element()[0];
    if (!this._isNodeReplaced) {
      inferno_renderer_default.onPreRender();
    }
    inferno_renderer_default.render(this._viewComponent, props, containerNode, this._isNodeReplaced);
    if (!this._isNodeReplaced) {
      this._isNodeReplaced = true;
      inferno_renderer_default.onAfterRender();
      this._shouldRaiseContentReady = true;
    }
    if (this._shouldRaiseContentReady) {
      this._fireContentReady();
      this._shouldRaiseContentReady = false;
    }
  }
  _silent(name2, value2) {
    this._options.silent(name2, value2);
  }
  _render() {
  }
  _removeWidget() {
    inferno_renderer_default.remove(this.$element()[0]);
  }
  _dispose() {
    this._removeWidget();
    super._dispose();
  }
  get elementAttr() {
    const element = this.$element()[0];
    if (!this._elementAttr) {
      const {
        attributes
      } = element;
      const attrs = Array.from(attributes).filter((attr) => {
        var _attributes$attr$name;
        return !this._propsInfo.templates.includes(attr.name) && (null === (_attributes$attr$name = attributes[attr.name]) || void 0 === _attributes$attr$name ? void 0 : _attributes$attr$name.specified);
      }).reduce((result2, _ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        const updatedAttributes = result2;
        const isDomAttr = name2 in element;
        updatedAttributes[name2] = "" === value2 && isDomAttr ? element[name2] : value2;
        return updatedAttributes;
      }, {});
      this._elementAttr = attrs;
      this._storedClasses = element.getAttribute("class") || "";
    }
    const elemStyle = element.style;
    const style = {};
    for (let i = 0; i < elemStyle.length; i += 1) {
      style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
    }
    this._elementAttr.style = style;
    this._elementAttr.class = this._storedClasses;
    return this._elementAttr;
  }
  _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ["disabled", "readOnly"]
      }
    };
  }
  _getAdditionalProps() {
    return [];
  }
  _patchOptionValues(options2) {
    const {
      allowNull,
      twoWay,
      elements,
      props
    } = this._propsInfo;
    const viewDefaultProps = this._getViewComponentDefaultProps();
    const defaultWidgetPropsKeys = Object.keys(viewDefaultProps);
    const defaultOptions2 = this._getDefaultOptions();
    const {
      ref,
      children,
      onKeyboardHandled
    } = options2;
    const onKeyDown = onKeyboardHandled ? (_, event_options) => {
      onKeyboardHandled(event_options);
    } : void 0;
    const widgetProps = {
      ref,
      children,
      onKeyDown
    };
    [...props, ...this._getAdditionalProps()].forEach((propName) => {
      if (Object.prototype.hasOwnProperty.call(options2, propName)) {
        widgetProps[propName] = options2[propName];
      }
    });
    allowNull.forEach(setDefaultOptionValue(widgetProps, () => null));
    defaultWidgetPropsKeys.forEach(setDefaultOptionValue(widgetProps, (name2) => defaultOptions2[name2]));
    twoWay.forEach((_ref3) => {
      let [name2, defaultName] = _ref3;
      setDefaultOptionValue(widgetProps, () => defaultOptions2[defaultName])(name2);
    });
    elements.forEach((name2) => {
      if (name2 in widgetProps) {
        const value2 = widgetProps[name2];
        if (isRenderer(value2)) {
          widgetProps[name2] = this._patchElementParam(value2);
        }
      }
    });
    return widgetProps;
  }
  getSupportedKeyNames() {
    return [];
  }
  prepareStyleProp(props) {
    if ("string" === typeof props.style) {
      return _extends({}, props, {
        style: {},
        cssText: props.style
      });
    }
    return props;
  }
  getProps() {
    const {
      elementAttr
    } = this.option();
    const options2 = this._patchOptionValues(_extends({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    this._propsInfo.templates.forEach((template) => {
      options2[template] = this._componentTemplates[template];
    });
    return this.prepareStyleProp(_extends({}, options2, this.elementAttr, elementAttr, {
      className: [...(this.elementAttr.class ?? "").split(" "), ...((null === elementAttr || void 0 === elementAttr ? void 0 : elementAttr.class) ?? "").split(" ")].filter((c, i, a) => c && a.indexOf(c) === i).join(" ").trim(),
      class: ""
    }, this._actionsMap));
  }
  _getActionConfigs() {
    return {};
  }
  _getActionConfigsFull() {
    return _extends({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  }
  getDefaultTemplates() {
    const defaultTemplates = Object.values(this._templatesInfo);
    const result2 = {};
    defaultTemplates.forEach((template) => {
      result2[template] = "dx-renovation-template-mock";
    });
    return result2;
  }
  get _templatesInfo() {
    return {};
  }
  _optionsWithDefaultTemplates(options2) {
    const templateOptions = Object.entries(this._templatesInfo).reduce((result2, _ref4) => {
      let [templateName, templateValue] = _ref4;
      return _extends({}, result2, {
        [templateName]: options2[templateName] ?? templateValue
      });
    }, {});
    return _extends({}, options2, templateOptions);
  }
  _init() {
    super._init();
    this.customKeyHandlers = {};
    this._actionsMap = {};
    this._aria = {};
    this._componentTemplates = {};
  }
  _createDefaultKeyHandlers() {
    const result2 = {};
    const keys = this.getSupportedKeyNames();
    keys.forEach((key) => {
      result2[key] = (e) => this.viewRef.keyDown(m_keyboard_processor_default.createKeyDownOptions(e));
    });
    return result2;
  }
  _addAction(event, actionToAdd) {
    let action = actionToAdd;
    if (!action) {
      const actionByOption = this._createActionByOption(event, this._getActionConfigsFull()[event]);
      action = (actArgs) => {
        Object.keys(actArgs).forEach((name2) => {
          if (isDefined(actArgs[name2]) && dom_adapter_default.isNode(actArgs[name2])) {
            actArgs[name2] = getPublicElement(renderer_default(actArgs[name2]));
          }
        });
        return actionByOption(actArgs);
      };
    }
    this._actionsMap[event] = action;
  }
  _optionChanged(option) {
    const {
      name: name2,
      fullName,
      value: value2,
      previousValue
    } = option;
    updatePropsImmutable(this._props, this.option(), name2, fullName);
    if (this._propsInfo.templates.includes(name2) && value2 !== previousValue) {
      this._componentTemplates[name2] = this._createTemplateComponent(value2);
    }
    if (name2 && this._getActionConfigsFull()[name2]) {
      this._addAction(name2);
    }
    this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(fullName);
    super._optionChanged(option);
    this._invalidate();
  }
  _validateOptions(options2) {
    return super._validateOptions(options2);
  }
  _extractDefaultSlot() {
    if (this.option("_hasAnonymousTemplateContent")) {
      return inferno_renderer_default.createElement(TemplateWrapper, {
        template: this._getTemplate(this._templateManager.anonymousTemplateName),
        transclude: true,
        renovated: true
      });
    }
    return null;
  }
  _createTemplateComponent(templateOption) {
    if (!templateOption) {
      return;
    }
    const template = this._getTemplate(templateOption);
    if (isString(template) && "dx-renovation-template-mock" === template) {
      return;
    }
    return (model) => inferno_renderer_default.createElement(TemplateWrapper, buildTemplateArgs(model, template));
  }
  _wrapKeyDownHandler(initialHandler) {
    return (options2) => {
      const {
        originalEvent,
        keyName,
        which
      } = options2;
      const keys = this.customKeyHandlers;
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          originalEvent.cancel = true;
          return originalEvent;
        }
      }
      return null === initialHandler || void 0 === initialHandler ? void 0 : initialHandler(originalEvent, options2);
    };
  }
  _toPublicElement(element) {
    return getPublicElement(renderer_default(element));
  }
  _patchElementParam(value2) {
    try {
      const result2 = renderer_default(value2);
      const element = null === result2 || void 0 === result2 ? void 0 : result2.get(0);
      return null !== element && void 0 !== element && element.nodeType ? element : value2;
    } catch (error2) {
      return value2;
    }
  }
  focus() {
    const $root = this.$element();
    const hasFocus = $root.is(":focus") || $root.find(":focus").length > 0;
    if (hasFocus) {
      return;
    }
    if (this.option("focusStateEnabled")) {
      $root.focus();
    } else {
      var _focusableElements$;
      const focusableElements = $root.find("[tabindex]");
      null === (_focusableElements$ = focusableElements[0]) || void 0 === _focusableElements$ || _focusableElements$.focus();
    }
  }
  repaint() {
    this._isNodeReplaced = false;
    this._shouldRaiseContentReady = true;
    this._removeWidget();
    this._refresh();
  }
  _supportedKeys() {
    return _extends({}, this.defaultKeyHandlers, this.customKeyHandlers);
  }
  registerKeyHandler(key, handler) {
    this.customKeyHandlers[key] = handler;
  }
  setAria(name2, value2) {
    this._aria[name2] = value2;
    this._initMarkup();
  }
  _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  }
};
ComponentWrapper.IS_RENOVATED_WIDGET = false;
ComponentWrapper.IS_RENOVATED_WIDGET = true;

// node_modules/devextreme/esm/__internal/core/r1/base_props.js
var BaseWidgetDefaultProps = {
  className: "",
  activeStateEnabled: false,
  disabled: false,
  focusStateEnabled: false,
  hoverStateEnabled: false,
  tabIndex: 0,
  visible: true
};

// node_modules/devextreme/esm/__internal/core/r1/config_context.js
var ConfigContext = createContext(void 0);

// node_modules/devextreme/esm/__internal/core/r1/config_provider.js
var ConfigProviderDefaultProps = {};
var ConfigProvider = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.__getterCache = {};
  }
  get config() {
    if (void 0 !== this.__getterCache.config) {
      return this.__getterCache.config;
    }
    return this.__getterCache.config = (() => ({
      rtlEnabled: this.props.rtlEnabled
    }))();
  }
  componentWillUpdate(nextProps) {
    if (this.props.rtlEnabled !== nextProps.rtlEnabled) {
      this.__getterCache.config = void 0;
    }
  }
  getChildContext() {
    return _extends({}, this.context, {
      [ConfigContext.id]: this.config || ConfigContext.defaultValue
    });
  }
  render() {
    return this.props.children;
  }
};
ConfigProvider.defaultProps = ConfigProviderDefaultProps;

// node_modules/devextreme/esm/__internal/core/r1/utils/render_utils.js
var combineClasses = (classesMap) => Object.keys(classesMap).filter((cssClass) => !!cssClass && classesMap[cssClass]).join(" ").split(" ").filter((cssClass, i, filteredClassesMap) => filteredClassesMap.indexOf(cssClass) === i).join(" ");

// node_modules/devextreme/esm/__internal/core/r1/utils/resolve_rtl.js
function resolveRtlEnabled(rtlProp, config3) {
  if (void 0 !== rtlProp) {
    return rtlProp;
  }
  if (void 0 !== (null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled)) {
    return config3.rtlEnabled;
  }
  return config_default().rtlEnabled;
}
function resolveRtlEnabledDefinition(rtlProp, config3) {
  const isPropDefined = isDefined(rtlProp);
  const onlyGlobalDefined = isDefined(config_default().rtlEnabled) && !isPropDefined && !isDefined(null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled);
  return isPropDefined && rtlProp !== (null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled) || onlyGlobalDefined;
}

// node_modules/devextreme/esm/__internal/events/gesture/m_emitter.gesture.js
var ready4 = ready_callbacks_default.add;
var {
  abs: abs2
} = Math;
var TOUCH_BOUNDARY = 10;
var supportPointerEvents = function() {
  return styleProp("pointer-events");
};
var setGestureCover = call_once_default(() => {
  const isDesktop = "desktop" === m_devices_default.real().deviceType;
  if (!supportPointerEvents() || !isDesktop) {
    return noop2;
  }
  const $cover = renderer_default("<div>").addClass("dx-gesture-cover").css("pointerEvents", "none");
  m_events_engine_default.subscribeGlobal($cover, "dxmousewheel", (e) => {
    e.preventDefault();
  });
  ready4(() => {
    $cover.appendTo("body");
  });
  return function(toggle, cursor) {
    $cover.css("pointerEvents", toggle ? "all" : "none");
    toggle && $cover.css("cursor", cursor);
  };
});
var gestureCover = function(toggle, cursor) {
  const gestureCoverStrategy = setGestureCover();
  gestureCoverStrategy(toggle, cursor);
};
var GestureEmitter = m_emitter_default.inherit({
  gesture: true,
  configure(data2) {
    this.getElement().css("msTouchAction", data2.immediate ? "pinch-zoom" : "");
    this.callBase(data2);
  },
  allowInterruptionByMouseWheel() {
    return 2 !== this._stage;
  },
  getDirection() {
    return this.direction;
  },
  _cancel() {
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
    this._stage = 0;
  },
  start(e) {
    if (e._needSkipEvent || needSkipEvent(e)) {
      this._cancel(e);
      return;
    }
    this._startEvent = createEvent(e);
    this._startEventData = eventData(e);
    this._stage = 1;
    this._init(e);
    this._setupImmediateTimer();
  },
  _setupImmediateTimer() {
    clearTimeout(this._immediateTimer);
    this._immediateAccepted = false;
    if (!this.immediate) {
      return;
    }
    if (0 === this.immediateTimeout) {
      this._immediateAccepted = true;
      return;
    }
    this._immediateTimer = setTimeout(() => {
      this._immediateAccepted = true;
    }, this.immediateTimeout ?? 180);
  },
  move(e) {
    if (1 === this._stage && this._directionConfirmed(e)) {
      this._stage = 2;
      this._resetActiveElement();
      this._toggleGestureCover(true);
      this._clearSelection(e);
      this._adjustStartEvent(e);
      this._start(this._startEvent);
      if (0 === this._stage) {
        return;
      }
      this._requestAccept(e);
      this._move(e);
      this._forgetAccept();
    } else if (2 === this._stage) {
      this._clearSelection(e);
      this._move(e);
    }
  },
  _directionConfirmed(e) {
    const touchBoundary = this._getTouchBoundary(e);
    const delta = eventDelta(this._startEventData, eventData(e));
    const deltaX = abs2(delta.x);
    const deltaY = abs2(delta.y);
    const horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
    const verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
    const direction = this.getDirection(e);
    const bothAccepted = "both" === direction && (horizontalMove || verticalMove);
    const horizontalAccepted = "horizontal" === direction && horizontalMove;
    const verticalAccepted = "vertical" === direction && verticalMove;
    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;
  },
  _validateMove(touchBoundary, mainAxis, crossAxis) {
    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);
  },
  _getTouchBoundary(e) {
    return this.immediate || isDxMouseWheelEvent(e) ? 0 : TOUCH_BOUNDARY;
  },
  _adjustStartEvent(e) {
    const touchBoundary = this._getTouchBoundary(e);
    const delta = eventDelta(this._startEventData, eventData(e));
    this._startEvent.pageX += sign(delta.x) * touchBoundary;
    this._startEvent.pageY += sign(delta.y) * touchBoundary;
  },
  _resetActiveElement() {
    if ("ios" === m_devices_default.real().platform && this.getElement().find(":focus").length) {
      m_dom_default.resetActiveElement();
    }
  },
  _toggleGestureCover(toggle) {
    this._toggleGestureCoverImpl(toggle);
  },
  _toggleGestureCoverImpl(toggle) {
    const isStarted = 2 === this._stage;
    if (isStarted) {
      gestureCover(toggle, this.getElement().css("cursor"));
    }
  },
  _clearSelection(e) {
    if (isDxMouseWheelEvent(e) || isTouchEvent(e)) {
      return;
    }
    m_dom_default.clearSelection();
  },
  end(e) {
    this._toggleGestureCover(false);
    if (2 === this._stage) {
      this._end(e);
    } else if (1 === this._stage) {
      this._stop(e);
    }
    this._stage = 0;
  },
  dispose() {
    clearTimeout(this._immediateTimer);
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
  },
  _init: noop2,
  _start: noop2,
  _move: noop2,
  _stop: noop2,
  _end: noop2
});
GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
GestureEmitter.touchBoundary = function(newBoundary) {
  if (isDefined(newBoundary)) {
    TOUCH_BOUNDARY = newBoundary;
    return;
  }
  return TOUCH_BOUNDARY;
};
var m_emitter_gesture_default = GestureEmitter;

// node_modules/devextreme/esm/__internal/events/gesture/m_emitter.gesture.scroll.js
var {
  abstract: abstract3
} = class_default;
var realDevice = m_devices_default.real();
var Locker = class_default.inherit(function() {
  const NAMESPACED_SCROLL_EVENT = addNamespace2("scroll", "dxScrollEmitter");
  return {
    ctor(element) {
      this._element = element;
      this._locked = false;
      this._proxiedScroll = (e) => {
        if (!this._disposed) {
          this._scroll(e);
        }
      };
      m_events_engine_default.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    },
    _scroll: abstract3,
    check(e, callback) {
      if (this._locked) {
        callback();
      }
    },
    dispose() {
      this._disposed = true;
      m_events_engine_default.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    }
  };
}());
var TimeoutLocker = Locker.inherit({
  ctor(element, timeout) {
    this.callBase(element);
    this._timeout = timeout;
  },
  _scroll() {
    this._prepare();
    this._forget();
  },
  _prepare() {
    if (this._timer) {
      this._clearTimer();
    }
    this._locked = true;
  },
  _clearTimer() {
    clearTimeout(this._timer);
    this._locked = false;
    this._timer = null;
  },
  _forget() {
    const that = this;
    this._timer = setTimeout(() => {
      that._clearTimer();
    }, this._timeout);
  },
  dispose() {
    this.callBase();
    this._clearTimer();
  }
});
var WheelLocker = TimeoutLocker.inherit({
  ctor(element) {
    this.callBase(element, 400);
    this._lastWheelDirection = null;
  },
  check(e, callback) {
    this._checkDirectionChanged(e);
    this.callBase(e, callback);
  },
  _checkDirectionChanged(e) {
    if (!isDxMouseWheelEvent(e)) {
      this._lastWheelDirection = null;
      return;
    }
    const direction = e.shiftKey || false;
    const directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;
    this._lastWheelDirection = direction;
    this._locked = this._locked && !directionChange;
  }
});
var PointerLocker = TimeoutLocker.inherit({
  ctor(element) {
    this.callBase(element, 400);
  }
});
!function() {
  const {
    ios: isIos,
    android: isAndroid
  } = realDevice;
  if (!(isIos || isAndroid)) {
    return;
  }
  PointerLocker = Locker.inherit({
    _scroll() {
      this._locked = true;
      const that = this;
      cancelAnimationFrame(this._scrollFrame);
      this._scrollFrame = requestAnimationFrame(() => {
        that._locked = false;
      });
    },
    check(e, callback) {
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
      const that = this;
      const {
        callBase
      } = this;
      this._checkFrame = requestAnimationFrame(() => {
        callBase.call(that, e, callback);
        that._locked = false;
      });
    },
    dispose() {
      this.callBase();
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
    }
  });
}();
var ScrollEmitter = m_emitter_gesture_default.inherit(function() {
  const FRAME_DURATION = Math.round(1e3 / 60);
  return {
    ctor(element) {
      this.callBase.apply(this, arguments);
      this.direction = "both";
      this._pointerLocker = new PointerLocker(element);
      this._wheelLocker = new WheelLocker(element);
    },
    validate: () => true,
    configure(data2) {
      if (data2.scrollTarget) {
        this._pointerLocker.dispose();
        this._wheelLocker.dispose();
        this._pointerLocker = new PointerLocker(data2.scrollTarget);
        this._wheelLocker = new WheelLocker(data2.scrollTarget);
      }
      this.callBase(data2);
    },
    _init(e) {
      this._wheelLocker.check(e, () => {
        if (isDxMouseWheelEvent(e)) {
          this._accept(e);
        }
      });
      this._pointerLocker.check(e, () => {
        const skipCheck = this.isNative && isMouseEvent(e);
        if (!isDxMouseWheelEvent(e) && !skipCheck) {
          this._accept(e);
        }
      });
      this._fireEvent("dxscrollinit", e);
      this._prevEventData = eventData(e);
    },
    move(e) {
      this.callBase.apply(this, arguments);
      e.isScrollingEvent = this.isNative || e.isScrollingEvent;
    },
    _start(e) {
      this._savedEventData = eventData(e);
      this._fireEvent("dxscrollstart", e);
      this._prevEventData = eventData(e);
    },
    _move(e) {
      const currentEventData = eventData(e);
      this._fireEvent("dxscroll", e, {
        delta: eventDelta(this._prevEventData, currentEventData)
      });
      const delta = eventDelta(this._savedEventData, currentEventData);
      if (delta.time > 200) {
        this._savedEventData = this._prevEventData;
      }
      this._prevEventData = eventData(e);
    },
    _end(e) {
      const endEventDelta = eventDelta(this._prevEventData, eventData(e));
      let velocity = {
        x: 0,
        y: 0
      };
      if (!isDxMouseWheelEvent(e) && endEventDelta.time < 100) {
        const delta = eventDelta(this._savedEventData, this._prevEventData);
        const velocityMultiplier = FRAME_DURATION / delta.time;
        velocity = {
          x: delta.x * velocityMultiplier,
          y: delta.y * velocityMultiplier
        };
      }
      this._fireEvent("dxscrollend", e, {
        velocity
      });
    },
    _stop(e) {
      this._fireEvent("dxscrollstop", e);
    },
    cancel(e) {
      this.callBase.apply(this, arguments);
      this._fireEvent("dxscrollcancel", e);
    },
    dispose() {
      this.callBase.apply(this, arguments);
      this._pointerLocker.dispose();
      this._wheelLocker.dispose();
    },
    _clearSelection() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    },
    _toggleGestureCover() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    }
  };
}());
m_emitter_registrator_default({
  emitter: ScrollEmitter,
  events: ["dxscrollinit", "dxscrollstart", "dxscroll", "dxscrollend", "dxscrollstop", "dxscrollcancel"]
});
var m_emitter_gesture_scroll_default = {
  init: "dxscrollinit",
  start: "dxscrollstart",
  move: "dxscroll",
  end: "dxscrollend",
  stop: "dxscrollstop",
  cancel: "dxscrollcancel",
  scroll: "scroll"
};

// node_modules/devextreme/esm/__internal/core/r1/utils/subscribe_to_event.js
function subscribeToEvent(eventName) {
  return (element, handler, eventData2, namespace) => {
    const event = namespace ? addNamespace2(eventName, namespace) : eventName;
    if (handler) {
      m_events_engine_default.on(element, event, eventData2, handler);
      return () => {
        m_events_engine_default.off(element, event, handler);
      };
    }
    return;
  };
}
var subscribeToClickEvent = subscribeToEvent(CLICK_EVENT_NAME);
var subscribeToScrollEvent = subscribeToEvent(m_emitter_gesture_scroll_default.scroll);
var subscribeToScrollInitEvent = subscribeToEvent(m_emitter_gesture_scroll_default.init);
var subscribeToDXScrollStartEvent = subscribeToEvent(m_emitter_gesture_scroll_default.start);
var subscribeToDXScrollMoveEvent = subscribeToEvent(m_emitter_gesture_scroll_default.move);
var subscribeToDXScrollEndEvent = subscribeToEvent(m_emitter_gesture_scroll_default.end);
var subscribeToDXScrollStopEvent = subscribeToEvent(m_emitter_gesture_scroll_default.stop);
var subscribeToDXScrollCancelEvent = subscribeToEvent(m_emitter_gesture_scroll_default.cancel);
var subscribeToDXPointerDownEvent = subscribeToEvent(m_pointer_default.down);
var subscribeToDXPointerUpEvent = subscribeToEvent(m_pointer_default.up);
var subscribeToDXPointerMoveEvent = subscribeToEvent(m_pointer_default.move);
var subscribeToMouseEnterEvent = subscribeToEvent("mouseenter");
var subscribeToMouseLeaveEvent = subscribeToEvent("mouseleave");
var subscribeToKeyDownEvent = subscribeToEvent("keydown");
var subscribeToDxActiveEvent = subscribeToEvent("dxactive");
var subscribeToDxInactiveEvent = subscribeToEvent("dxinactive");
var subscribeToDxHoverStartEvent = subscribeToEvent("dxhoverstart");
var subscribeToDxHoverEndEvent = subscribeToEvent("dxhoverend");
var subscribeToDxFocusInEvent = subscribeToEvent("focusin");
var subscribeToDxFocusOutEvent = subscribeToEvent("focusout");

// node_modules/devextreme/esm/__internal/core/r1/widget.js
var WIDGET_CLASS = "dx-widget";
var getAria = (args) => Object.keys(args).reduce((r, key) => {
  if (args[key]) {
    return _extends({}, r, {
      ["role" === key || "id" === key ? key : `aria-${key}`]: String(args[key])
    });
  }
  return r;
}, {});
var WidgetDefaultProps = _extends({}, BaseWidgetDefaultProps, {
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: {},
  classes: "",
  name: "",
  addWidgetClass: true
});
var Widget2 = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.state = {
      active: false,
      focused: false,
      hovered: false
    };
    this.refs = null;
    this.rootElementRef = createRef();
    this.widgetElementRef = createRef();
    this.setRootElementRef = this.setRootElementRef.bind(this);
    this.activeEffect = this.activeEffect.bind(this);
    this.inactiveEffect = this.inactiveEffect.bind(this);
    this.clickEffect = this.clickEffect.bind(this);
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.focusInEffect = this.focusInEffect.bind(this);
    this.focusOutEffect = this.focusOutEffect.bind(this);
    this.hoverStartEffect = this.hoverStartEffect.bind(this);
    this.hoverEndEffect = this.hoverEndEffect.bind(this);
    this.keyboardEffect = this.keyboardEffect.bind(this);
    this.resizeEffect = this.resizeEffect.bind(this);
    this.windowResizeEffect = this.windowResizeEffect.bind(this);
    this.visibilityEffect = this.visibilityEffect.bind(this);
    this.checkDeprecation = this.checkDeprecation.bind(this);
    this.applyCssTextEffect = this.applyCssTextEffect.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate(nextProps, nextState, context2);
  }
  getConfig() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, []), new InfernoEffect(this.activeEffect, [this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]), new InfernoEffect(this.inactiveEffect, [this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]), new InfernoEffect(this.clickEffect, [this.props.disabled, this.props.name, this.props.onClick]), new InfernoEffect(this.focusInEffect, [this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]), new InfernoEffect(this.focusOutEffect, [this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]), new InfernoEffect(this.hoverStartEffect, [this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]), new InfernoEffect(this.hoverEndEffect, [this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]), new InfernoEffect(this.keyboardEffect, [this.props.focusStateEnabled, this.props.onKeyDown]), new InfernoEffect(this.resizeEffect, [this.props.name, this.props.onDimensionChanged]), new InfernoEffect(this.windowResizeEffect, [this.props.onDimensionChanged]), new InfernoEffect(this.visibilityEffect, [this.props.name, this.props.onVisibilityChange]), new InfernoEffect(this.checkDeprecation, [this.props.height, this.props.width]), new InfernoEffect(this.applyCssTextEffect, [this.props.cssText]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2, _this$_effects$3, _this$_effects$4, _this$_effects$5, _this$_effects$6, _this$_effects$7, _this$_effects$8, _this$_effects$9, _this$_effects$10, _this$_effects$11, _this$_effects$12, _this$_effects$13;
    null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]);
    null === (_this$_effects$2 = this._effects[2]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]);
    null === (_this$_effects$3 = this._effects[3]) || void 0 === _this$_effects$3 || _this$_effects$3.update([this.props.disabled, this.props.name, this.props.onClick]);
    null === (_this$_effects$4 = this._effects[4]) || void 0 === _this$_effects$4 || _this$_effects$4.update([this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]);
    null === (_this$_effects$5 = this._effects[5]) || void 0 === _this$_effects$5 || _this$_effects$5.update([this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]);
    null === (_this$_effects$6 = this._effects[6]) || void 0 === _this$_effects$6 || _this$_effects$6.update([this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]);
    null === (_this$_effects$7 = this._effects[7]) || void 0 === _this$_effects$7 || _this$_effects$7.update([this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]);
    null === (_this$_effects$8 = this._effects[8]) || void 0 === _this$_effects$8 || _this$_effects$8.update([this.props.focusStateEnabled, this.props.onKeyDown]);
    null === (_this$_effects$9 = this._effects[9]) || void 0 === _this$_effects$9 || _this$_effects$9.update([this.props.name, this.props.onDimensionChanged]);
    null === (_this$_effects$10 = this._effects[10]) || void 0 === _this$_effects$10 || _this$_effects$10.update([this.props.onDimensionChanged]);
    null === (_this$_effects$11 = this._effects[11]) || void 0 === _this$_effects$11 || _this$_effects$11.update([this.props.name, this.props.onVisibilityChange]);
    null === (_this$_effects$12 = this._effects[12]) || void 0 === _this$_effects$12 || _this$_effects$12.update([this.props.height, this.props.width]);
    null === (_this$_effects$13 = this._effects[13]) || void 0 === _this$_effects$13 || _this$_effects$13.update([this.props.cssText]);
  }
  setRootElementRef() {
    var _this$widgetElementRe;
    const {
      rootElementRef,
      onRootElementRendered
    } = this.props;
    if (rootElementRef && this.widgetElementRef) {
      rootElementRef.current = this.widgetElementRef.current;
    }
    if (null !== this && void 0 !== this && null !== (_this$widgetElementRe = this.widgetElementRef) && void 0 !== _this$widgetElementRe && _this$widgetElementRe.current) {
      null === onRootElementRendered || void 0 === onRootElementRendered || onRootElementRendered(this.widgetElementRef.current);
    }
  }
  activeEffect() {
    const {
      activeStateEnabled,
      activeStateUnit,
      disabled,
      _feedbackShowTimeout,
      onActive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      if (!disabled) {
        var _this$widgetElementRe2;
        return subscribeToDxActiveEvent(null === (_this$widgetElementRe2 = this.widgetElementRef) || void 0 === _this$widgetElementRe2 ? void 0 : _this$widgetElementRe2.current, (event) => {
          this.setState({
            active: true
          });
          null === onActive || void 0 === onActive || onActive(event);
        }, {
          timeout: _feedbackShowTimeout,
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  inactiveEffect() {
    const {
      activeStateEnabled,
      activeStateUnit,
      _feedbackHideTimeout,
      onInactive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      var _this$widgetElementRe3;
      return subscribeToDxInactiveEvent(null === (_this$widgetElementRe3 = this.widgetElementRef) || void 0 === _this$widgetElementRe3 ? void 0 : _this$widgetElementRe3.current, (event) => {
        if (this.state.active) {
          this.setState({
            active: false
          });
          null === onInactive || void 0 === onInactive || onInactive(event);
        }
      }, {
        timeout: _feedbackHideTimeout,
        selector
      }, "UIFeedback");
    }
    return;
  }
  clickEffect() {
    const {
      name: name2,
      onClick,
      disabled
    } = this.props;
    const namespace = name2;
    if (onClick && !disabled) {
      var _this$widgetElementRe4;
      dxClick.on(null === (_this$widgetElementRe4 = this.widgetElementRef) || void 0 === _this$widgetElementRe4 ? void 0 : _this$widgetElementRe4.current, onClick, {
        namespace
      });
      return () => {
        var _this$widgetElementRe5;
        return dxClick.off(null === (_this$widgetElementRe5 = this.widgetElementRef) || void 0 === _this$widgetElementRe5 ? void 0 : _this$widgetElementRe5.current, {
          namespace
        });
      };
    }
    return;
  }
  focusInEffect() {
    const {
      disabled,
      focusStateEnabled,
      name: name2,
      onFocusIn
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      if (!disabled) {
        var _this$widgetElementRe6;
        return subscribeToDxFocusInEvent(null === (_this$widgetElementRe6 = this.widgetElementRef) || void 0 === _this$widgetElementRe6 ? void 0 : _this$widgetElementRe6.current, (event) => {
          if (!event.isDefaultPrevented()) {
            this.setState({
              focused: true
            });
            null === onFocusIn || void 0 === onFocusIn || onFocusIn(event);
          }
        }, null, namespace);
      }
    }
    return;
  }
  focusOutEffect() {
    const {
      focusStateEnabled,
      name: name2,
      onFocusOut
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      var _this$widgetElementRe7;
      return subscribeToDxFocusOutEvent(null === (_this$widgetElementRe7 = this.widgetElementRef) || void 0 === _this$widgetElementRe7 ? void 0 : _this$widgetElementRe7.current, (event) => {
        if (!event.isDefaultPrevented() && this.state.focused) {
          this.setState({
            focused: false
          });
          null === onFocusOut || void 0 === onFocusOut || onFocusOut(event);
        }
      }, null, namespace);
    }
    return;
  }
  hoverStartEffect() {
    const {
      activeStateUnit,
      hoverStateEnabled,
      disabled,
      onHoverStart
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      if (!disabled) {
        var _this$widgetElementRe8;
        return subscribeToDxHoverStartEvent(null === (_this$widgetElementRe8 = this.widgetElementRef) || void 0 === _this$widgetElementRe8 ? void 0 : _this$widgetElementRe8.current, (event) => {
          if (!this.state.active) {
            this.setState({
              hovered: true
            });
          }
          null === onHoverStart || void 0 === onHoverStart || onHoverStart(event);
        }, {
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  hoverEndEffect() {
    const {
      activeStateUnit,
      hoverStateEnabled,
      onHoverEnd
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      var _this$widgetElementRe9;
      return subscribeToDxHoverEndEvent(null === (_this$widgetElementRe9 = this.widgetElementRef) || void 0 === _this$widgetElementRe9 ? void 0 : _this$widgetElementRe9.current, (event) => {
        if (this.state.hovered) {
          this.setState({
            hovered: false
          });
          null === onHoverEnd || void 0 === onHoverEnd || onHoverEnd(event);
        }
      }, {
        selector
      }, "UIFeedback");
    }
    return;
  }
  keyboardEffect() {
    const {
      onKeyDown,
      focusStateEnabled
    } = this.props;
    if (focusStateEnabled && onKeyDown) {
      var _this$widgetElementRe10, _this$widgetElementRe11;
      const id = keyboard.on(null === (_this$widgetElementRe10 = this.widgetElementRef) || void 0 === _this$widgetElementRe10 ? void 0 : _this$widgetElementRe10.current, null === (_this$widgetElementRe11 = this.widgetElementRef) || void 0 === _this$widgetElementRe11 ? void 0 : _this$widgetElementRe11.current, (e) => onKeyDown(e));
      return () => keyboard.off(id);
    }
    return;
  }
  resizeEffect() {
    const namespace = `${this.props.name}VisibilityChange`;
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      var _this$widgetElementRe12;
      resize.on(null === (_this$widgetElementRe12 = this.widgetElementRef) || void 0 === _this$widgetElementRe12 ? void 0 : _this$widgetElementRe12.current, onDimensionChanged, {
        namespace
      });
      return () => {
        var _this$widgetElementRe13;
        return resize.off(null === (_this$widgetElementRe13 = this.widgetElementRef) || void 0 === _this$widgetElementRe13 ? void 0 : _this$widgetElementRe13.current, {
          namespace
        });
      };
    }
    return;
  }
  windowResizeEffect() {
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      resize_callbacks_default.add(onDimensionChanged);
      return () => {
        resize_callbacks_default.remove(onDimensionChanged);
      };
    }
    return;
  }
  visibilityEffect() {
    const {
      name: name2,
      onVisibilityChange
    } = this.props;
    const namespace = `${name2}VisibilityChange`;
    if (onVisibilityChange) {
      var _this$widgetElementRe14;
      visibility.on(null === (_this$widgetElementRe14 = this.widgetElementRef) || void 0 === _this$widgetElementRe14 ? void 0 : _this$widgetElementRe14.current, () => onVisibilityChange(true), () => onVisibilityChange(false), {
        namespace
      });
      return () => {
        var _this$widgetElementRe15;
        return visibility.off(null === (_this$widgetElementRe15 = this.widgetElementRef) || void 0 === _this$widgetElementRe15 ? void 0 : _this$widgetElementRe15.current, {
          namespace
        });
      };
    }
    return;
  }
  checkDeprecation() {
    const {
      width,
      height
    } = this.props;
    if (isFunction(width)) {
      errors_default.log("W0017", "width");
    }
    if (isFunction(height)) {
      errors_default.log("W0017", "height");
    }
  }
  applyCssTextEffect() {
    var _this$widgetElementRe16;
    const {
      cssText
    } = this.props;
    if (void 0 !== cssText && "" !== cssText && null !== (_this$widgetElementRe16 = this.widgetElementRef) && void 0 !== _this$widgetElementRe16 && _this$widgetElementRe16.current) {
      this.widgetElementRef.current.style.cssText = cssText;
    }
  }
  getShouldRenderConfigProvider() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabledDefinition(rtlEnabled, this.config);
  }
  getRtlEnabled() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabled(rtlEnabled, this.config);
  }
  getAttributes() {
    const {
      aria,
      disabled,
      focusStateEnabled,
      visible: visible2
    } = this.props;
    const accessKey = focusStateEnabled && !disabled && this.props.accessKey;
    const props = _extends({}, extend({}, accessKey && {
      accessKey
    }), getAria(_extends({}, aria, {
      disabled,
      hidden: !visible2
    })), extend({}, this.getRestAttributes(this.props)));
    return props;
  }
  getRestAttributes(props) {
    const result2 = _extends({}, props);
    ["_feedbackHideTimeout", "_feedbackShowTimeout", "accessKey", "activeStateEnabled", "activeStateUnit", "addWidgetClass", "aria", "children", "className", "classes", "cssText", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "name", "onActive", "onClick", "onDimensionChanged", "onFocusIn", "onFocusOut", "onHoverEnd", "onHoverStart", "onInactive", "onKeyDown", "onRootElementRendered", "onVisibilityChange", "rootElementRef", "rtlEnabled", "tabIndex", "visible", "width"].forEach((exclude) => {
      delete result2[exclude];
    });
    return result2;
  }
  getStyles() {
    const {
      width,
      height
    } = this.props;
    const style = this.props.style || {};
    const computedWidth = normalizeStyleProp("width", isFunction(width) ? width() : width);
    const computedHeight = normalizeStyleProp("height", isFunction(height) ? height() : height);
    return _extends({}, style, {
      height: computedHeight ?? style.height,
      width: computedWidth ?? style.width
    });
  }
  getCssClasses() {
    const {
      classes,
      addWidgetClass,
      className,
      disabled,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled,
      onVisibilityChange,
      visible: visible2
    } = this.props;
    const isFocusable = !!focusStateEnabled && !disabled;
    const isHoverable = !!hoverStateEnabled && !disabled;
    const canBeActive = !!activeStateEnabled && !disabled;
    const classesMap = {
      [WIDGET_CLASS]: !!addWidgetClass,
      [String(classes)]: !!classes,
      [String(className)]: !!className,
      "dx-state-disabled": !!disabled,
      "dx-state-invisible": !visible2,
      "dx-state-focused": !!this.state.focused && isFocusable,
      "dx-state-active": !!this.state.active && canBeActive,
      "dx-state-hover": !!this.state.hovered && isHoverable && !this.state.active,
      "dx-rtl": !!this.props.rtlEnabled,
      "dx-visibility-change-handler": !!onVisibilityChange
    };
    return combineClasses(classesMap);
  }
  getTabIndex() {
    const {
      focusStateEnabled,
      disabled,
      tabIndex
    } = this.props;
    const isFocusable = focusStateEnabled && !disabled;
    return isFocusable ? tabIndex : void 0;
  }
  focus() {
    var _this$widgetElementRe17;
    focus.trigger(null === (_this$widgetElementRe17 = this.widgetElementRef) || void 0 === _this$widgetElementRe17 ? void 0 : _this$widgetElementRe17.current);
  }
  blur() {
    var _this$widgetElementRe18, _this$widgetElementRe19;
    const activeElement = dom_adapter_default.getActiveElement(null === (_this$widgetElementRe18 = this.widgetElementRef) || void 0 === _this$widgetElementRe18 ? void 0 : _this$widgetElementRe18.current);
    if ((null === (_this$widgetElementRe19 = this.widgetElementRef) || void 0 === _this$widgetElementRe19 ? void 0 : _this$widgetElementRe19.current) === activeElement) {
      activeElement.blur();
    }
  }
  activate() {
    this.setState({
      active: true
    });
  }
  deactivate() {
    this.setState({
      active: false
    });
  }
  render() {
    const {
      hint,
      children
    } = this.props;
    const widget = normalizeProps(createVNode(1, "div", this.getCssClasses(), children, 0, _extends({}, this.getAttributes(), {
      tabindex: this.getTabIndex(),
      title: hint,
      style: this.getStyles()
    }), null, this.widgetElementRef));
    return this.getShouldRenderConfigProvider() ? createComponentVNode(2, ConfigProvider, {
      rtlEnabled: this.getRtlEnabled(),
      children: widget
    }) : widget;
  }
};
Widget2.defaultProps = WidgetDefaultProps;

// node_modules/devextreme/esm/__internal/core/utils/combine_classes.js
function combineClasses2(classesMap) {
  return Object.keys(classesMap).filter((p2) => classesMap[p2]).join(" ");
}

// node_modules/devextreme/esm/__internal/ui/button/icon.js
var defaultIconProps = {
  position: "left",
  source: ""
};
var Icon = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  get sourceType() {
    return getImageSourceType(this.props.source);
  }
  get cssClass() {
    return "left" !== this.props.position ? "dx-icon-right" : "";
  }
  get iconClassName() {
    const generalClasses = {
      "dx-icon": true,
      [this.cssClass]: !!this.cssClass
    };
    const {
      source
    } = this.props;
    if ("dxIcon" === this.sourceType) {
      return combineClasses2(_extends({}, generalClasses, {
        [`dx-icon-${source}`]: true
      }));
    }
    if ("fontIcon" === this.sourceType) {
      return combineClasses2(_extends({}, generalClasses, {
        [String(source)]: !!source
      }));
    }
    if ("image" === this.sourceType) {
      return combineClasses2(generalClasses);
    }
    if ("svg" === this.sourceType) {
      return combineClasses2(_extends({}, generalClasses, {
        "dx-svg-icon": true
      }));
    }
    return "";
  }
  render() {
    const {
      iconClassName,
      props,
      sourceType
    } = this;
    const IconTemplate = getTemplate(props.iconTemplate);
    return createFragment(["dxIcon" === sourceType && createVNode(1, "i", iconClassName), "fontIcon" === sourceType && createVNode(1, "i", iconClassName), "image" === sourceType && createVNode(1, "img", iconClassName, null, 1, {
      alt: "",
      src: props.source
    }), IconTemplate && createVNode(1, "i", iconClassName, IconTemplate({}), 0)], 0);
  }
};
Icon.defaultProps = defaultIconProps;

// node_modules/devextreme/esm/ui/widget/utils.ink_ripple.js
var initConfig = function() {
  let config3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  const {
    useHoldAnimation,
    waveSizeCoefficient,
    isCentered,
    wavesNumber
  } = config3;
  return {
    waveSizeCoefficient: waveSizeCoefficient || 2,
    isCentered: isCentered || false,
    wavesNumber: wavesNumber || 1,
    durations: getDurations(useHoldAnimation ?? true)
  };
};
var getInkRipple = function(element) {
  let result2 = element.children(".dx-inkripple");
  if (0 === result2.length) {
    result2 = renderer_default("<div>").addClass("dx-inkripple").appendTo(element);
  }
  return result2;
};
var getWaves = function(element, wavesNumber) {
  const inkRipple = getInkRipple(renderer_default(element));
  const result2 = inkRipple.children(".dx-inkripple-wave").toArray();
  for (let i = result2.length; i < wavesNumber; i++) {
    const $currentWave = renderer_default("<div>").appendTo(inkRipple).addClass("dx-inkripple-wave");
    result2.push($currentWave[0]);
  }
  return renderer_default(result2);
};
var getWaveStyleConfig = function(args, config3) {
  const element = renderer_default(config3.element);
  const elementWidth = getOuterWidth(element);
  const elementHeight = getOuterHeight(element);
  const elementDiagonal = parseInt(Math.sqrt(elementWidth * elementWidth + elementHeight * elementHeight));
  const waveSize = Math.min(4e3, parseInt(elementDiagonal * args.waveSizeCoefficient));
  let left;
  let top;
  if (args.isCentered) {
    left = (elementWidth - waveSize) / 2;
    top = (elementHeight - waveSize) / 2;
  } else {
    const event = config3.event;
    const position2 = element.offset();
    const x = event.pageX - position2.left;
    const y = event.pageY - position2.top;
    left = x - waveSize / 2;
    top = y - waveSize / 2;
  }
  return {
    left,
    top,
    height: waveSize,
    width: waveSize
  };
};
function showWave(args, config3) {
  const $wave = getWaves(config3.element, args.wavesNumber).eq(config3.wave || 0);
  args.hidingTimeout && clearTimeout(args.hidingTimeout);
  hideSelectedWave($wave);
  $wave.css(getWaveStyleConfig(args, config3));
  args.showingTimeout = setTimeout(showingWaveHandler.bind(this, args, $wave), 0);
}
function showingWaveHandler(args, $wave) {
  const durationCss = args.durations.showingScale + "ms";
  $wave.addClass("dx-inkripple-showing").css("transitionDuration", durationCss);
}
function getDurations(useHoldAnimation) {
  return {
    showingScale: useHoldAnimation ? 1e3 : 300,
    hidingScale: 300,
    hidingOpacity: 300
  };
}
function hideSelectedWave($wave) {
  $wave.removeClass("dx-inkripple-hiding").css("transitionDuration", "");
}
function hideWave(args, config3) {
  args.showingTimeout && clearTimeout(args.showingTimeout);
  const $wave = getWaves(config3.element, config3.wavesNumber).eq(config3.wave || 0);
  const durations = args.durations;
  const durationCss = durations.hidingScale + "ms, " + durations.hidingOpacity + "ms";
  $wave.addClass("dx-inkripple-hiding").removeClass("dx-inkripple-showing").css("transitionDuration", durationCss);
  const animationDuration = Math.max(durations.hidingScale, durations.hidingOpacity);
  args.hidingTimeout = setTimeout(hideSelectedWave.bind(this, $wave), animationDuration);
}

// node_modules/devextreme/esm/__internal/ui/button/ink_ripple.js
var _excluded4 = ["config"];
var defaultInkRippleProps = {
  config: {}
};
var InkRipple = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.__getterCache = {};
    this.state = {};
    this.hideWave = this.hideWave.bind(this);
    this.showWave = this.showWave.bind(this);
  }
  get getConfig() {
    if (void 0 === this.__getterCache.getConfig) {
      this.__getterCache.getConfig = initConfig(this.props.config);
    }
    return this.__getterCache.getConfig;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded4);
    return restProps;
  }
  hideWave(opts) {
    hideWave(this.getConfig, opts);
  }
  showWave(opts) {
    showWave(this.getConfig, opts);
  }
  componentWillUpdate(nextProps) {
    if (this.props.config !== nextProps.config) {
      this.__getterCache.getConfig = void 0;
    }
  }
  render() {
    return normalizeProps(createVNode(1, "div", "dx-inkripple", null, 1, _extends({}, this.restAttributes)));
  }
};
InkRipple.defaultProps = defaultInkRippleProps;

// node_modules/devextreme/esm/__internal/ui/button/button.js
var BUTTON_CLASS = "dx-button";
var stylingModes = ["outlined", "text", "contained"];
var buttonComponentProps = ["accessKey", "activeStateEnabled", "className", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "icon", "iconPosition", "iconTemplate", "onClick", "onKeyDown", "onSubmit", "pressed", "rtlEnabled", "stylingMode", "tabIndex", "template", "templateData", "text", "type", "useInkRipple", "useSubmitBehavior", "visible", "width"];
var getCssClasses2 = (model) => {
  const {
    icon,
    iconPosition,
    stylingMode,
    text,
    type: type2
  } = model;
  const isValidStylingMode = stylingMode && stylingModes.includes(stylingMode);
  const classesMap = {
    [BUTTON_CLASS]: true,
    [`dx-button-mode-${isValidStylingMode ? stylingMode : "contained"}`]: true,
    [`dx-button-${type2 ?? "normal"}`]: true,
    "dx-button-has-text": !!text,
    "dx-button-has-icon": !!icon,
    "dx-button-icon-right": "left" !== iconPosition
  };
  return combineClasses2(classesMap);
};
var omit = (obj, excludedKeys) => {
  const excludedSet = new Set(excludedKeys);
  return Object.keys(obj).reduce((result2, key) => {
    if (!excludedSet.has(key)) {
      result2[key] = obj[key];
    }
    return result2;
  }, {});
};
var defaultButtonProps = _extends({}, BaseWidgetDefaultProps, {
  activeStateEnabled: true,
  hoverStateEnabled: true,
  icon: "",
  iconPosition: "left",
  stylingMode: "contained",
  text: "",
  type: "normal",
  useInkRipple: false,
  useSubmitBehavior: false,
  templateData: {}
});
var defaultOptionRules = createDefaultOptionRules([{
  device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
  options: {
    focusStateEnabled: true
  }
}, {
  device: () => isMaterial(current()),
  options: {
    useInkRipple: true
  }
}]);
var Button = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.contentRef = createRef();
    this.inkRippleRef = createRef();
    this.submitInputRef = createRef();
    this.widgetRef = createRef();
    this.__getterCache = {};
    this.state = {};
    this.focus = this.focus.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.submitEffect = this.submitEffect.bind(this);
    this.onActive = this.onActive.bind(this);
    this.onInactive = this.onInactive.bind(this);
    this.onWidgetClick = this.onWidgetClick.bind(this);
    this.keyDown = this.keyDown.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.submitEffect, [this.props.onSubmit, this.props.useSubmitBehavior]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props.onSubmit, this.props.useSubmitBehavior]);
  }
  submitEffect() {
    const {
      onSubmit,
      useSubmitBehavior
    } = this.props;
    const submitInput = this.submitInputRef.current;
    if (useSubmitBehavior && onSubmit) {
      click.on(submitInput, (event) => onSubmit({
        event,
        submitInput
      }), {
        namespace: "UIFeedback"
      });
      return () => click.off(submitInput, {
        namespace: "UIFeedback"
      });
    }
    return;
  }
  onActive(event) {
    if (this.props.useInkRipple) {
      var _this$inkRippleRef$cu;
      null === (_this$inkRippleRef$cu = this.inkRippleRef.current) || void 0 === _this$inkRippleRef$cu || _this$inkRippleRef$cu.showWave({
        element: this.contentRef.current,
        event
      });
    }
  }
  onInactive(event) {
    if (this.props.useInkRipple) {
      var _this$inkRippleRef$cu2;
      null === (_this$inkRippleRef$cu2 = this.inkRippleRef.current) || void 0 === _this$inkRippleRef$cu2 || _this$inkRippleRef$cu2.hideWave({
        element: this.contentRef.current,
        event
      });
    }
  }
  onWidgetClick(event) {
    const {
      onClick,
      useSubmitBehavior
    } = this.props;
    null === onClick || void 0 === onClick || onClick({
      event
    });
    if (useSubmitBehavior) {
      var _this$submitInputRef$;
      null === (_this$submitInputRef$ = this.submitInputRef.current) || void 0 === _this$submitInputRef$ || _this$submitInputRef$.click();
    }
  }
  keyDown(e) {
    const {
      onKeyDown
    } = this.props;
    const {
      keyName,
      originalEvent,
      which
    } = e;
    const result2 = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);
    if (null !== result2 && void 0 !== result2 && result2.cancel) {
      return result2;
    }
    if ("space" === keyName || "space" === which || "enter" === keyName || "enter" === which) {
      originalEvent.preventDefault();
      this.onWidgetClick(originalEvent);
    }
    return;
  }
  get aria() {
    const {
      icon,
      text
    } = this.props;
    let label = text ?? "";
    if (!text && icon) {
      const iconSource = getImageSourceType(icon);
      switch (iconSource) {
        case "image": {
          const notURLRegexp = /^(?!(?:https?:\/\/)|(?:ftp:\/\/)|(?:www\.))[^\s]+$/;
          const isPathToImage = !icon.includes("base64") && notURLRegexp.test(icon);
          label = isPathToImage ? icon.replace(/.+\/([^.]+)\..+$/, "$1") : "";
          break;
        }
        case "dxIcon":
          label = message_default.format(camelize(icon, true)) || icon;
          break;
        case "fontIcon":
          label = icon;
          break;
        case "svg": {
          var _titleRegexp$exec;
          const titleRegexp = /<title>(.*?)<\/title>/;
          label = (null === (_titleRegexp$exec = titleRegexp.exec(icon)) || void 0 === _titleRegexp$exec ? void 0 : _titleRegexp$exec[1]) ?? "";
          break;
        }
      }
    }
    return _extends({
      role: "button"
    }, label ? {
      label
    } : {});
  }
  get cssClasses() {
    return getCssClasses2(this.props);
  }
  get iconSource() {
    return this.props.icon ?? "";
  }
  get inkRippleConfig() {
    if (void 0 === this.__getterCache.inkRippleConfig) {
      const {
        icon,
        text
      } = this.props;
      this.__getterCache.inkRippleConfig = !text && icon ? {
        isCentered: true,
        useHoldAnimation: false,
        waveSizeCoefficient: 1
      } : {};
    }
    return this.__getterCache.inkRippleConfig;
  }
  get buttonTemplateData() {
    const {
      icon,
      text,
      templateData
    } = this.props;
    return _extends({
      icon,
      text
    }, templateData);
  }
  get restAttributes() {
    const excludedKeys = [...buttonComponentProps, "children"];
    return omit(this.props, excludedKeys);
  }
  focus() {
    var _this$widgetRef$curre;
    null === (_this$widgetRef$curre = this.widgetRef.current) || void 0 === _this$widgetRef$curre || _this$widgetRef$curre.focus();
  }
  activate() {
    var _this$widgetRef$curre2;
    null === (_this$widgetRef$curre2 = this.widgetRef.current) || void 0 === _this$widgetRef$curre2 || _this$widgetRef$curre2.activate();
  }
  deactivate() {
    var _this$widgetRef$curre3;
    null === (_this$widgetRef$curre3 = this.widgetRef.current) || void 0 === _this$widgetRef$curre3 || _this$widgetRef$curre3.deactivate();
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.icon !== nextProps.icon || this.props.text !== nextProps.text) {
      this.__getterCache.inkRippleConfig = void 0;
    }
  }
  render() {
    const {
      children,
      iconPosition,
      text
    } = this.props;
    const ButtonTemplate = getTemplate(this.props.template);
    const IconTemplate = getTemplate(this.props.iconTemplate);
    const renderText = !this.props.template && !children && "" !== text;
    const isIconLeft = "left" === iconPosition;
    const iconComponent = !ButtonTemplate && !children && (this.iconSource || IconTemplate) && createComponentVNode(2, Icon, {
      source: this.iconSource,
      position: iconPosition,
      iconTemplate: IconTemplate
    });
    return normalizeProps(createComponentVNode(2, Widget2, _extends({
      accessKey: this.props.accessKey,
      activeStateEnabled: this.props.activeStateEnabled,
      aria: this.aria,
      className: this.props.className,
      classes: this.cssClasses,
      disabled: this.props.disabled,
      focusStateEnabled: this.props.focusStateEnabled,
      height: this.props.height,
      hint: this.props.hint,
      hoverStateEnabled: this.props.hoverStateEnabled,
      onActive: this.onActive,
      onClick: this.onWidgetClick,
      onInactive: this.onInactive,
      onKeyDown: this.keyDown,
      rtlEnabled: this.props.rtlEnabled,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible,
      width: this.props.width
    }, this.restAttributes, {
      children: createVNode(1, "div", "dx-button-content", [ButtonTemplate ? ButtonTemplate({
        data: this.buttonTemplateData
      }) : children, isIconLeft && iconComponent, renderText && createVNode(1, "span", "dx-button-text", text, 0), !isIconLeft && iconComponent, this.props.useSubmitBehavior && createVNode(64, "input", "dx-button-submit-input", null, 1, {
        type: "submit",
        tabindex: -1
      }, null, this.submitInputRef), this.props.useInkRipple && createComponentVNode(2, InkRipple, {
        config: this.inkRippleConfig
      }, null, this.inkRippleRef)], 0, null, null, this.contentRef)
    }), null, this.widgetRef));
  }
};
Button.defaultProps = _extends({}, defaultButtonProps, convertRulesToOptions(defaultOptionRules));
var __defaultOptionRules = [];
function defaultOptions(rule) {
  __defaultOptionRules.push(rule);
  Button.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(Button.defaultProps), Object.getOwnPropertyDescriptors(convertRulesToOptions(defaultOptionRules)), Object.getOwnPropertyDescriptors(convertRulesToOptions(__defaultOptionRules))));
}

// node_modules/devextreme/esm/__internal/ui/button/wrapper.js
var Button2 = class extends ComponentWrapper {
  get _validationGroupConfig() {
    return validation_engine_default.getGroupConfig(this._findGroup());
  }
  getDefaultTemplateNames() {
    return ["content"];
  }
  getSupportedKeyNames() {
    return ["space", "enter"];
  }
  getProps() {
    const props = super.getProps();
    props.onClick = (_ref) => {
      let {
        event
      } = _ref;
      this._clickAction({
        event,
        validationGroup: this._validationGroupConfig
      });
    };
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    const iconType = getImageSourceType(props.icon);
    if ("svg" === iconType) {
      props.iconTemplate = this._createTemplateComponent(() => props.icon);
    }
    return props;
  }
  get viewRef() {
    return super.viewRef;
  }
  get _templatesInfo() {
    return {
      template: "content"
    };
  }
  _toggleActiveState(_, value2) {
    if (value2) {
      var _this$viewRef;
      null === (_this$viewRef = this.viewRef) || void 0 === _this$viewRef || _this$viewRef.activate();
    } else {
      var _this$viewRef2;
      null === (_this$viewRef2 = this.viewRef) || void 0 === _this$viewRef2 || _this$viewRef2.deactivate();
    }
  }
  _getSubmitAction() {
    let needValidate = true;
    let validationStatus = "valid";
    return this._createAction((_ref2) => {
      let {
        event,
        submitInput
      } = _ref2;
      if (needValidate) {
        const validationGroup = this._validationGroupConfig;
        if (void 0 !== validationGroup && "" !== validationGroup) {
          const validationResult = validationGroup.validate();
          validationStatus = validationResult.status;
          if ("pending" === validationResult.status) {
            needValidate = false;
            this.option("disabled", true);
            validationResult.complete.then((_ref3) => {
              let {
                status
              } = _ref3;
              this.option("disabled", false);
              validationStatus = status;
              if ("valid" === validationStatus) {
                submitInput.click();
              }
              needValidate = true;
            });
          }
        }
      }
      if ("valid" !== validationStatus) {
        event.preventDefault();
      }
      event.stopPropagation();
    });
  }
  _initializeComponent() {
    super._initializeComponent();
    this._addAction("onSubmit", this._getSubmitAction());
    this._clickAction = this._createClickAction();
  }
  _initMarkup() {
    super._initMarkup();
    const $content = this.$element().find(".dx-button-content").first();
    const $template = $content.children().filter(".dx-template-wrapper");
    const $input = $content.children().filter(".dx-button-submit-input");
    if ($template.length) {
      $template.addClass("dx-button-content");
      $template.append($input);
      $content.replaceWith($template);
    }
  }
  _patchOptionValues(options2) {
    return super._patchOptionValues(_extends({}, options2, {
      templateData: options2._templateData
    }));
  }
  _findGroup() {
    const $element = this.$element();
    const validationGroup = this.option("validationGroup");
    return void 0 !== validationGroup && "" !== validationGroup ? validationGroup : validation_engine_default.findGroup($element, this._modelByElement($element));
  }
  _createClickAction() {
    return this._createActionByOption("onClick", {
      excludeValidators: ["readOnly"]
    });
  }
  _optionChanged(option) {
    if ("onClick" === option.name) {
      this._clickAction = this._createClickAction();
    }
    super._optionChanged(option);
  }
  focus() {
    var _this$viewRef3;
    null === (_this$viewRef3 = this.viewRef) || void 0 === _this$viewRef3 || _this$viewRef3.focus();
  }
  activate() {
    var _this$viewRef4;
    null === (_this$viewRef4 = this.viewRef) || void 0 === _this$viewRef4 || _this$viewRef4.activate();
  }
  deactivate() {
    var _this$viewRef5;
    null === (_this$viewRef5 = this.viewRef) || void 0 === _this$viewRef5 || _this$viewRef5.deactivate();
  }
  _getActionConfigs() {
    return {
      onClick: {
        excludeValidators: ["readOnly"]
      },
      onSubmit: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: ["onSubmit"],
      templates: ["template", "iconTemplate"],
      props: buttonComponentProps
    };
  }
  get _viewComponent() {
    return Button;
  }
};
component_registrator_default("dxButton", Button2);
Button2.defaultOptions = defaultOptions;

// node_modules/devextreme/esm/__internal/ui/button/index.js
var button_default = Button2;

// node_modules/devextreme/esm/ui/button.js
var button_default2 = button_default;

// node_modules/devextreme/esm/__internal/events/m_drag.js
var DRAG_START_EVENT = "dxdragstart";
var DRAG_EVENT = "dxdrag";
var DRAG_END_EVENT = "dxdragend";
var DRAG_ENTER_EVENT = "dxdragenter";
var DRAG_LEAVE_EVENT = "dxdragleave";
var DROP_EVENT = "dxdrop";
var knownDropTargets = [];
var knownDropTargetSelectors = [];
var knownDropTargetConfigs = [];
var dropTargetRegistration = {
  setup(element, data2) {
    const knownDropTarget = knownDropTargets.includes(element);
    if (!knownDropTarget) {
      knownDropTargets.push(element);
      knownDropTargetSelectors.push([]);
      knownDropTargetConfigs.push(data2 || {});
    }
  },
  add(element, handleObj) {
    const index2 = knownDropTargets.indexOf(element);
    this.updateEventsCounter(element, handleObj.type, 1);
    const {
      selector
    } = handleObj;
    if (!knownDropTargetSelectors[index2].includes(selector)) {
      knownDropTargetSelectors[index2].push(selector);
    }
  },
  updateEventsCounter(element, event, value2) {
    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].includes(event)) {
      const eventsCount = data(element, "dxDragEventsCount") || 0;
      data(element, "dxDragEventsCount", Math.max(0, eventsCount + value2));
    }
  },
  remove(element, handleObj) {
    this.updateEventsCounter(element, handleObj.type, -1);
  },
  teardown(element) {
    const handlersCount = data(element, "dxDragEventsCount");
    if (!handlersCount) {
      const index2 = knownDropTargets.indexOf(element);
      knownDropTargets.splice(index2, 1);
      knownDropTargetSelectors.splice(index2, 1);
      knownDropTargetConfigs.splice(index2, 1);
      removeData(element, "dxDragEventsCount");
    }
  }
};
m_event_registrator_default(DRAG_ENTER_EVENT, dropTargetRegistration);
m_event_registrator_default(DRAG_LEAVE_EVENT, dropTargetRegistration);
m_event_registrator_default(DROP_EVENT, dropTargetRegistration);
var getItemDelegatedTargets = function($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  const dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter((selector) => selector);
  let $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
  if (knownDropTargetSelectors[dropTargetIndex].includes(void 0)) {
    $delegatedTargets = $delegatedTargets.add($element);
  }
  return $delegatedTargets;
};
var getItemConfig = function($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  return knownDropTargetConfigs[dropTargetIndex];
};
var getItemPosition = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemPositionFunc) {
    return dropTargetConfig.itemPositionFunc($element);
  }
  return $element.offset();
};
var getItemSize = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemSizeFunc) {
    return dropTargetConfig.itemSizeFunc($element);
  }
  return {
    width: $element.get(0).getBoundingClientRect().width,
    height: $element.get(0).getBoundingClientRect().height
  };
};
var DragEmitter = m_emitter_gesture_default.inherit({
  ctor(element) {
    this.callBase(element);
    this.direction = "both";
  },
  _init(e) {
    this._initEvent = e;
  },
  _start(e) {
    e = this._fireEvent("dxdragstart", this._initEvent);
    this._maxLeftOffset = e.maxLeftOffset;
    this._maxRightOffset = e.maxRightOffset;
    this._maxTopOffset = e.maxTopOffset;
    this._maxBottomOffset = e.maxBottomOffset;
    if (e.targetElements || null === e.targetElements) {
      const dropTargets = wrapToArray(e.targetElements || []);
      this._dropTargets = map(dropTargets, (element) => renderer_default(element).get(0));
    } else {
      this._dropTargets = knownDropTargets;
    }
  },
  _move(e) {
    const eventData2 = eventData(e);
    const dragOffset = this._calculateOffset(eventData2);
    e = this._fireEvent("dxdrag", e, {
      offset: dragOffset
    });
    this._processDropTargets(e);
    if (!e._cancelPreventDefault) {
      e.preventDefault();
    }
  },
  _calculateOffset(eventData2) {
    return {
      x: this._calculateXOffset(eventData2),
      y: this._calculateYOffset(eventData2)
    };
  },
  _calculateXOffset(eventData2) {
    if ("vertical" !== this.direction) {
      const offset2 = eventData2.x - this._startEventData.x;
      return this._fitOffset(offset2, this._maxLeftOffset, this._maxRightOffset);
    }
    return 0;
  },
  _calculateYOffset(eventData2) {
    if ("horizontal" !== this.direction) {
      const offset2 = eventData2.y - this._startEventData.y;
      return this._fitOffset(offset2, this._maxTopOffset, this._maxBottomOffset);
    }
    return 0;
  },
  _fitOffset(offset2, minOffset, maxOffset) {
    if (null != minOffset) {
      offset2 = Math.max(offset2, -minOffset);
    }
    if (null != maxOffset) {
      offset2 = Math.min(offset2, maxOffset);
    }
    return offset2;
  },
  _processDropTargets(e) {
    const target = this._findDropTarget(e);
    const sameTarget = target === this._currentDropTarget;
    if (!sameTarget) {
      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
      this._currentDropTarget = target;
      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);
    }
  },
  _fireDropTargetEvent(event, eventName) {
    if (!this._currentDropTarget) {
      return;
    }
    const eventData2 = {
      type: eventName,
      originalEvent: event,
      draggingElement: this._$element.get(0),
      target: this._currentDropTarget
    };
    fireEvent(eventData2);
  },
  _findDropTarget(e) {
    const that = this;
    let result2;
    each(knownDropTargets, (_, target) => {
      if (!that._checkDropTargetActive(target)) {
        return;
      }
      const $target = renderer_default(target);
      each(getItemDelegatedTargets($target), (_2, delegatedTarget) => {
        const $delegatedTarget = renderer_default(delegatedTarget);
        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, renderer_default(result2), e)) {
          result2 = delegatedTarget;
        }
      });
    });
    return result2;
  },
  _checkDropTargetActive(target) {
    let active2 = false;
    each(this._dropTargets, (_, activeTarget) => {
      active2 = active2 || activeTarget === target || contains2(activeTarget, target);
      return !active2;
    });
    return active2;
  },
  _checkDropTarget(config3, $target, $prevTarget, e) {
    const isDraggingElement = $target.get(0) === renderer_default(e.target).get(0);
    if (isDraggingElement) {
      return false;
    }
    const targetPosition = getItemPosition(config3, $target);
    if (e.pageX < targetPosition.left) {
      return false;
    }
    if (e.pageY < targetPosition.top) {
      return false;
    }
    const targetSize = getItemSize(config3, $target);
    if (e.pageX > targetPosition.left + targetSize.width) {
      return false;
    }
    if (e.pageY > targetPosition.top + targetSize.height) {
      return false;
    }
    if ($prevTarget.length && $prevTarget.closest($target).length) {
      return false;
    }
    if (config3.checkDropTarget && !config3.checkDropTarget($target, e)) {
      return false;
    }
    return $target;
  },
  _end(e) {
    const eventData2 = eventData(e);
    this._fireEvent("dxdragend", e, {
      offset: this._calculateOffset(eventData2)
    });
    this._fireDropTargetEvent(e, DROP_EVENT);
    delete this._currentDropTarget;
  }
});
m_emitter_registrator_default({
  emitter: DragEmitter,
  events: ["dxdragstart", "dxdrag", "dxdragend"]
});

// node_modules/devextreme/esm/__internal/ui/resizable/m_resizable.js
var RESIZABLE = "dxResizable";
var DRAGSTART_START_EVENT_NAME = addNamespace2(DRAG_START_EVENT, RESIZABLE);
var DRAGSTART_EVENT_NAME = addNamespace2(DRAG_EVENT, RESIZABLE);
var DRAGSTART_END_EVENT_NAME = addNamespace2(DRAG_END_EVENT, RESIZABLE);
var SIDE_BORDER_WIDTH_STYLES = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};
var Resizable = class extends dom_component_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      handles: "all",
      step: "1",
      stepPrecision: "simple",
      minWidth: 30,
      maxWidth: 1 / 0,
      minHeight: 30,
      maxHeight: 1 / 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      roundStepValue: true,
      keepAspectRatio: true
    });
  }
  _init() {
    super._init();
    this.$element().addClass("dx-resizable");
  }
  _initMarkup() {
    super._initMarkup();
    this._renderHandles();
  }
  _render() {
    super._render();
    this._renderActions();
  }
  _renderActions() {
    this._resizeStartAction = this._createActionByOption("onResizeStart");
    this._resizeEndAction = this._createActionByOption("onResizeEnd");
    this._resizeAction = this._createActionByOption("onResize");
  }
  _renderHandles() {
    this._handles = [];
    const {
      handles
    } = this.option();
    if ("none" === handles || !handles) {
      return;
    }
    const directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
    const activeHandlesMap = {};
    each(directions, (index2, handleName) => {
      activeHandlesMap[handleName] = true;
      this._renderHandle(handleName);
    });
    activeHandlesMap.bottom && activeHandlesMap.right && this._renderHandle("corner-bottom-right");
    activeHandlesMap.bottom && activeHandlesMap.left && this._renderHandle("corner-bottom-left");
    activeHandlesMap.top && activeHandlesMap.right && this._renderHandle("corner-top-right");
    activeHandlesMap.top && activeHandlesMap.left && this._renderHandle("corner-top-left");
    this._attachEventHandlers();
  }
  _renderHandle(handleName) {
    const $handle = renderer_default("<div>").addClass("dx-resizable-handle").addClass(`dx-resizable-handle-${handleName}`).appendTo(this.$element());
    this._handles.push($handle);
  }
  _attachEventHandlers() {
    if (this.option("disabled")) {
      return;
    }
    const handlers = {};
    handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
    handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
    handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
    this._handles.forEach((handleElement) => {
      m_events_engine_default.on(handleElement, handlers, {
        direction: "both",
        immediate: true
      });
    });
  }
  _detachEventHandlers() {
    this._handles.forEach((handleElement) => {
      m_events_engine_default.off(handleElement);
    });
  }
  _toggleEventHandlers(shouldAttachEvents) {
    shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers();
  }
  _getElementSize() {
    const $element = this.$element();
    return "border-box" === $element.css("boxSizing") ? {
      width: getOuterWidth($element),
      height: getOuterHeight($element)
    } : {
      width: getWidth($element),
      height: getHeight($element)
    };
  }
  _dragStartHandler(e) {
    var _this$_resizeStartAct;
    const $element = this.$element();
    if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    this._toggleResizingClass(true);
    this._movingSides = this._getMovingSides(e);
    this._elementLocation = locate($element);
    this._elementSize = this._getElementSize();
    this._renderDragOffsets(e);
    null === (_this$_resizeStartAct = this._resizeStartAction) || void 0 === _this$_resizeStartAct || _this$_resizeStartAct.call(this, {
      event: e,
      width: this._elementSize.width,
      height: this._elementSize.height,
      handles: this._movingSides
    });
    e.targetElements = null;
  }
  _toggleResizingClass(value2) {
    this.$element().toggleClass("dx-resizable-resizing", value2);
  }
  _renderDragOffsets(e) {
    const area = this._getArea();
    if (!area) {
      return;
    }
    const $handle = renderer_default(e.target).closest(".dx-resizable-handle");
    const handleWidth = getOuterWidth($handle);
    const handleHeight = getOuterHeight($handle);
    const handleOffset = $handle.offset();
    const areaOffset = area.offset;
    const scrollOffset = this._getAreaScrollOffset();
    e.maxLeftOffset = this._leftMaxOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
    e.maxRightOffset = this._rightMaxOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
    e.maxTopOffset = this._topMaxOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
    e.maxBottomOffset = this._bottomMaxOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;
  }
  _getBorderWidth($element, direction) {
    if (isWindow($element.get(0))) {
      return 0;
    }
    const borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);
    return parseInt(borderWidth) || 0;
  }
  _proportionate(direction, value2) {
    const size = this._elementSize;
    const factor = "x" === direction ? size.width / size.height : size.height / size.width;
    return value2 * factor;
  }
  _getProportionalDelta(_ref) {
    let {
      x,
      y
    } = _ref;
    const proportionalY = this._proportionate("y", x);
    if (proportionalY >= y) {
      return {
        x,
        y: proportionalY
      };
    }
    const proportionalX = this._proportionate("x", y);
    if (proportionalX >= x) {
      return {
        x: proportionalX,
        y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  _getDirectionName(axis) {
    const sides = this._movingSides;
    if ("x" === axis) {
      return sides.left ? "left" : "right";
    }
    return sides.top ? "top" : "bottom";
  }
  _fitIntoArea(axis, value2) {
    const directionName = this._getDirectionName(axis);
    return Math.min(value2, this[`_${directionName}MaxOffset`] ?? 1 / 0);
  }
  _fitDeltaProportionally(delta) {
    let fittedDelta = _extends({}, delta);
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    const getWidth2 = () => size.width + fittedDelta.x;
    const getHeight2 = () => size.height + fittedDelta.y;
    const isInArea = (axis) => fittedDelta[axis] === this._fitIntoArea(axis, fittedDelta[axis]);
    const isFittedX = () => inRange(getWidth2(), minWidth, maxWidth) && isInArea("x");
    const isFittedY = () => inRange(getHeight2(), minHeight, maxHeight) && isInArea("y");
    if (!isFittedX()) {
      const x = this._fitIntoArea("x", fitIntoRange(getWidth2(), minWidth, maxWidth) - size.width);
      fittedDelta = {
        x,
        y: this._proportionate("y", x)
      };
    }
    if (!isFittedY()) {
      const y = this._fitIntoArea("y", fitIntoRange(getHeight2(), minHeight, maxHeight) - size.height);
      fittedDelta = {
        x: this._proportionate("x", y),
        y
      };
    }
    return isFittedX() && isFittedY() ? fittedDelta : {
      x: 0,
      y: 0
    };
  }
  _fitDelta(_ref2) {
    let {
      x,
      y
    } = _ref2;
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    return {
      x: fitIntoRange(size.width + x, minWidth, maxWidth) - size.width,
      y: fitIntoRange(size.height + y, minHeight, maxHeight) - size.height
    };
  }
  _getDeltaByOffset(offset2) {
    const sides = this._movingSides;
    const shouldKeepAspectRatio = this._isCornerHandler(sides) && this.option("keepAspectRatio");
    let delta = {
      x: offset2.x * (sides.left ? -1 : 1),
      y: offset2.y * (sides.top ? -1 : 1)
    };
    if (shouldKeepAspectRatio) {
      const proportionalDelta = this._getProportionalDelta(delta);
      const fittedProportionalDelta = this._fitDeltaProportionally(proportionalDelta);
      delta = fittedProportionalDelta;
    } else {
      const fittedDelta = this._fitDelta(delta);
      const roundedFittedDelta = this._roundByStep(fittedDelta);
      delta = roundedFittedDelta;
    }
    return delta;
  }
  _updatePosition(delta, _ref3) {
    let {
      width,
      height
    } = _ref3;
    const location = this._elementLocation;
    const sides = this._movingSides;
    const $element = this.$element();
    const elementRect = this._getElementSize();
    const offsetTop = delta.y * (sides.top ? -1 : 1) - ((elementRect.height || height) - height);
    const offsetLeft = delta.x * (sides.left ? -1 : 1) - ((elementRect.width || width) - width);
    move($element, {
      top: location.top + (sides.top ? offsetTop : 0),
      left: location.left + (sides.left ? offsetLeft : 0)
    });
  }
  _dragHandler(e) {
    const offset2 = this._getOffset(e);
    const delta = this._getDeltaByOffset(offset2);
    const dimensions = this._updateDimensions(delta);
    this._updatePosition(delta, dimensions);
    this._triggerResizeAction(e, dimensions);
  }
  _updateDimensions(delta) {
    const isAbsoluteSize = (size2) => "px" === size2.substring(size2.length - 2);
    const {
      stepPrecision
    } = this.option();
    const isStepPrecisionStrict = "strict" === stepPrecision;
    const size = this._elementSize;
    const width = size.width + delta.x;
    const height = size.height + delta.y;
    const elementStyle = this.$element().get(0).style;
    const shouldRenderWidth = delta.x || isStepPrecisionStrict || isAbsoluteSize(elementStyle.width);
    const shouldRenderHeight = delta.y || isStepPrecisionStrict || isAbsoluteSize(elementStyle.height);
    if (shouldRenderWidth) {
      this.option({
        width
      });
    }
    if (shouldRenderHeight) {
      this.option({
        height
      });
    }
    return {
      width: shouldRenderWidth ? width : size.width,
      height: shouldRenderHeight ? height : size.height
    };
  }
  _triggerResizeAction(e, _ref4) {
    var _this$_resizeAction;
    let {
      width,
      height
    } = _ref4;
    null === (_this$_resizeAction = this._resizeAction) || void 0 === _this$_resizeAction || _this$_resizeAction.call(this, {
      event: e,
      width: this.option("width") || width,
      height: this.option("height") || height,
      handles: this._movingSides
    });
    triggerResizeEvent2(this.$element());
  }
  _isCornerHandler(sides) {
    return 0 === Object.values(sides).reduce((xor, value2) => xor ^ value2, 0);
  }
  _getOffset(e) {
    const {
      offset: offset2
    } = e;
    const sides = this._movingSides;
    if (!sides.left && !sides.right) {
      offset2.x = 0;
    }
    if (!sides.top && !sides.bottom) {
      offset2.y = 0;
    }
    return offset2;
  }
  _roundByStep(delta) {
    const {
      stepPrecision
    } = this.option();
    return "strict" === stepPrecision ? this._roundStrict(delta) : this._roundNotStrict(delta);
  }
  _getSteps() {
    return pairToObject(this.option("step"), !this.option("roundStepValue"));
  }
  _roundNotStrict(delta) {
    const steps = this._getSteps();
    return {
      x: delta.x - delta.x % steps.h,
      y: delta.y - delta.y % steps.v
    };
  }
  _roundStrict(delta) {
    const sides = this._movingSides;
    const offset2 = {
      x: delta.x * (sides.left ? -1 : 1),
      y: delta.y * (sides.top ? -1 : 1)
    };
    const steps = this._getSteps();
    const location = this._elementLocation;
    const size = this._elementSize;
    const xPos = sides.left ? location.left : location.left + size.width;
    const yPos = sides.top ? location.top : location.top + size.height;
    const newXShift = (xPos + offset2.x) % steps.h;
    const newYShift = (yPos + offset2.y) % steps.v;
    const sign2 = Math.sign || ((x) => {
      x = +x;
      if (0 === x || isNaN(x)) {
        return x;
      }
      return x > 0 ? 1 : -1;
    });
    const separatorOffset = (steps2, offset3) => (1 + 0.2 * sign2(offset3)) % 1 * steps2;
    const isSmallOffset = (offset3, steps2) => Math.abs(offset3) < 0.2 * steps2;
    let newOffsetX = offset2.x - newXShift;
    let newOffsetY = offset2.y - newYShift;
    if (newXShift > separatorOffset(steps.h, offset2.x)) {
      newOffsetX += steps.h;
    }
    if (newYShift > separatorOffset(steps.v, offset2.y)) {
      newOffsetY += steps.v;
    }
    const roundedOffset_x = (sides.left || sides.right) && !isSmallOffset(offset2.x, steps.h) ? newOffsetX : 0, roundedOffset_y = (sides.top || sides.bottom) && !isSmallOffset(offset2.y, steps.v) ? newOffsetY : 0;
    return {
      x: roundedOffset_x * (sides.left ? -1 : 1),
      y: roundedOffset_y * (sides.top ? -1 : 1)
    };
  }
  _getMovingSides(e) {
    const $target = renderer_default(e.target);
    const hasCornerTopLeftClass = $target.hasClass("dx-resizable-handle-corner-top-left");
    const hasCornerTopRightClass = $target.hasClass("dx-resizable-handle-corner-top-right");
    const hasCornerBottomLeftClass = $target.hasClass("dx-resizable-handle-corner-bottom-left");
    const hasCornerBottomRightClass = $target.hasClass("dx-resizable-handle-corner-bottom-right");
    return {
      top: $target.hasClass("dx-resizable-handle-top") || hasCornerTopLeftClass || hasCornerTopRightClass,
      left: $target.hasClass("dx-resizable-handle-left") || hasCornerTopLeftClass || hasCornerBottomLeftClass,
      bottom: $target.hasClass("dx-resizable-handle-bottom") || hasCornerBottomLeftClass || hasCornerBottomRightClass,
      right: $target.hasClass("dx-resizable-handle-right") || hasCornerTopRightClass || hasCornerBottomRightClass
    };
  }
  _getArea() {
    let area = this.option("area");
    if (isFunction(area)) {
      area = area.call(this);
    }
    if (isPlainObject(area)) {
      return this._getAreaFromObject(area);
    }
    return this._getAreaFromElement(area);
  }
  _getAreaScrollOffset() {
    const area = this.option("area");
    const isElement = !isFunction(area) && !isPlainObject(area);
    const scrollOffset = {
      scrollY: 0,
      scrollX: 0
    };
    if (isElement) {
      const areaElement = renderer_default(area)[0];
      if (isWindow(areaElement)) {
        scrollOffset.scrollX = areaElement.pageXOffset;
        scrollOffset.scrollY = areaElement.pageYOffset;
      }
    }
    return scrollOffset;
  }
  _getAreaFromObject(area) {
    const result2 = {
      width: area.right - area.left,
      height: area.bottom - area.top,
      offset: {
        left: area.left,
        top: area.top
      }
    };
    this._correctAreaGeometry(result2);
    return result2;
  }
  _getAreaFromElement(area) {
    const $area = renderer_default(area);
    let result2;
    if ($area.length) {
      result2 = {
        width: getInnerWidth($area),
        height: getInnerHeight($area),
        offset: extend({
          top: 0,
          left: 0
        }, isWindow($area[0]) ? {} : $area.offset())
      };
      this._correctAreaGeometry(result2, $area);
    }
    return result2;
  }
  _correctAreaGeometry(result2, $area) {
    const areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0;
    const areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
    result2.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), "left");
    result2.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), "top");
    result2.width -= getOuterWidth(this.$element()) - getInnerWidth(this.$element());
    result2.height -= getOuterHeight(this.$element()) - getInnerHeight(this.$element());
  }
  _dragEndHandler(e) {
    var _this$_resizeEndActio;
    const $element = this.$element();
    null === (_this$_resizeEndActio = this._resizeEndAction) || void 0 === _this$_resizeEndActio || _this$_resizeEndActio.call(this, {
      event: e,
      width: getOuterWidth($element),
      height: getOuterHeight($element),
      handles: this._movingSides
    });
    this._toggleResizingClass(false);
  }
  _renderWidth(width) {
    this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")));
  }
  _renderHeight(height) {
    this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")));
  }
  _optionChanged(args) {
    switch (args.name) {
      case "disabled":
        this._toggleEventHandlers(!args.value);
        super._optionChanged(args);
        break;
      case "handles":
        this._invalidate();
        break;
      case "minWidth":
      case "maxWidth":
        hasWindow() && this._renderWidth(getOuterWidth(this.$element()));
        break;
      case "minHeight":
      case "maxHeight":
        hasWindow() && this._renderHeight(getOuterHeight(this.$element()));
        break;
      case "onResize":
      case "onResizeStart":
      case "onResizeEnd":
        this._renderActions();
        break;
      case "area":
      case "stepPrecision":
      case "step":
      case "roundStepValue":
      case "keepAspectRatio":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clean() {
    this.$element().find(".dx-resizable-handle").remove();
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default(RESIZABLE, Resizable);
var m_resizable_default = Resizable;

// node_modules/devextreme/esm/ui/resizable.js
var resizable_default = m_resizable_default;

// node_modules/devextreme/esm/ui/widget/swatch_container.js
var getSwatchContainer = (element) => {
  const $element = renderer_default(element);
  const swatchContainer = $element.closest('[class^="dx-swatch-"], [class*=" dx-swatch-"]');
  const viewport = value();
  if (!swatchContainer.length) {
    return viewport;
  }
  const swatchClassRegex = new RegExp("(\\s|^)(dx-swatch-.*?)(\\s|$)");
  const swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
  let viewportSwatchContainer = viewport.children("." + swatchClass);
  if (!viewportSwatchContainer.length) {
    viewportSwatchContainer = renderer_default("<div>").addClass(swatchClass).appendTo(viewport);
  }
  return viewportSwatchContainer;
};
var swatch_container_default = {
  getSwatchContainer
};

// node_modules/devextreme/esm/__internal/ui/overlay/m_overlay_position_controller.js
var window17 = m_window_default.getWindow();
var OVERLAY_POSITION_ALIASES = {
  top: {
    my: "top center",
    at: "top center"
  },
  bottom: {
    my: "bottom center",
    at: "bottom center"
  },
  right: {
    my: "right center",
    at: "right center"
  },
  left: {
    my: "left center",
    at: "left center"
  },
  center: {
    my: "center",
    at: "center"
  },
  "right bottom": {
    my: "right bottom",
    at: "right bottom"
  },
  "right top": {
    my: "right top",
    at: "right top"
  },
  "left bottom": {
    my: "left bottom",
    at: "left bottom"
  },
  "left top": {
    my: "left top",
    at: "left top"
  }
};
var OVERLAY_DEFAULT_BOUNDARY_OFFSET = {
  h: 0,
  v: 0
};
var OverlayPositionController = class {
  constructor(_ref) {
    let {
      position: position2,
      container,
      visualContainer,
      $root,
      $content,
      $wrapper,
      onPositioned,
      onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    } = _ref;
    this._props = {
      position: position2,
      container,
      visualContainer,
      restorePosition,
      onPositioned,
      onVisualPositionChanged,
      _fixWrapperPosition,
      _skipContentPositioning
    };
    this._$root = $root;
    this._$content = $content;
    this._$wrapper = $wrapper;
    this._$markupContainer = void 0;
    this._$visualContainer = void 0;
    this._shouldRenderContentInitialPosition = true;
    this._visualPosition = void 0;
    this._initialPosition = void 0;
    this._previousVisualPosition = void 0;
    this.updateContainer(container);
    this.updatePosition(position2);
    this.updateVisualContainer(visualContainer);
  }
  get $container() {
    this.updateContainer();
    return this._$markupContainer;
  }
  get $visualContainer() {
    return this._$visualContainer;
  }
  get position() {
    return this._position;
  }
  set fixWrapperPosition(fixWrapperPosition) {
    this._props._fixWrapperPosition = fixWrapperPosition;
    this.styleWrapperPosition();
  }
  set restorePosition(restorePosition) {
    this._props.restorePosition = restorePosition;
  }
  restorePositionOnNextRender(value2) {
    this._shouldRenderContentInitialPosition = value2 || !this._visualPosition;
  }
  openingHandled() {
    const shouldRestorePosition = this._props.restorePosition;
    this.restorePositionOnNextRender(shouldRestorePosition);
  }
  updatePosition(positionProp) {
    this._props.position = positionProp;
    this._position = this._normalizePosition(positionProp);
    this.updateVisualContainer();
  }
  updateContainer() {
    let containerProp = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._props.container;
    this._props.container = containerProp;
    this._$markupContainer = containerProp ? renderer_default(containerProp) : swatch_container_default.getSwatchContainer(this._$root);
    this.updateVisualContainer(this._props.visualContainer);
  }
  updateVisualContainer() {
    let visualContainer = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._props.visualContainer;
    this._props.visualContainer = visualContainer;
    this._$visualContainer = this._getVisualContainer();
  }
  detectVisualPositionChange(event) {
    this._updateVisualPositionValue();
    this._raisePositionedEvents(event);
  }
  positionContent() {
    if (this._shouldRenderContentInitialPosition) {
      this._renderContentInitialPosition();
    } else {
      move(this._$content, this._visualPosition);
      this.detectVisualPositionChange();
    }
  }
  positionWrapper() {
    if (this._$visualContainer) {
      position_default.setup(this._$wrapper, {
        my: "top left",
        at: "top left",
        of: this._$visualContainer
      });
    }
  }
  styleWrapperPosition() {
    const useFixed = isWindow(this.$visualContainer.get(0)) || this._props._fixWrapperPosition;
    const positionStyle = useFixed ? "fixed" : "absolute";
    this._$wrapper.css("position", positionStyle);
  }
  _updateVisualPositionValue() {
    this._previousVisualPosition = this._visualPosition;
    this._visualPosition = locate(this._$content);
  }
  _renderContentInitialPosition() {
    this._renderBoundaryOffset();
    resetPosition(this._$content);
    const wrapperOverflow = this._$wrapper.css("overflow");
    this._$wrapper.css("overflow", "hidden");
    if (!this._props._skipContentPositioning) {
      const resultPosition = position_default.setup(this._$content, this._position);
      this._initialPosition = resultPosition;
    }
    this._$wrapper.css("overflow", wrapperOverflow);
    this.detectVisualPositionChange();
  }
  _raisePositionedEvents(event) {
    const previousPosition = this._previousVisualPosition;
    const newPosition = this._visualPosition;
    const isVisualPositionChanged = (null === previousPosition || void 0 === previousPosition ? void 0 : previousPosition.top) !== newPosition.top || (null === previousPosition || void 0 === previousPosition ? void 0 : previousPosition.left) !== newPosition.left;
    if (isVisualPositionChanged) {
      this._props.onVisualPositionChanged({
        previousPosition,
        position: newPosition,
        event
      });
    }
    this._props.onPositioned({
      position: this._initialPosition
    });
  }
  _renderBoundaryOffset() {
    const boundaryOffset = this._position ?? {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    this._$content.css("margin", `${boundaryOffset.v}px ${boundaryOffset.h}px`);
  }
  _getVisualContainer() {
    var _this$_props$position, _this$_props$position2;
    const containerProp = this._props.container;
    const visualContainerProp = this._props.visualContainer;
    const positionOf = isEvent(null === (_this$_props$position = this._props.position) || void 0 === _this$_props$position ? void 0 : _this$_props$position.of) ? this._props.position.of.target : null === (_this$_props$position2 = this._props.position) || void 0 === _this$_props$position2 ? void 0 : _this$_props$position2.of;
    if (visualContainerProp) {
      return renderer_default(visualContainerProp);
    }
    if (containerProp) {
      return renderer_default(containerProp);
    }
    if (positionOf) {
      return renderer_default(positionOf);
    }
    return renderer_default(window17);
  }
  _normalizePosition(positionProp) {
    const defaultPositionConfig = {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    if (isDefined(positionProp)) {
      return extend(true, {}, defaultPositionConfig, this._positionToObject(positionProp));
    }
    return defaultPositionConfig;
  }
  _positionToObject(position2) {
    if (isString(position2)) {
      return extend({}, OVERLAY_POSITION_ALIASES[position2]);
    }
    return position2;
  }
};

// node_modules/devextreme/esm/__internal/ui/overlay/m_z_index.js
var baseZIndex = 1500;
var zIndexStack = [];
var base = (ZIndex) => {
  baseZIndex = ensureDefined(ZIndex, baseZIndex);
  return baseZIndex;
};
var create = function() {
  let baseIndex = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : baseZIndex;
  const {
    length
  } = zIndexStack;
  const index2 = (length ? zIndexStack[length - 1] : baseIndex) + 1;
  zIndexStack.push(index2);
  return index2;
};
var remove4 = (zIndex) => {
  const position2 = zIndexStack.indexOf(zIndex);
  if (position2 >= 0) {
    zIndexStack.splice(position2, 1);
  }
};
var isLastZIndexInStack = (zIndex) => zIndexStack.length && zIndexStack[zIndexStack.length - 1] === zIndex;

// node_modules/devextreme/esm/__internal/ui/overlay/m_overlay.js
var ready5 = ready_callbacks_default.add;
var window18 = m_window_default.getWindow();
var viewPortChanged2 = changeCallback;
var OVERLAY_STACK = [];
ready5(() => {
  m_events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), m_pointer_default.down, (e) => {
    for (let i = OVERLAY_STACK.length - 1; i >= 0; i--) {
      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
        return;
      }
    }
  });
});
var Overlay = class _Overlay extends widget_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      escape() {
        this.hide();
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      activeStateEnabled: false,
      visible: false,
      deferRendering: true,
      shading: true,
      shadingColor: "",
      wrapperAttr: {},
      position: extend({}, OVERLAY_POSITION_ALIASES.center),
      width: "80vw",
      minWidth: null,
      maxWidth: null,
      height: "80vh",
      minHeight: null,
      maxHeight: null,
      animation: {
        show: {
          type: "pop",
          duration: 300,
          from: {
            scale: 0.55
          }
        },
        hide: {
          type: "pop",
          duration: 300,
          from: {
            opacity: 1,
            scale: 1
          },
          to: {
            opacity: 0,
            scale: 0.55
          }
        }
      },
      hideOnOutsideClick: false,
      _ignorePreventScrollEventsDeprecation: false,
      onShowing: null,
      onShown: null,
      onHiding: null,
      onHidden: null,
      contentTemplate: "content",
      innerOverlay: false,
      restorePosition: true,
      hideTopOverlayHandler: () => {
        this.hide();
      },
      hideOnParentScroll: false,
      preventScrollEvents: true,
      onPositioned: null,
      propagateOutsideClick: false,
      ignoreChildEvents: true,
      _checkParentVisibility: true,
      _fixWrapperPosition: false,
      _loopFocus: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !m_window_default.hasWindow(),
      options: {
        width: null,
        height: null,
        animation: null,
        _checkParentVisibility: false
      }
    }]);
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      animation: true
    });
  }
  $wrapper() {
    return this._$wrapper;
  }
  _eventBindingTarget() {
    return this._$content;
  }
  ctor(element, options2) {
    super.ctor(element, options2);
    if (options2) {
      if ("preventScrollEvents" in options2 && !options2._ignorePreventScrollEventsDeprecation) {
        this._logDeprecatedPreventScrollEventsInfo();
      }
    }
  }
  _logDeprecatedPreventScrollEventsInfo() {
    this._logDeprecatedOptionWarning("preventScrollEvents", {
      since: "23.1",
      message: "If you enable this option, end-users may experience scrolling issues."
    });
  }
  _init() {
    super._init();
    this._initActions();
    this._initHideOnOutsideClickHandler();
    this._initTabTerminatorHandler();
    this._customWrapperClass = null;
    this._$wrapper = renderer_default("<div>").addClass("dx-overlay-wrapper");
    this._$content = renderer_default("<div>").addClass("dx-overlay-content");
    this._initInnerOverlayClass();
    const $element = this.$element();
    $element.addClass("dx-overlay");
    this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
    this._toggleViewPortSubscription(true);
    const {
      hideTopOverlayHandler
    } = this.option();
    this._initHideTopOverlayHandler(hideTopOverlayHandler);
    this._parentsScrollSubscriptionInfo = {
      handler: (e) => {
        this._hideOnParentsScrollHandler(e);
      }
    };
    this.warnPositionAsFunction();
  }
  warnPositionAsFunction() {
    if (isFunction(this.option("position"))) {
      errors_default.log("W0018");
    }
  }
  _initInnerOverlayClass() {
    const {
      innerOverlay
    } = this.option();
    this._$content.toggleClass("dx-inner-overlay", innerOverlay);
  }
  _initHideTopOverlayHandler(handler) {
    this._hideTopOverlayHandler = handler;
  }
  _getActionsList() {
    return ["onShowing", "onShown", "onHiding", "onHidden", "onPositioned", "onVisualPositionChanged"];
  }
  _initActions() {
    this._actions = {};
    const actions = this._getActionsList();
    each(actions, (_, action) => {
      this._actions[action] = this._createActionByOption(action, {
        excludeValidators: ["disabled", "readOnly"]
      }) || noop2;
    });
  }
  _initHideOnOutsideClickHandler() {
    var _this = this;
    this._proxiedDocumentDownHandler = function() {
      return _this._documentDownHandler(...arguments);
    };
  }
  _initMarkup() {
    super._initMarkup();
    this._renderWrapperAttributes();
    this._initPositionController();
  }
  _documentDownHandler(e) {
    if (this._showAnimationProcessing) {
      this._stopAnimation();
    }
    const isAttachedTarget = renderer_default(window18.document).is(e.target) || m_dom_default.contains(window18.document, e.target);
    const isInnerOverlay = renderer_default(e.target).closest(".dx-inner-overlay").length;
    const outsideClick = isAttachedTarget && !isInnerOverlay && !(this._$content.is(e.target) || m_dom_default.contains(this._$content.get(0), e.target));
    if (outsideClick && this._shouldHideOnOutsideClick(e)) {
      this._outsideClickHandler(e);
    }
    const {
      propagateOutsideClick
    } = this.option();
    return propagateOutsideClick;
  }
  _shouldHideOnOutsideClick(e) {
    const {
      hideOnOutsideClick
    } = this.option();
    if (isFunction(hideOnOutsideClick)) {
      return hideOnOutsideClick(e);
    }
    return hideOnOutsideClick;
  }
  _outsideClickHandler(e) {
    if (this.option("shading")) {
      e.preventDefault();
    }
    this.hide();
  }
  _getAnonymousTemplateName() {
    return "content";
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    super._initTemplates();
  }
  _isTopOverlay() {
    const overlayStack = this._overlayStack();
    for (let i = overlayStack.length - 1; i >= 0; i--) {
      const tabbableElements = overlayStack[i]._findTabbableBounds();
      if (tabbableElements.first || tabbableElements.last) {
        return overlayStack[i] === this;
      }
    }
    return false;
  }
  _overlayStack() {
    return OVERLAY_STACK;
  }
  _zIndexInitValue() {
    return _Overlay.baseZIndex();
  }
  _toggleViewPortSubscription(toggle) {
    var _this2 = this;
    viewPortChanged2.remove(this._viewPortChangeHandle);
    if (toggle) {
      this._viewPortChangeHandle = function() {
        _this2._viewPortChangeHandler(...arguments);
      };
      viewPortChanged2.add(this._viewPortChangeHandle);
    }
  }
  _viewPortChangeHandler() {
    this._positionController.updateContainer(this.option("container"));
    this._refresh();
  }
  _renderWrapperAttributes() {
    const {
      wrapperAttr
    } = this.option();
    const attributes = extend({}, wrapperAttr);
    const classNames = attributes.class;
    delete attributes.class;
    this.$wrapper().attr(attributes).removeClass(this._customWrapperClass).addClass(classNames);
    this._customWrapperClass = classNames;
  }
  _renderVisibilityAnimate(visible2) {
    this._stopAnimation();
    return visible2 ? this._show() : this._hide();
  }
  _getAnimationConfig() {
    return this._getOptionValue("animation", this);
  }
  _toggleBodyScroll(enabled) {
  }
  _animateShowing() {
    var _this3 = this;
    const animation2 = this._getAnimationConfig() ?? {};
    const showAnimation = this._normalizeAnimation(animation2.show, "to");
    const startShowAnimation = (null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.start) ?? noop2;
    const completeShowAnimation = (null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.complete) ?? noop2;
    this._animate(showAnimation, function() {
      if (_this3._isAnimationPaused) {
        return;
      }
      if (_this3.option("focusStateEnabled")) {
        m_events_engine_default.trigger(_this3._focusTarget(), "focus");
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      completeShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = false;
      _this3._isHidden = false;
      _this3._actions.onShown();
      _this3._toggleSafariScrolling();
      _this3._showingDeferred.resolve();
    }, function() {
      if (_this3._isAnimationPaused) {
        return;
      }
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      startShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = true;
    });
  }
  _processShowingHidingCancel(cancelArg, applyFunction, cancelFunction) {
    if (isPromise(cancelArg)) {
      cancelArg.then((shouldCancel) => {
        if (shouldCancel) {
          cancelFunction();
        } else {
          applyFunction();
        }
      }).catch(() => applyFunction());
    } else {
      cancelArg ? cancelFunction() : applyFunction();
    }
  }
  _show() {
    this._showingDeferred = Deferred();
    this._parentHidden = this._isParentHidden();
    this._showingDeferred.done(() => {
      delete this._parentHidden;
    });
    if (this._parentHidden) {
      this._isHidden = true;
      return this._showingDeferred.resolve();
    }
    if (this._currentVisible) {
      return Deferred().resolve().promise();
    }
    this._currentVisible = true;
    if (this._isHidingActionCanceled) {
      delete this._isHidingActionCanceled;
      this._showingDeferred.reject();
    } else {
      const show = () => {
        this._stopAnimation();
        const {
          enableBodyScroll
        } = this.option();
        this._toggleBodyScroll(enableBodyScroll);
        this._toggleVisibility(true);
        this._$content.css("visibility", "hidden");
        this._$content.toggleClass("dx-state-invisible", false);
        this._updateZIndexStackPosition(true);
        this._positionController.openingHandled();
        this._renderContent();
        const showingArgs = {
          cancel: false
        };
        this._actions.onShowing(showingArgs);
        this._processShowingHidingCancel(showingArgs.cancel, () => {
          this._$content.css("visibility", "");
          this._renderVisibility(true);
          this._animateShowing();
        }, () => {
          this._toggleVisibility(false);
          this._$content.css("visibility", "");
          this._$content.toggleClass("dx-state-invisible", true);
          this._isShowingActionCanceled = true;
          this._moveFromContainer();
          this._toggleBodyScroll(true);
          this.option("visible", false);
          this._showingDeferred.resolve();
        });
      };
      if (this.option("templatesRenderAsynchronously")) {
        this._stopShowTimer();
        this._asyncShowTimeout = setTimeout(show);
      } else {
        show();
      }
    }
    return this._showingDeferred.promise();
  }
  _normalizeAnimation(showHideConfig, direction) {
    if (showHideConfig) {
      showHideConfig = extend({
        type: "slide",
        skipElementInitialStyles: true
      }, showHideConfig);
      if (isObject(showHideConfig[direction])) {
        extend(showHideConfig[direction], {
          position: this._positionController.position
        });
      }
    }
    return showHideConfig;
  }
  _animateHiding() {
    var _this4 = this;
    const animation2 = this._getAnimationConfig() ?? {};
    const hideAnimation = this._normalizeAnimation(animation2.hide, "from");
    const startHideAnimation = (null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.start) ?? noop2;
    const completeHideAnimation = (null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.complete) ?? noop2;
    this._animate(hideAnimation, function() {
      var _this4$_actions;
      _this4._$content.css("pointerEvents", "");
      _this4._renderVisibility(false);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      completeHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = false;
      null === (_this4$_actions = _this4._actions) || void 0 === _this4$_actions || _this4$_actions.onHidden();
      _this4._hidingDeferred.resolve();
    }, function() {
      _this4._$content.css("pointerEvents", "none");
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      startHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = true;
    });
  }
  _hide() {
    if (!this._currentVisible) {
      return Deferred().resolve().promise();
    }
    this._currentVisible = false;
    this._hidingDeferred = Deferred();
    const hidingArgs = {
      cancel: false
    };
    if (this._isShowingActionCanceled) {
      delete this._isShowingActionCanceled;
      this._hidingDeferred.reject();
    } else {
      this._actions.onHiding(hidingArgs);
      this._toggleSafariScrolling();
      this._toggleBodyScroll(true);
      const cancelHide = () => {
        this._isHidingActionCanceled = true;
        const {
          enableBodyScroll
        } = this.option();
        this._toggleBodyScroll(enableBodyScroll);
        this.option("visible", true);
        this._hidingDeferred.resolve();
      };
      const applyHide = () => {
        this._forceFocusLost();
        this._toggleShading(false);
        this._toggleSubscriptions(false);
        this._stopShowTimer();
        this._animateHiding();
      };
      this._processShowingHidingCancel(hidingArgs.cancel, applyHide, cancelHide);
    }
    return this._hidingDeferred.promise();
  }
  _forceFocusLost() {
    const activeElement = dom_adapter_default.getActiveElement();
    const shouldResetActiveElement = !!this._$content.find(activeElement).length;
    if (shouldResetActiveElement) {
      m_dom_default.resetActiveElement();
    }
  }
  _animate(animation2, completeCallback, startCallback) {
    if (animation2) {
      startCallback = startCallback || animation2.start || noop2;
      fx_default.animate(this._$content, extend({}, animation2, {
        start: startCallback,
        complete: completeCallback
      }));
    } else {
      completeCallback();
    }
  }
  _stopAnimation() {
    fx_default.stop(this._$content, true);
  }
  _renderVisibility(visible2) {
    if (visible2 && this._isParentHidden()) {
      return;
    }
    this._currentVisible = visible2;
    this._stopAnimation();
    if (!visible2) {
      triggerHidingEvent2(this._$content);
    }
    if (visible2) {
      this._checkContainerExists();
      this._moveToContainer();
      this._renderGeometry();
      triggerShownEvent2(this._$content);
      triggerResizeEvent2(this._$content);
    } else {
      this._toggleVisibility(visible2);
      this._$content.toggleClass("dx-state-invisible", !visible2);
      this._updateZIndexStackPosition(visible2);
      this._moveFromContainer();
    }
    this._toggleShading(visible2);
    this._toggleSubscriptions(visible2);
  }
  _updateZIndexStackPosition(pushToStack) {
    const overlayStack = this._overlayStack();
    const index2 = overlayStack.indexOf(this);
    if (pushToStack) {
      if (-1 === index2) {
        this._zIndex = create(this._zIndexInitValue());
        overlayStack.push(this);
      }
      this._$wrapper.css("zIndex", this._zIndex);
      this._$content.css("zIndex", this._zIndex);
    } else if (-1 !== index2) {
      overlayStack.splice(index2, 1);
      remove4(this._zIndex);
    }
  }
  _toggleShading(visible2) {
    const {
      shading,
      shadingColor
    } = this.option();
    this._$wrapper.toggleClass("dx-overlay-shader", visible2 && shading);
    this._$wrapper.css("backgroundColor", shading ? shadingColor : "");
    this._toggleTabTerminator(visible2 && shading);
  }
  _initTabTerminatorHandler() {
    var _this5 = this;
    this._proxiedTabTerminatorHandler = function() {
      _this5._tabKeyHandler(...arguments);
    };
  }
  _toggleTabTerminator(enabled) {
    const {
      _loopFocus
    } = this.option();
    const eventName = addNamespace2("keydown", this.NAME);
    if (_loopFocus || enabled) {
      m_events_engine_default.on(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    } else {
      this._destroyTabTerminator();
    }
  }
  _destroyTabTerminator() {
    const eventName = addNamespace2("keydown", this.NAME);
    m_events_engine_default.off(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
  }
  _findTabbableBounds() {
    const $elements = this._$wrapper.find("*");
    const elementsCount = $elements.length - 1;
    let first = null;
    let last = null;
    for (let i = 0; i <= elementsCount; i += 1) {
      if (!first && $elements.eq(i).is(tabbable)) {
        first = $elements.eq(i);
      }
      if (!last && $elements.eq(elementsCount - i).is(tabbable)) {
        last = $elements.eq(elementsCount - i);
      }
      if (first && last) {
        break;
      }
    }
    return {
      first,
      last
    };
  }
  _tabKeyHandler(e) {
    if ("tab" !== normalizeKeyName(e) || !this._isTopOverlay()) {
      return;
    }
    const wrapper = this._$wrapper.get(0);
    const activeElement = dom_adapter_default.getActiveElement(wrapper);
    const {
      first: $firstTabbable,
      last: $lastTabbable
    } = this._findTabbableBounds();
    const isTabOnLast = !e.shiftKey && activeElement === (null === $lastTabbable || void 0 === $lastTabbable ? void 0 : $lastTabbable.get(0));
    const isShiftTabOnFirst = e.shiftKey && activeElement === (null === $firstTabbable || void 0 === $firstTabbable ? void 0 : $firstTabbable.get(0));
    const isOutsideTarget = !m_dom_default.contains(wrapper, activeElement);
    const shouldPreventDefault = isTabOnLast || isShiftTabOnFirst || isOutsideTarget;
    if (shouldPreventDefault) {
      e.preventDefault();
      const $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
      m_events_engine_default.trigger($focusElement, "focusin");
      m_events_engine_default.trigger($focusElement, "focus");
    }
  }
  _toggleSubscriptions(enabled) {
    if (m_window_default.hasWindow()) {
      this._toggleHideTopOverlayCallback(enabled);
      this._toggleHideOnParentsScrollSubscription(enabled);
    }
  }
  _toggleHideTopOverlayCallback(subscribe) {
    if (!this._hideTopOverlayHandler) {
      return;
    }
    if (subscribe) {
      hideCallback.add(this._hideTopOverlayHandler);
    } else {
      hideCallback.remove(this._hideTopOverlayHandler);
    }
  }
  _toggleHideOnParentsScrollSubscription(needSubscribe) {
    const scrollEvent = addNamespace2("scroll", this.NAME);
    const {
      prevTargets,
      handler
    } = this._parentsScrollSubscriptionInfo ?? {};
    m_events_engine_default.off(prevTargets, scrollEvent, handler);
    const hideOnScroll = this.option("hideOnParentScroll");
    if (needSubscribe && hideOnScroll) {
      let $parents = this._getHideOnParentScrollTarget().parents();
      if ("desktop" === devices_default.real().deviceType) {
        $parents = $parents.add(window18);
      }
      m_events_engine_default.on($parents, scrollEvent, handler);
      this._parentsScrollSubscriptionInfo.prevTargets = $parents;
    }
  }
  _hideOnParentsScrollHandler(e) {
    let hideHandled = false;
    const hideOnScroll = this.option("hideOnParentScroll");
    if (isFunction(hideOnScroll)) {
      hideHandled = hideOnScroll(e);
    }
    if (!hideHandled && !this._showAnimationProcessing) {
      this.hide();
    }
  }
  _getHideOnParentScrollTarget() {
    const {
      _hideOnParentScrollTarget
    } = this.option();
    const $hideOnParentScrollTarget = renderer_default(_hideOnParentScrollTarget);
    if ($hideOnParentScrollTarget.length) {
      return $hideOnParentScrollTarget;
    }
    return this._$wrapper;
  }
  _render() {
    super._render();
    this._appendContentToElement();
    this._renderVisibilityAnimate(this.option("visible"));
  }
  _appendContentToElement() {
    if (!this._$content.parent().is(this.$element())) {
      this._$content.appendTo(this.$element());
    }
  }
  _renderContent() {
    const shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
    const isParentHidden = this.option("visible") && this._isParentHidden();
    if (isParentHidden) {
      this._isHidden = true;
      return;
    }
    if (this._contentAlreadyRendered || shouldDeferRendering) {
      return;
    }
    this._contentAlreadyRendered = true;
    this._appendContentToElement();
    super._renderContent();
  }
  _isParentHidden() {
    if (!this.option("_checkParentVisibility")) {
      return false;
    }
    if (void 0 !== this._parentHidden) {
      return this._parentHidden;
    }
    const $parent = this.$element().parent();
    if ($parent.is(":visible")) {
      return false;
    }
    let isHidden = false;
    $parent.add($parent.parents()).each((index2, element) => {
      const $element = renderer_default(element);
      if ("none" === $element.css("display")) {
        isHidden = true;
        return false;
      }
    });
    return isHidden || !dom_adapter_default.getBody().contains($parent.get(0));
  }
  _renderContentImpl() {
    const whenContentRendered = Deferred();
    const contentTemplateOption = this.option("contentTemplate");
    const contentTemplate = this._getTemplate(contentTemplateOption);
    const transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
    null === contentTemplate || void 0 === contentTemplate || contentTemplate.render({
      container: getPublicElement(this.$content()),
      noModel: true,
      transclude,
      onRendered: () => {
        whenContentRendered.resolve();
        if (this.option("templatesRenderAsynchronously")) {
          this._dimensionChanged();
        }
      }
    });
    const {
      preventScrollEvents
    } = this.option();
    this._toggleWrapperScrollEventsSubscription(preventScrollEvents);
    whenContentRendered.done(() => {
      if (this.option("visible")) {
        this._moveToContainer();
      }
    });
    return whenContentRendered.promise();
  }
  _getPositionControllerConfig() {
    const {
      container,
      visualContainer,
      _fixWrapperPosition,
      restorePosition,
      _skipContentPositioning
    } = this.option();
    return {
      container,
      visualContainer,
      $root: this.$element(),
      $content: this._$content,
      $wrapper: this._$wrapper,
      onPositioned: this._actions.onPositioned,
      onVisualPositionChanged: this._actions.onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    };
  }
  _initPositionController() {
    this._positionController = new OverlayPositionController(this._getPositionControllerConfig());
  }
  _toggleWrapperScrollEventsSubscription(enabled) {
    const eventName = addNamespace2(DRAG_EVENT, this.NAME);
    m_events_engine_default.off(this._$wrapper, eventName);
    if (enabled) {
      m_events_engine_default.on(this._$wrapper, eventName, {
        validate: () => true,
        getDirection: () => "both",
        _toggleGestureCover(toggle) {
          if (!toggle) {
            this._toggleGestureCoverImpl(toggle);
          }
        },
        _clearSelection: noop2,
        isNative: true
      }, (e) => {
        const {
          originalEvent
        } = e.originalEvent;
        const {
          type: type2
        } = originalEvent || {};
        const isWheel = "wheel" === type2;
        const isMouseMove = "mousemove" === type2;
        const isScrollByWheel = isWheel && !isCommandKeyPressed(e);
        e._cancelPreventDefault = true;
        if (originalEvent && false !== e.cancelable && (!isMouseMove && !isWheel || isScrollByWheel)) {
          e.preventDefault();
        }
      });
    }
  }
  _moveFromContainer() {
    this._$content.appendTo(this.$element());
    this._$wrapper.detach();
  }
  _checkContainerExists() {
    const $wrapperContainer = this._positionController.$container;
    if (void 0 === $wrapperContainer) {
      return;
    }
    const containerExists = $wrapperContainer.length > 0;
    if (!containerExists) {
      ui_errors_default.log("W1021", this.NAME);
    }
  }
  _moveToContainer() {
    const $wrapperContainer = this._positionController.$container;
    this._$wrapper.appendTo($wrapperContainer);
    this._$content.appendTo(this._$wrapper);
  }
  _renderGeometry(options2) {
    const {
      visible: visible2
    } = this.option();
    if (visible2 && m_window_default.hasWindow()) {
      this._stopAnimation();
      this._renderGeometryImpl();
    }
  }
  _renderGeometryImpl() {
    this._positionController.updatePosition(this._getOptionValue("position"));
    this._renderWrapper();
    this._renderDimensions();
    this._renderPosition();
  }
  _renderPosition(state) {
    this._positionController.positionContent();
  }
  _isAllWindowCovered() {
    const {
      shading
    } = this.option();
    return isWindow(this._positionController.$visualContainer.get(0)) && shading;
  }
  _toggleSafariScrolling() {
    const visible2 = this.option("visible");
    const $body = renderer_default(dom_adapter_default.getBody());
    const isIosSafari = "ios" === devices_default.real().platform && browser_default.safari;
    const isAllWindowCovered = this._isAllWindowCovered();
    const isScrollingPrevented = $body.hasClass("dx-prevent-safari-scrolling");
    const shouldPreventScrolling = !isScrollingPrevented && visible2 && isAllWindowCovered;
    const shouldEnableScrolling = isScrollingPrevented && (!visible2 || !isAllWindowCovered || this._disposed);
    if (isIosSafari) {
      if (shouldEnableScrolling) {
        $body.removeClass("dx-prevent-safari-scrolling");
        window18.scrollTo(0, this._cachedBodyScrollTop);
        this._cachedBodyScrollTop = void 0;
      } else if (shouldPreventScrolling) {
        this._cachedBodyScrollTop = window18.pageYOffset;
        $body.addClass("dx-prevent-safari-scrolling");
      }
    }
  }
  _renderWrapper() {
    this._positionController.styleWrapperPosition();
    this._renderWrapperDimensions();
    this._positionController.positionWrapper();
  }
  _renderWrapperDimensions() {
    const {
      $visualContainer
    } = this._positionController;
    const documentElement = dom_adapter_default.getDocumentElement();
    const isVisualContainerWindow = isWindow($visualContainer.get(0));
    const wrapperWidth = isVisualContainerWindow ? documentElement.clientWidth : getOuterWidth($visualContainer);
    const wrapperHeight = isVisualContainerWindow ? window18.innerHeight : getOuterHeight($visualContainer);
    this._$wrapper.css({
      width: wrapperWidth,
      height: wrapperHeight
    });
  }
  _renderDimensions() {
    const content = this._$content.get(0);
    this._$content.css({
      minWidth: this._getOptionValue("minWidth", content),
      maxWidth: this._getOptionValue("maxWidth", content),
      minHeight: this._getOptionValue("minHeight", content),
      maxHeight: this._getOptionValue("maxHeight", content),
      width: this._getOptionValue("width", content),
      height: this._getOptionValue("height", content)
    });
  }
  _focusTarget() {
    return this._$content;
  }
  _attachKeyboardEvents() {
    this._keyboardListenerId = keyboard.on(this._$content, null, (options2) => this._keyboardHandler(options2));
  }
  _keyboardHandler(options2) {
    const e = options2.originalEvent;
    const $target = renderer_default(e.target);
    if ($target.is(this._$content) || !this.option("ignoreChildEvents")) {
      super._keyboardHandler(...arguments);
    }
  }
  _isVisible() {
    const {
      visible: visible2
    } = this.option();
    return visible2;
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      if (this.option("visible")) {
        this._renderVisibilityAnimate(visible2);
      }
    } else {
      this._renderVisibilityAnimate(visible2);
    }
  }
  _dimensionChanged() {
    this._renderGeometry();
  }
  _clean() {
    const {
      isRenovated
    } = this.option();
    if (!this._contentAlreadyRendered && !isRenovated) {
      this.$content().empty();
    }
    this._renderVisibility(false);
    this._stopShowTimer();
    this._cleanFocusState();
  }
  _stopShowTimer() {
    if (this._asyncShowTimeout) {
      clearTimeout(this._asyncShowTimeout);
    }
    this._asyncShowTimeout = null;
  }
  _dispose() {
    fx_default.stop(this._$content, false);
    this._toggleViewPortSubscription(false);
    this._toggleSubscriptions(false);
    this._updateZIndexStackPosition(false);
    this._actions = null;
    this._parentsScrollSubscriptionInfo = null;
    super._dispose();
    this._toggleSafariScrolling();
    this.option("visible") && remove4(this._zIndex);
    this._$wrapper.remove();
    this._$content.remove();
    this._destroyTabTerminator();
  }
  _toggleRTLDirection(rtl) {
    this._$content.toggleClass("dx-rtl", rtl);
  }
  _optionChanged(args) {
    const {
      value: value2,
      name: name2
    } = args;
    if (this._getActionsList().includes(name2)) {
      this._initActions();
      return;
    }
    switch (name2) {
      case "animation":
      case "hideOnOutsideClick":
      case "propagateOutsideClick":
        break;
      case "_loopFocus":
      case "shading": {
        const {
          visible: visible2
        } = this.option();
        this._toggleShading(visible2);
        this._toggleSafariScrolling();
        break;
      }
      case "shadingColor": {
        const {
          visible: visible2
        } = this.option();
        this._toggleShading(visible2);
        break;
      }
      case "width":
      case "height":
      case "minWidth":
      case "maxWidth":
      case "minHeight":
      case "maxHeight":
        this._renderGeometry();
        break;
      case "position":
        this._positionController.updatePosition(this.option("position"));
        this._positionController.restorePositionOnNextRender(true);
        this._renderGeometry();
        this._toggleSafariScrolling();
        break;
      case "visible":
        this._renderVisibilityAnimate(value2).done(() => {
          var _this$_animateDeferre;
          return null === (_this$_animateDeferre = this._animateDeferred) || void 0 === _this$_animateDeferre ? void 0 : _this$_animateDeferre.resolveWith(this);
        }).fail(() => {
          var _this$_animateDeferre2;
          return null === (_this$_animateDeferre2 = this._animateDeferred) || void 0 === _this$_animateDeferre2 ? void 0 : _this$_animateDeferre2.reject();
        });
        break;
      case "container":
        this._positionController.updateContainer(value2);
        this._invalidate();
        this._toggleSafariScrolling();
        break;
      case "visualContainer":
        this._positionController.updateVisualContainer(value2);
        this._renderWrapper();
        this._toggleSafariScrolling();
        break;
      case "innerOverlay":
        this._initInnerOverlayClass();
        break;
      case "deferRendering":
      case "contentTemplate":
        this._contentAlreadyRendered = false;
        this._clean();
        this._invalidate();
        break;
      case "hideTopOverlayHandler":
        this._toggleHideTopOverlayCallback(false);
        this._initHideTopOverlayHandler(value2);
        this._toggleHideTopOverlayCallback(this.option("visible"));
        break;
      case "hideOnParentScroll":
      case "_hideOnParentScrollTarget": {
        const {
          visible: visible2
        } = this.option();
        this._toggleHideOnParentsScrollSubscription(visible2);
        break;
      }
      case "rtlEnabled":
        this._contentAlreadyRendered = false;
        super._optionChanged(args);
        break;
      case "_fixWrapperPosition":
        this._positionController.fixWrapperPosition = value2;
        break;
      case "wrapperAttr":
        this._renderWrapperAttributes();
        break;
      case "restorePosition":
        this._positionController.restorePosition = value2;
        break;
      case "preventScrollEvents":
        this._logDeprecatedPreventScrollEventsInfo();
        this._toggleWrapperScrollEventsSubscription(value2);
        break;
      default:
        super._optionChanged(args);
    }
  }
  toggle(showing) {
    showing = void 0 === showing ? !this.option("visible") : showing;
    const result2 = Deferred();
    if (showing === this.option("visible")) {
      return result2.resolveWith(this, [showing]).promise();
    }
    const animateDeferred = Deferred();
    this._animateDeferred = animateDeferred;
    this.option("visible", showing);
    animateDeferred.promise().done(() => {
      delete this._animateDeferred;
      result2.resolveWith(this, [this.option("visible")]);
    }).fail(() => {
      delete this._animateDeferred;
      result2.reject();
    });
    return result2.promise();
  }
  $content() {
    return this._$content;
  }
  show() {
    return this.toggle(true);
  }
  hide() {
    return this.toggle(false);
  }
  content() {
    return getPublicElement(this._$content);
  }
  repaint() {
    if (this._contentAlreadyRendered) {
      this._positionController.restorePositionOnNextRender(true);
      this._renderGeometry({
        forceStopAnimation: true
      });
      triggerResizeEvent2(this._$content);
    } else {
      super.repaint();
    }
  }
};
Overlay.baseZIndex = (zIndex) => base(zIndex);
component_registrator_default("dxOverlay", Overlay);
var m_overlay_default = Overlay;

// node_modules/devextreme/esm/__internal/ui/popup/m_popup_drag.js
var PopupDrag = class {
  constructor(config3) {
    this.init(config3);
  }
  init(_ref) {
    let {
      dragEnabled,
      handle,
      draggableElement,
      positionController
    } = _ref;
    this._positionController = positionController;
    this._draggableElement = draggableElement;
    this._handle = handle;
    this._dragEnabled = dragEnabled;
    this.unsubscribe();
    if (!dragEnabled) {
      return;
    }
    this.subscribe();
  }
  moveDown(e) {
    this._moveTo(5, 0, e);
  }
  moveUp(e) {
    this._moveTo(-5, 0, e);
  }
  moveLeft(e) {
    this._moveTo(0, -5, e);
  }
  moveRight(e) {
    this._moveTo(0, 5, e);
  }
  subscribe() {
    const eventNames = this._getEventNames();
    m_events_engine_default.on(this._handle, eventNames.startEventName, (e) => {
      this._dragStartHandler(e);
    });
    m_events_engine_default.on(this._handle, eventNames.updateEventName, (e) => {
      this._dragUpdateHandler(e);
    });
    m_events_engine_default.on(this._handle, eventNames.endEventName, (e) => {
      this._dragEndHandler(e);
    });
  }
  unsubscribe() {
    const eventNames = this._getEventNames();
    m_events_engine_default.off(this._handle, eventNames.startEventName);
    m_events_engine_default.off(this._handle, eventNames.updateEventName);
    m_events_engine_default.off(this._handle, eventNames.endEventName);
  }
  _getEventNames() {
    const startEventName = addNamespace2(DRAG_START_EVENT, "overlayDrag");
    const updateEventName = addNamespace2(DRAG_EVENT, "overlayDrag");
    const endEventName = addNamespace2(DRAG_END_EVENT, "overlayDrag");
    return {
      startEventName,
      updateEventName,
      endEventName
    };
  }
  _dragStartHandler(e) {
    const allowedOffsets = this._getAllowedOffsets();
    this._prevOffset = {
      x: 0,
      y: 0
    };
    e.targetElements = [];
    e.maxTopOffset = allowedOffsets.top;
    e.maxBottomOffset = allowedOffsets.bottom;
    e.maxLeftOffset = allowedOffsets.left;
    e.maxRightOffset = allowedOffsets.right;
  }
  _dragUpdateHandler(e) {
    const targetOffset = {
      top: e.offset.y - this._prevOffset.y,
      left: e.offset.x - this._prevOffset.x
    };
    this._moveByOffset(targetOffset);
    this._prevOffset = e.offset;
  }
  _dragEndHandler(event) {
    this._positionController.dragHandled();
    this._positionController.detectVisualPositionChange(event);
  }
  _moveTo(top, left, e) {
    if (!this._dragEnabled) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const offset2 = this._fitOffsetIntoAllowedRange(top, left);
    this._moveByOffset(offset2);
    this._dragEndHandler(e);
  }
  _fitOffsetIntoAllowedRange(top, left) {
    const allowedOffsets = this._getAllowedOffsets();
    return {
      top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
      left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
    };
  }
  _getContainerDimensions() {
    const document2 = dom_adapter_default.getDocument();
    const container = this._positionController.$dragResizeContainer.get(0);
    let containerWidth = getOuterWidth(container);
    let containerHeight = getOuterHeight(container);
    if (isWindow(container)) {
      containerHeight = Math.max(document2.body.clientHeight, containerHeight);
      containerWidth = Math.max(document2.body.clientWidth, containerWidth);
    }
    return {
      width: containerWidth,
      height: containerHeight
    };
  }
  _getContainerPosition() {
    const container = this._positionController.$dragResizeContainer.get(0);
    return isWindow(container) ? {
      top: 0,
      left: 0
    } : getOffset(container);
  }
  _getElementPosition() {
    return getOffset(this._draggableElement);
  }
  _getInnerDelta() {
    const containerDimensions = this._getContainerDimensions();
    const elementDimensions = this._getElementDimensions();
    return {
      x: containerDimensions.width - elementDimensions.width,
      y: containerDimensions.height - elementDimensions.height
    };
  }
  _getOuterDelta() {
    const {
      width,
      height
    } = this._getElementDimensions();
    const {
      outsideDragFactor
    } = this._positionController;
    return {
      x: width * outsideDragFactor,
      y: height * outsideDragFactor
    };
  }
  _getFullDelta() {
    const fullDelta = this._getInnerDelta();
    const outerDelta = this._getOuterDelta();
    return {
      x: fullDelta.x + outerDelta.x,
      y: fullDelta.y + outerDelta.y
    };
  }
  _getElementDimensions() {
    return {
      width: this._draggableElement.offsetWidth,
      height: this._draggableElement.offsetHeight
    };
  }
  _getAllowedOffsets() {
    const fullDelta = this._getFullDelta();
    const isDragAllowed = fullDelta.y >= 0 && fullDelta.x >= 0;
    if (!isDragAllowed) {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }
    const elementPosition = this._getElementPosition();
    const containerPosition = this._getContainerPosition();
    const outerDelta = this._getOuterDelta();
    return {
      top: elementPosition.top - containerPosition.top + outerDelta.y,
      bottom: -elementPosition.top + containerPosition.top + fullDelta.y,
      left: elementPosition.left - containerPosition.left + outerDelta.x,
      right: -elementPosition.left + containerPosition.left + fullDelta.x
    };
  }
  _moveByOffset(offset2) {
    const currentPosition = locate(this._draggableElement);
    const newPosition = {
      left: currentPosition.left + offset2.left,
      top: currentPosition.top + offset2.top
    };
    move(this._draggableElement, newPosition);
  }
};
var m_popup_drag_default = PopupDrag;

// node_modules/devextreme/esm/__internal/ui/popup/m_popup_overflow_manager.js
var overflowManagerMock = {
  setOverflow: noop2,
  restoreOverflow: noop2
};
var createBodyOverflowManager = () => {
  if (!m_window_default.hasWindow()) {
    return overflowManagerMock;
  }
  const window21 = m_window_default.getWindow();
  const {
    documentElement
  } = dom_adapter_default.getDocument();
  const body = dom_adapter_default.getBody();
  const isIosDevice = "ios" === devices_default.real().platform;
  const prevSettings = {
    overflow: null,
    overflowX: null,
    overflowY: null,
    paddingRight: null,
    position: null,
    top: null,
    left: null
  };
  return {
    setOverflow: isIosDevice ? () => {
      if (isDefined(prevSettings.position) || "fixed" === body.style.position) {
        return;
      }
      const {
        scrollY,
        scrollX
      } = window21;
      prevSettings.position = body.style.position;
      prevSettings.top = body.style.top;
      prevSettings.left = body.style.left;
      body.style.setProperty("position", "fixed");
      body.style.setProperty("top", -scrollY + "px");
      body.style.setProperty("left", -scrollX + "px");
    } : () => {
      (() => {
        const scrollBarWidth = window21.innerWidth - documentElement.clientWidth;
        if (prevSettings.paddingRight || scrollBarWidth <= 0) {
          return;
        }
        const paddingRight = window21.getComputedStyle(body).getPropertyValue("padding-right");
        const computedBodyPaddingRight = parseInt(paddingRight, 10);
        prevSettings.paddingRight = computedBodyPaddingRight;
        body.style.setProperty("padding-right", `${computedBodyPaddingRight + scrollBarWidth}px`);
      })();
      if (prevSettings.overflow || "hidden" === body.style.overflow) {
        return;
      }
      prevSettings.overflow = body.style.overflow;
      prevSettings.overflowX = body.style.overflowX;
      prevSettings.overflowY = body.style.overflowY;
      body.style.setProperty("overflow", "hidden");
    },
    restoreOverflow: isIosDevice ? () => {
      if (!isDefined(prevSettings.position)) {
        return;
      }
      const scrollY = -parseInt(body.style.top, 10);
      const scrollX = -parseInt(body.style.left, 10);
      ["position", "top", "left"].forEach((property) => {
        if (prevSettings[property]) {
          body.style.setProperty(property, prevSettings[property]);
        } else {
          body.style.removeProperty(property);
        }
      });
      window21.scrollTo(scrollX, scrollY);
      prevSettings.position = null;
    } : () => {
      (() => {
        if (!isDefined(prevSettings.paddingRight)) {
          return;
        }
        if (prevSettings.paddingRight) {
          body.style.setProperty("padding-right", `${prevSettings.paddingRight}px`);
        } else {
          body.style.removeProperty("padding-right");
        }
        prevSettings.paddingRight = null;
      })();
      ["overflow", "overflowX", "overflowY"].forEach((property) => {
        if (!isDefined(prevSettings[property])) {
          return;
        }
        const propertyInKebabCase = property.replace(/(X)|(Y)/, (symbol) => `-${symbol.toLowerCase()}`);
        if (prevSettings[property]) {
          body.style.setProperty(propertyInKebabCase, prevSettings[property]);
        } else {
          body.style.removeProperty(propertyInKebabCase);
        }
        prevSettings[property] = null;
      });
    }
  };
};

// node_modules/devextreme/esm/__internal/ui/popup/m_popup_position_controller.js
var _excluded5 = ["fullScreen", "forceApplyBindings", "dragOutsideBoundary", "dragAndResizeArea", "outsideDragFactor"];
var window19 = m_window_default.getWindow();
var PopupPositionController = class extends OverlayPositionController {
  constructor(_ref) {
    let {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = _ref, args = _objectWithoutPropertiesLoose(_ref, _excluded5);
    super(args);
    this._props = _extends({}, this._props, {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
    this._$dragResizeContainer = void 0;
    this._updateDragResizeContainer();
  }
  set fullScreen(fullScreen) {
    this._props.fullScreen = fullScreen;
    if (fullScreen) {
      this._fullScreenEnabled();
    } else {
      this._fullScreenDisabled();
    }
  }
  get $dragResizeContainer() {
    return this._$dragResizeContainer;
  }
  get outsideDragFactor() {
    if (this._props.dragOutsideBoundary) {
      return 1;
    }
    return this._props.outsideDragFactor;
  }
  set dragAndResizeArea(dragAndResizeArea) {
    this._props.dragAndResizeArea = dragAndResizeArea;
    this._updateDragResizeContainer();
  }
  set dragOutsideBoundary(dragOutsideBoundary) {
    this._props.dragOutsideBoundary = dragOutsideBoundary;
    this._updateDragResizeContainer();
  }
  set outsideDragFactor(outsideDragFactor) {
    this._props.outsideDragFactor = outsideDragFactor;
  }
  updateContainer(containerProp) {
    super.updateContainer(containerProp);
    this._updateDragResizeContainer();
  }
  dragHandled() {
    this.restorePositionOnNextRender(false);
  }
  resizeHandled() {
    this.restorePositionOnNextRender(false);
  }
  positionContent() {
    if (this._props.fullScreen) {
      move(this._$content, {
        top: 0,
        left: 0
      });
      this.detectVisualPositionChange();
    } else {
      var _this$_props$forceApp, _this$_props;
      null === (_this$_props$forceApp = (_this$_props = this._props).forceApplyBindings) || void 0 === _this$_props$forceApp || _this$_props$forceApp.call(_this$_props);
      super.positionContent();
    }
  }
  _normalizePosition(positionProp) {
    const normalizedPosition = super._normalizePosition(positionProp);
    if (this._props.fullScreen) {
      normalizedPosition.of = "window";
    }
    return normalizedPosition;
  }
  _updateDragResizeContainer() {
    this._$dragResizeContainer = this._getDragResizeContainer();
  }
  _getDragResizeContainer() {
    if (this._props.dragOutsideBoundary) {
      return renderer_default(window19);
    }
    if (this._props.dragAndResizeArea) {
      return renderer_default(this._props.dragAndResizeArea);
    }
    const isContainerDefined = originalViewPort().get(0) || this._props.container;
    return isContainerDefined ? this._$markupContainer : renderer_default(window19);
  }
  _getVisualContainer() {
    if (this._props.fullScreen) {
      return renderer_default(window19);
    }
    return super._getVisualContainer();
  }
  _fullScreenEnabled() {
    this.restorePositionOnNextRender(false);
  }
  _fullScreenDisabled() {
    this.restorePositionOnNextRender(true);
  }
};

// node_modules/devextreme/esm/__internal/ui/popup/m_popup.js
var window20 = m_window_default.getWindow();
var ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
var HEIGHT_STRATEGIES = {
  static: "",
  inherit: "dx-popup-inherit-height",
  flex: "dx-popup-flex-height"
};
var getButtonPlace = (name2) => {
  const device = devices_default.current();
  const {
    platform
  } = device;
  let toolbar = "bottom";
  let location = "before";
  if ("ios" === platform) {
    switch (name2) {
      case "cancel":
        toolbar = "top";
        break;
      case "clear":
        toolbar = "top";
        location = "after";
        break;
      case "done":
        location = "after";
    }
  } else if ("android" === platform) {
    switch (name2) {
      case "cancel":
      case "done":
        location = "after";
    }
  }
  return {
    toolbar,
    location
  };
};
var Popup = class extends m_overlay_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      upArrow: (e) => {
        var _this$_drag;
        null === (_this$_drag = this._drag) || void 0 === _this$_drag || _this$_drag.moveUp(e);
      },
      downArrow: (e) => {
        var _this$_drag2;
        null === (_this$_drag2 = this._drag) || void 0 === _this$_drag2 || _this$_drag2.moveDown(e);
      },
      leftArrow: (e) => {
        var _this$_drag3;
        null === (_this$_drag3 = this._drag) || void 0 === _this$_drag3 || _this$_drag3.moveLeft(e);
      },
      rightArrow: (e) => {
        var _this$_drag4;
        null === (_this$_drag4 = this._drag) || void 0 === _this$_drag4 || _this$_drag4.moveRight(e);
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      fullScreen: false,
      title: "",
      showTitle: true,
      titleTemplate: "title",
      onTitleRendered: null,
      dragOutsideBoundary: false,
      dragEnabled: false,
      enableBodyScroll: true,
      outsideDragFactor: 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      resizeEnabled: false,
      toolbarItems: [],
      showCloseButton: false,
      bottomTemplate: "bottom",
      useDefaultToolbarButtons: false,
      useFlatToolbarButtons: false,
      autoResizeEnabled: true
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        animation: this._iosAnimation
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        animation: this._androidAnimation
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        showCloseButton: true
      }
    }, {
      device: (device) => "desktop" === devices_default.real().deviceType && "generic" === device.platform,
      options: {
        dragEnabled: true
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useFlatToolbarButtons: true
      }
    }, {
      device: () => isMaterial(),
      options: {
        useDefaultToolbarButtons: true,
        showCloseButton: false
      }
    }]);
  }
  _iosAnimation() {
    return {
      show: {
        type: "slide",
        duration: 400,
        from: {
          position: {
            my: "top",
            at: "bottom"
          }
        },
        to: {
          position: {
            my: "center",
            at: "center"
          }
        }
      },
      hide: {
        type: "slide",
        duration: 400,
        from: {
          opacity: 1,
          position: {
            my: "center",
            at: "center"
          }
        },
        to: {
          opacity: 1,
          position: {
            my: "top",
            at: "bottom"
          }
        }
      }
    };
  }
  _androidAnimation() {
    return this.option("fullScreen") ? {
      show: {
        type: "slide",
        duration: 300,
        from: {
          top: "30%",
          opacity: 0
        },
        to: {
          top: 0,
          opacity: 1
        }
      },
      hide: {
        type: "slide",
        duration: 300,
        from: {
          top: 0,
          opacity: 1
        },
        to: {
          top: "30%",
          opacity: 0
        }
      }
    } : {
      show: {
        type: "fade",
        duration: 400,
        from: 0,
        to: 1
      },
      hide: {
        type: "fade",
        duration: 400,
        from: 1,
        to: 0
      }
    };
  }
  _init() {
    const {
      _wrapperClassExternal: popupWrapperClassExternal
    } = this.option();
    const popupWrapperClasses = popupWrapperClassExternal ? `dx-popup-wrapper ${popupWrapperClassExternal}` : "dx-popup-wrapper";
    super._init();
    this._createBodyOverflowManager();
    this._updateResizeCallbackSkipCondition();
    this.$element().addClass("dx-popup");
    this.$wrapper().addClass(popupWrapperClasses);
    this._$popupContent = this._$content.wrapInner(renderer_default("<div>").addClass("dx-popup-content")).children().eq(0);
    this._toggleContentScrollClass();
    this.$overlayContent().attr("role", "dialog");
  }
  _render() {
    const isFullscreen = this.option("fullScreen");
    this._toggleFullScreenClass(isFullscreen);
    super._render();
  }
  _createBodyOverflowManager() {
    this._bodyOverflowManager = createBodyOverflowManager();
  }
  _toggleFullScreenClass(value2) {
    this.$overlayContent().toggleClass("dx-popup-fullscreen", value2).toggleClass("dx-popup-normal", !value2);
  }
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      title: new EmptyTemplate(),
      bottom: new EmptyTemplate()
    });
  }
  _getActionsList() {
    return super._getActionsList().concat(["onResizeStart", "onResize", "onResizeEnd"]);
  }
  _contentResizeHandler(entry) {
    if (!this._shouldSkipContentResize(entry)) {
      this._renderGeometry({
        shouldOnlyReposition: true
      });
    }
  }
  _doesShowAnimationChangeDimensions() {
    const animation2 = this.option("animation");
    return ["to", "from"].some((prop) => {
      var _animation$show;
      const config3 = null === animation2 || void 0 === animation2 || null === (_animation$show = animation2.show) || void 0 === _animation$show ? void 0 : _animation$show[prop];
      return isObject(config3) && ("width" in config3 || "height" in config3);
    });
  }
  _updateResizeCallbackSkipCondition() {
    const doesShowAnimationChangeDimensions = this._doesShowAnimationChangeDimensions();
    this._shouldSkipContentResize = (entry) => doesShowAnimationChangeDimensions && this._showAnimationProcessing || this._areContentDimensionsRendered(entry);
  }
  _observeContentResize(shouldObserve) {
    if (!this.option("useResizeObserver")) {
      return;
    }
    const contentElement = this._$content.get(0);
    if (shouldObserve) {
      resize_observer_default.observe(contentElement, (entry) => {
        this._contentResizeHandler(entry);
      });
    } else {
      resize_observer_default.unobserve(contentElement);
    }
  }
  _areContentDimensionsRendered(entry) {
    var _entry$contentBoxSize, _this$_renderedDimens3, _this$_renderedDimens4;
    const contentBox = null === (_entry$contentBoxSize = entry.contentBoxSize) || void 0 === _entry$contentBoxSize ? void 0 : _entry$contentBoxSize[0];
    if (contentBox) {
      var _this$_renderedDimens, _this$_renderedDimens2;
      return parseInt(contentBox.inlineSize, 10) === (null === (_this$_renderedDimens = this._renderedDimensions) || void 0 === _this$_renderedDimens ? void 0 : _this$_renderedDimens.width) && parseInt(contentBox.blockSize, 10) === (null === (_this$_renderedDimens2 = this._renderedDimensions) || void 0 === _this$_renderedDimens2 ? void 0 : _this$_renderedDimens2.height);
    }
    const {
      contentRect
    } = entry;
    return parseInt(contentRect.width, 10) === (null === (_this$_renderedDimens3 = this._renderedDimensions) || void 0 === _this$_renderedDimens3 ? void 0 : _this$_renderedDimens3.width) && parseInt(contentRect.height, 10) === (null === (_this$_renderedDimens4 = this._renderedDimensions) || void 0 === _this$_renderedDimens4 ? void 0 : _this$_renderedDimens4.height);
  }
  _renderContent() {
    super._renderContent();
    this._observeContentResize(true);
  }
  _renderContentImpl() {
    this._renderTitle();
    super._renderContentImpl();
    this._renderResize();
    this._renderBottom();
  }
  _renderTitle() {
    const items = this._getToolbarItems("top");
    const {
      title,
      showTitle
    } = this.option();
    if (showTitle && !!title) {
      items.unshift({
        location: devices_default.current().ios ? "center" : "before",
        text: title
      });
    }
    if (showTitle || items.length > 0) {
      if (this._$title) {
        this._$title.remove();
      }
      const $title = renderer_default("<div>").addClass("dx-popup-title").insertBefore(this.$content());
      this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass("dx-popup-title");
      this._renderDrag();
      this._executeTitleRenderAction(this._$title);
      this._$title.toggleClass("dx-has-close-button", this._hasCloseButton());
    } else if (this._$title) {
      this._$title.detach();
    }
    this._toggleAriaLabel();
  }
  _toggleAriaLabel() {
    var _this$_$title;
    const {
      title,
      showTitle
    } = this.option();
    const shouldSetAriaLabel = showTitle && !!title;
    const titleId = shouldSetAriaLabel ? new guid_default2() : null;
    null === (_this$_$title = this._$title) || void 0 === _this$_$title || _this$_$title.find(".dx-toolbar-label").eq(0).attr("id", titleId);
    this.$overlayContent().attr("aria-labelledby", titleId);
  }
  _renderTemplateByType(optionName, data2, $container, additionalToolbarOptions) {
    const {
      rtlEnabled,
      useDefaultToolbarButtons,
      useFlatToolbarButtons,
      disabled
    } = this.option();
    const template = this._getTemplateByOption(optionName);
    const toolbarTemplate = template instanceof EmptyTemplate;
    if (toolbarTemplate) {
      const integrationOptions = extend({}, this.option("integrationOptions"), {
        skipTemplates: ["content", "title"]
      });
      const toolbarOptions = extend(additionalToolbarOptions, {
        items: data2,
        rtlEnabled,
        useDefaultButtons: useDefaultToolbarButtons,
        useFlatButtons: useFlatToolbarButtons,
        disabled,
        integrationOptions
      });
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: {
          widget: this._getToolbarName(),
          options: toolbarOptions
        }
      });
      const $toolbar = $container.children("div");
      $container.replaceWith($toolbar);
      return $toolbar;
    }
    const $result = renderer_default(template.render({
      container: getPublicElement($container)
    }));
    if ($result.hasClass("dx-template-wrapper")) {
      $container.replaceWith($result);
      $container = $result;
    }
    return $container;
  }
  _getToolbarName() {
    return "dxToolbarBase";
  }
  _renderVisibilityAnimate(visible2) {
    return super._renderVisibilityAnimate(visible2);
  }
  _hide() {
    this._observeContentResize(false);
    return super._hide();
  }
  _executeTitleRenderAction($titleElement) {
    this._getTitleRenderAction()({
      titleElement: getPublicElement($titleElement)
    });
  }
  _getTitleRenderAction() {
    return this._titleRenderAction || this._createTitleRenderAction();
  }
  _createTitleRenderAction() {
    return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getCloseButton() {
    return {
      toolbar: "top",
      location: "after",
      template: this._getCloseButtonRenderer()
    };
  }
  _getCloseButtonRenderer() {
    return (_, __, container) => {
      const $button = renderer_default("<div>").addClass("dx-closebutton");
      this._createComponent($button, button_default2, {
        icon: "close",
        onClick: this._createToolbarItemAction(void 0),
        stylingMode: "text",
        integrationOptions: {}
      });
      renderer_default(container).append($button);
    };
  }
  _getToolbarItems(toolbar) {
    const toolbarItems = this.option("toolbarItems");
    const toolbarsItems = [];
    this._toolbarItemClasses = [];
    const currentPlatform = devices_default.current().platform;
    let index2 = 0;
    each(toolbarItems, (_, data2) => {
      const isShortcut = isDefined(data2.shortcut);
      const item = isShortcut ? getButtonPlace(data2.shortcut) : data2;
      if (isShortcut && "ios" === currentPlatform && index2 < 2) {
        item.toolbar = "top";
        index2++;
      }
      item.toolbar = data2.toolbar || item.toolbar || "top";
      if (item && item.toolbar === toolbar) {
        if (isShortcut) {
          extend(item, {
            location: data2.location
          }, this._getToolbarItemByAlias(data2));
        }
        const isLTROrder = "generic" === currentPlatform;
        if ("done" === data2.shortcut && isLTROrder || "cancel" === data2.shortcut && !isLTROrder) {
          toolbarsItems.unshift(item);
        } else {
          toolbarsItems.push(item);
        }
      }
    });
    if ("top" === toolbar && this._hasCloseButton()) {
      toolbarsItems.push(this._getCloseButton());
    }
    return toolbarsItems;
  }
  _hasCloseButton() {
    const {
      showCloseButton,
      showTitle
    } = this.option();
    return showCloseButton && showTitle;
  }
  _getLocalizationKey(itemType) {
    return "done" === itemType.toLowerCase() ? "OK" : camelize(itemType, true);
  }
  _getToolbarButtonStylingMode(shortcut) {
    if (isFluent()) {
      return "done" === shortcut ? "contained" : "outlined";
    }
    return this.option("useFlatToolbarButtons") ? "text" : "contained";
  }
  _getToolbarButtonType(shortcut) {
    if (isFluent() && "done" === shortcut || this.option("useDefaultToolbarButtons")) {
      return "default";
    }
    return "normal";
  }
  _getToolbarItemByAlias(data2) {
    const that = this;
    const itemType = data2.shortcut;
    if (!ALLOWED_TOOLBAR_ITEM_ALIASES.includes(itemType)) {
      return false;
    }
    const itemConfig = extend({
      text: message_default.format(this._getLocalizationKey(itemType)),
      onClick: this._createToolbarItemAction(data2.onClick),
      integrationOptions: {},
      type: this._getToolbarButtonType(itemType),
      stylingMode: this._getToolbarButtonStylingMode(itemType)
    }, data2.options || {});
    const itemClass = `dx-popup-${itemType}`;
    this._toolbarItemClasses.push(itemClass);
    return {
      template(_, __, container) {
        const $toolbarItem = renderer_default("<div>").addClass(itemClass).appendTo(container);
        that._createComponent($toolbarItem, button_default2, itemConfig);
      }
    };
  }
  _createToolbarItemAction(clickAction) {
    return this._createAction(clickAction, {
      afterExecute(e) {
        e.component.hide();
      }
    });
  }
  _renderBottom() {
    const items = this._getToolbarItems("bottom");
    if (items.length) {
      var _this$_$bottom;
      null === (_this$_$bottom = this._$bottom) || void 0 === _this$_$bottom || _this$_$bottom.remove();
      const $bottom = renderer_default("<div>").addClass("dx-popup-bottom").insertAfter(this.$content());
      this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom, {
        compactMode: true
      }).addClass("dx-popup-bottom");
      this._toggleClasses();
    } else {
      var _this$_$bottom2;
      null === (_this$_$bottom2 = this._$bottom) || void 0 === _this$_$bottom2 || _this$_$bottom2.detach();
    }
  }
  _toggleDisabledState(value2) {
    super._toggleDisabledState(...arguments);
    this.$content().toggleClass("dx-state-disabled", Boolean(value2));
  }
  _toggleClasses() {
    const aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
    each(aliases, (_, alias) => {
      const className = `dx-popup-${alias}`;
      if (this._toolbarItemClasses.includes(className)) {
        var _this$_$bottom3;
        this.$wrapper().addClass(`${className}-visible`);
        null === (_this$_$bottom3 = this._$bottom) || void 0 === _this$_$bottom3 || _this$_$bottom3.addClass(className);
      } else {
        var _this$_$bottom4;
        this.$wrapper().removeClass(`${className}-visible`);
        null === (_this$_$bottom4 = this._$bottom) || void 0 === _this$_$bottom4 || _this$_$bottom4.removeClass(className);
      }
    });
  }
  _toggleFocusClass(isFocused, $element) {
    super._toggleFocusClass(isFocused, $element);
    if (isFocused && !isLastZIndexInStack(this._zIndex)) {
      const zIndex = create(this._zIndexInitValue());
      remove4(this._zIndex);
      this._zIndex = zIndex;
      this._$wrapper.css("zIndex", zIndex);
      this._$content.css("zIndex", zIndex);
    }
  }
  _toggleContentScrollClass() {
    const isNativeScrollingEnabled = !this.option("preventScrollEvents");
    this.$content().toggleClass("dx-popup-content-scrollable", isNativeScrollingEnabled);
  }
  _getPositionControllerConfig() {
    const {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = this.option();
    return _extends({}, super._getPositionControllerConfig(), {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
  }
  _initPositionController() {
    this._positionController = new PopupPositionController(this._getPositionControllerConfig());
  }
  _getDragTarget() {
    return this.topToolbar();
  }
  _renderGeometry(options2) {
    const {
      visible: visible2,
      useResizeObserver
    } = this.option();
    if (visible2 && m_window_default.hasWindow()) {
      const isAnimated = this._showAnimationProcessing;
      const shouldRepeatAnimation = isAnimated && !(null !== options2 && void 0 !== options2 && options2.forceStopAnimation) && useResizeObserver;
      this._isAnimationPaused = shouldRepeatAnimation || void 0;
      this._stopAnimation();
      if (null !== options2 && void 0 !== options2 && options2.shouldOnlyReposition) {
        this._renderPosition(false);
      } else {
        this._renderGeometryImpl(null === options2 || void 0 === options2 ? void 0 : options2.isDimensionChange);
      }
      if (shouldRepeatAnimation) {
        this._animateShowing();
        this._isAnimationPaused = void 0;
      }
    }
  }
  _cacheDimensions() {
    if (!this.option("useResizeObserver")) {
      return;
    }
    this._renderedDimensions = {
      width: parseInt(getWidth(this._$content), 10),
      height: parseInt(getHeight(this._$content), 10)
    };
  }
  _renderGeometryImpl() {
    let isDimensionChange = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    if (!isDimensionChange) {
      this._resetContentHeight();
    }
    super._renderGeometryImpl();
    this._cacheDimensions();
    this._setContentHeight();
  }
  _resetContentHeight() {
    const height = this._getOptionValue("height");
    if ("auto" === height) {
      this.$content().css({
        height: "auto",
        maxHeight: "none"
      });
    }
  }
  _renderDrag() {
    const $dragTarget = this._getDragTarget();
    const {
      dragEnabled
    } = this.option();
    if (!$dragTarget) {
      return;
    }
    const config3 = {
      dragEnabled,
      handle: $dragTarget.get(0),
      draggableElement: this._$content.get(0),
      positionController: this._positionController
    };
    if (this._drag) {
      this._drag.init(config3);
    } else {
      this._drag = new m_popup_drag_default(config3);
    }
    this.$overlayContent().toggleClass("dx-popup-draggable", dragEnabled);
  }
  _renderResize() {
    this._resizable = this._createComponent(this._$content, resizable_default, {
      handles: this.option("resizeEnabled") ? "all" : "none",
      onResizeEnd: (e) => {
        this._resizeEndHandler(e);
        this._observeContentResize(true);
      },
      onResize: (e) => {
        this._setContentHeight();
        this._actions.onResize(e);
      },
      onResizeStart: (e) => {
        this._observeContentResize(false);
        this._actions.onResizeStart(e);
      },
      minHeight: 100,
      minWidth: 100,
      area: this._positionController.$dragResizeContainer,
      keepAspectRatio: false
    });
  }
  _resizeEndHandler(e) {
    const width = this._resizable.option("width");
    const height = this._resizable.option("height");
    width && this._setOptionWithoutOptionChange("width", width);
    height && this._setOptionWithoutOptionChange("height", height);
    this._cacheDimensions();
    this._positionController.resizeHandled();
    this._positionController.detectVisualPositionChange(e.event);
    this._actions.onResizeEnd(e);
  }
  _setContentHeight() {
    const {
      forceApplyBindings
    } = this.option();
    (forceApplyBindings || noop2)();
    const overlayContent = this.$overlayContent().get(0);
    const currentHeightStrategyClass = this._chooseHeightStrategy(overlayContent);
    this.$content().css(this._getHeightCssStyles(currentHeightStrategyClass, overlayContent));
    this._setHeightClasses(this.$overlayContent(), currentHeightStrategyClass);
  }
  _heightStrategyChangeOffset(currentHeightStrategyClass, popupVerticalPaddings) {
    return currentHeightStrategyClass === HEIGHT_STRATEGIES.flex ? -popupVerticalPaddings : 0;
  }
  _chooseHeightStrategy(overlayContent) {
    const isAutoWidth = "auto" === overlayContent.style.width || "" === overlayContent.style.width;
    let currentHeightStrategyClass = HEIGHT_STRATEGIES.static;
    if (this._isAutoHeight() && this.option("autoResizeEnabled")) {
      if (isAutoWidth) {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.inherit;
      } else {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.flex;
      }
    }
    return currentHeightStrategyClass;
  }
  _getHeightCssStyles(currentHeightStrategyClass, overlayContent) {
    let cssStyles = {};
    const contentMaxHeight = this._getOptionValue("maxHeight", overlayContent);
    const contentMinHeight = this._getOptionValue("minHeight", overlayContent);
    const popupHeightParts = this._splitPopupHeight();
    const toolbarsAndVerticalOffsetsHeight = popupHeightParts.header + popupHeightParts.footer + popupHeightParts.contentVerticalOffsets + popupHeightParts.popupVerticalOffsets + this._heightStrategyChangeOffset(currentHeightStrategyClass, popupHeightParts.popupVerticalPaddings);
    if (currentHeightStrategyClass === HEIGHT_STRATEGIES.static) {
      if (!this._isAutoHeight() || contentMaxHeight || contentMinHeight) {
        const overlayHeight = this.option("fullScreen") ? Math.min(getBoundingRect(overlayContent).height, m_window_default.getWindow().innerHeight) : getBoundingRect(overlayContent).height;
        const contentHeight = overlayHeight - toolbarsAndVerticalOffsetsHeight;
        cssStyles = {
          height: Math.max(0, contentHeight),
          minHeight: "auto",
          maxHeight: "auto"
        };
      }
    } else {
      const container = renderer_default(this._positionController.$visualContainer).get(0);
      const maxHeightValue = addOffsetToMaxHeight(contentMaxHeight, -toolbarsAndVerticalOffsetsHeight, container);
      const minHeightValue = addOffsetToMinHeight(contentMinHeight, -toolbarsAndVerticalOffsetsHeight, container);
      cssStyles = {
        height: "auto",
        minHeight: minHeightValue,
        maxHeight: maxHeightValue
      };
    }
    return cssStyles;
  }
  _setHeightClasses($container, currentClass) {
    let excessClasses = "";
    for (const name2 in HEIGHT_STRATEGIES) {
      if (HEIGHT_STRATEGIES[name2] !== currentClass) {
        excessClasses += ` ${HEIGHT_STRATEGIES[name2]}`;
      }
    }
    $container.removeClass(excessClasses).addClass(currentClass);
  }
  _isAutoHeight() {
    return "auto" === this.$overlayContent().get(0).style.height;
  }
  _splitPopupHeight() {
    const topToolbar = this.topToolbar();
    const bottomToolbar = this.bottomToolbar();
    return {
      header: getVisibleHeight(null === topToolbar || void 0 === topToolbar ? void 0 : topToolbar.get(0)),
      footer: getVisibleHeight(null === bottomToolbar || void 0 === bottomToolbar ? void 0 : bottomToolbar.get(0)),
      contentVerticalOffsets: getVerticalOffsets(this.$overlayContent().get(0), true),
      popupVerticalOffsets: getVerticalOffsets(this.$content().get(0), true),
      popupVerticalPaddings: getVerticalOffsets(this.$content().get(0), false)
    };
  }
  _isAllWindowCovered() {
    const {
      fullScreen
    } = this.option();
    return super._isAllWindowCovered() || fullScreen;
  }
  _renderDimensions() {
    if (this.option("fullScreen")) {
      this.$overlayContent().css({
        width: "100%",
        height: "100%",
        minWidth: "",
        maxWidth: "",
        minHeight: "",
        maxHeight: ""
      });
    } else {
      super._renderDimensions();
    }
    if (m_window_default.hasWindow()) {
      this._renderFullscreenWidthClass();
    }
  }
  _dimensionChanged() {
    this._renderGeometry({
      isDimensionChange: true
    });
  }
  _clean() {
    super._clean();
    this._observeContentResize(false);
  }
  _dispose() {
    super._dispose();
    this._toggleBodyScroll(true);
  }
  _renderFullscreenWidthClass() {
    const isFullScreen = getOuterWidth(this.$overlayContent()) === getWidth(window20);
    this.$overlayContent().toggleClass("dx-popup-fullscreen-width", isFullScreen);
  }
  _toggleSafariScrolling() {
    if (!this.option("enableBodyScroll")) {
      return;
    }
    super._toggleSafariScrolling();
  }
  _toggleBodyScroll(enabled) {
    if (!this._bodyOverflowManager) {
      return;
    }
    const {
      setOverflow,
      restoreOverflow
    } = this._bodyOverflowManager;
    if (enabled) {
      restoreOverflow();
    } else {
      setOverflow();
    }
  }
  refreshPosition() {
    this._renderPosition();
  }
  _optionChanged(args) {
    var _this$_resizable2;
    const {
      value: value2,
      name: name2
    } = args;
    switch (name2) {
      case "disabled":
        super._optionChanged(args);
        this._renderTitle();
        this._renderBottom();
        break;
      case "animation":
        this._updateResizeCallbackSkipCondition();
        break;
      case "enableBodyScroll":
        if (this.option("visible")) {
          this._toggleBodyScroll(value2);
        }
        break;
      case "showTitle":
      case "title":
      case "titleTemplate":
        this._renderTitle();
        this._renderGeometry();
        triggerResizeEvent2(this.$overlayContent());
        break;
      case "bottomTemplate":
        this._renderBottom();
        this._renderGeometry();
        triggerResizeEvent2(this.$overlayContent());
        break;
      case "container":
        super._optionChanged(args);
        if (this.option("resizeEnabled")) {
          var _this$_resizable;
          null === (_this$_resizable = this._resizable) || void 0 === _this$_resizable || _this$_resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        null === (_this$_resizable2 = this._resizable) || void 0 === _this$_resizable2 || _this$_resizable2.option(name2, value2);
        break;
      case "onTitleRendered":
        this._createTitleRenderAction();
        break;
      case "toolbarItems":
      case "useDefaultToolbarButtons":
      case "useFlatToolbarButtons": {
        const shouldRenderGeometry = !args.fullName.match(/^toolbarItems((\[\d+\])(\.(options|visible).*)?)?$/);
        this._renderTitle();
        this._renderBottom();
        if (shouldRenderGeometry) {
          this._renderGeometry();
          triggerResizeEvent2(this.$overlayContent());
        }
        break;
      }
      case "dragEnabled":
        this._renderDrag();
        break;
      case "dragAndResizeArea":
        this._positionController.dragAndResizeArea = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        this._positionController.positionContent();
        break;
      case "dragOutsideBoundary":
        this._positionController.dragOutsideBoundary = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "outsideDragFactor":
        this._positionController.outsideDragFactor = value2;
        break;
      case "resizeEnabled":
        this._renderResize();
        this._renderGeometry();
        break;
      case "autoResizeEnabled":
        this._renderGeometry();
        triggerResizeEvent2(this.$overlayContent());
        break;
      case "fullScreen":
        this._positionController.fullScreen = value2;
        this._toggleFullScreenClass(value2);
        this._toggleSafariScrolling();
        this._renderGeometry();
        triggerResizeEvent2(this.$overlayContent());
        break;
      case "showCloseButton":
        this._renderTitle();
        break;
      case "preventScrollEvents":
        super._optionChanged(args);
        this._toggleContentScrollClass();
        break;
      default:
        super._optionChanged(args);
    }
  }
  bottomToolbar() {
    return this._$bottom;
  }
  topToolbar() {
    return this._$title;
  }
  $content() {
    return this._$popupContent;
  }
  content() {
    return getPublicElement(this.$content());
  }
  $overlayContent() {
    return this._$content;
  }
  getFocusableElements() {
    return this.$wrapper().find("[tabindex]").filter((index2, item) => item.getAttribute("tabindex") >= 0);
  }
};
component_registrator_default("dxPopup", Popup);
var m_popup_default = Popup;

// node_modules/devextreme/esm/__internal/ui/resizable/utils.js
var borderWidthStyles = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};

// node_modules/devextreme/esm/__internal/ui/popover/m_popover_position_controller.js
var _excluded6 = ["shading", "target", "$arrow"];
var WEIGHT_OF_SIDES = {
  left: -1,
  top: -1,
  center: 0,
  right: 1,
  bottom: 1
};
var POPOVER_POSITION_ALIASES = {
  top: {
    my: "bottom center",
    at: "top center",
    collision: "fit flip"
  },
  bottom: {
    my: "top center",
    at: "bottom center",
    collision: "fit flip"
  },
  right: {
    my: "left center",
    at: "right center",
    collision: "flip fit"
  },
  left: {
    my: "right center",
    at: "left center",
    collision: "flip fit"
  }
};
var POPOVER_DEFAULT_BOUNDARY_OFFSET = {
  h: 10,
  v: 10
};
var PopoverPositionController = class extends OverlayPositionController {
  constructor(_ref) {
    let {
      shading,
      target,
      $arrow
    } = _ref, args = _objectWithoutPropertiesLoose(_ref, _excluded6);
    super(args);
    this._props = _extends({}, this._props, {
      shading,
      target
    });
    this._$arrow = $arrow;
    this._positionSide = void 0;
    this.updatePosition(this._props.position);
  }
  positionWrapper() {
    if (this._props.shading) {
      this._$wrapper.css({
        top: 0,
        left: 0
      });
    }
  }
  updateTarget(target) {
    this._props.target = target;
    this.updatePosition(this._props.position);
  }
  _renderBoundaryOffset() {
  }
  _getContainerPosition() {
    const offset2 = pairToObject(this._position.offset || "");
    let {
      h: hOffset,
      v: vOffset
    } = offset2;
    const isVerticalSide = this._isVerticalSide();
    const isHorizontalSide = this._isHorizontalSide();
    if (isVerticalSide || isHorizontalSide) {
      const isPopoverInside = this._isPopoverInside();
      const sign2 = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];
      const arrowSize = isVerticalSide ? getHeight(this._$arrow) : getWidth(this._$arrow);
      const arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);
      const arrowOffset = sign2 * (arrowSize - arrowSizeCorrection);
      isVerticalSide ? vOffset += arrowOffset : hOffset += arrowOffset;
    }
    return extend({}, this._position, {
      offset: `${hOffset} ${vOffset}`
    });
  }
  _getContentBorderWidth(side) {
    const borderWidth = this._$content.css(borderWidthStyles[side]);
    return parseInt(borderWidth) || 0;
  }
  _isPopoverInside() {
    const my = position_default.setup.normalizeAlign(this._position.my);
    const at = position_default.setup.normalizeAlign(this._position.at);
    return my.h === at.h && my.v === at.v;
  }
  _isVerticalSide() {
    let side = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._positionSide;
    return "top" === side || "bottom" === side;
  }
  _isHorizontalSide() {
    let side = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._positionSide;
    return "left" === side || "right" === side;
  }
  _getDisplaySide(position2) {
    const my = position_default.setup.normalizeAlign(position2.my);
    const at = position_default.setup.normalizeAlign(position2.at);
    const weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1;
    const horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]);
    const verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);
    return horizontalWeight > verticalWeight ? at.h : at.v;
  }
  _normalizePosition(positionProp) {
    const defaultPositionConfig = {
      of: this._props.target,
      boundaryOffset: POPOVER_DEFAULT_BOUNDARY_OFFSET
    };
    let resultPosition;
    if (isDefined(positionProp)) {
      resultPosition = extend(true, {}, defaultPositionConfig, this._positionToObject(positionProp));
    } else {
      resultPosition = defaultPositionConfig;
    }
    this._positionSide = this._getDisplaySide(resultPosition);
    return resultPosition;
  }
  _positionToObject(positionProp) {
    if (isString(positionProp)) {
      return extend({}, POPOVER_POSITION_ALIASES[positionProp]);
    }
    return positionProp;
  }
};

// node_modules/devextreme/esm/__internal/ui/popover/m_popover.js
var POSITION_FLIP_MAP = {
  left: "right",
  top: "bottom",
  right: "left",
  bottom: "top",
  center: "center"
};
var Popover = class extends m_popup_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      shading: false,
      position: extend({}, POPOVER_POSITION_ALIASES.bottom),
      hideOnOutsideClick: true,
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          from: 1,
          to: 0
        }
      },
      showTitle: false,
      width: "auto",
      height: "auto",
      dragEnabled: false,
      resizeEnabled: false,
      fullScreen: false,
      hideOnParentScroll: true,
      arrowPosition: "",
      arrowOffset: 0,
      _fixWrapperPosition: true
    });
  }
  _defaultOptionsRules() {
    return [{
      device: {
        platform: "ios"
      },
      options: {
        arrowPosition: {
          boundaryOffset: {
            h: 20,
            v: -10
          },
          collision: "fit"
        }
      }
    }, {
      device: () => !hasWindow(),
      options: {
        animation: null
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useFlatToolbarButtons: true
      }
    }, {
      device: () => isMaterial(),
      options: {
        useDefaultToolbarButtons: true,
        showCloseButton: false
      }
    }];
  }
  _init() {
    super._init();
    this._renderArrow();
    this._timeouts = {};
    this.$element().addClass("dx-popover");
    this.$wrapper().addClass("dx-popover-wrapper");
    const {
      toolbarItems
    } = this.option();
    const isInteractive = null === toolbarItems || void 0 === toolbarItems ? void 0 : toolbarItems.length;
    this.setAria("role", isInteractive ? "dialog" : "tooltip");
  }
  _render() {
    super._render.apply(this, arguments);
    this._detachEvents(this.option("target"));
    this._attachEvents();
  }
  _detachEvents(target) {
    this._detachEvent(target, "show");
    this._detachEvent(target, "hide");
  }
  _attachEvents() {
    this._attachEvent("show");
    this._attachEvent("hide");
  }
  _createEventHandler(name2) {
    const action = this._createAction(() => {
      const delay = this._getEventDelay(`${name2}Event`);
      this._clearEventsTimeouts();
      if (delay) {
        this._timeouts[name2] = setTimeout(() => {
          this[name2]();
        }, delay);
      } else {
        this[name2]();
      }
    }, {
      validatingTargetName: "target"
    });
    return (e) => {
      action({
        event: e,
        target: renderer_default(e.currentTarget)
      });
    };
  }
  _attachEvent(name2) {
    const {
      target,
      shading,
      disabled,
      hideEvent
    } = this.option();
    const shouldIgnoreHideEvent = shading && "hide" === name2;
    if (shouldIgnoreHideEvent && hideEvent) {
      ui_errors_default.log("W1020");
    }
    const event = shouldIgnoreHideEvent ? null : this._getEventName(`${name2}Event`);
    if (!event || disabled) {
      return;
    }
    const EVENT_HANDLER_NAME = this._getEventHandlerName(name2);
    this[EVENT_HANDLER_NAME] = this._createEventHandler(name2);
    const eventName = addNamespace2(event, this.NAME);
    const isSelector = isString(target);
    if (isSelector) {
      m_events_engine_default.on(dom_adapter_default.getDocument(), eventName, target, this[EVENT_HANDLER_NAME]);
    } else {
      m_events_engine_default.on(getPublicElement(renderer_default(target)), eventName, this[EVENT_HANDLER_NAME]);
    }
  }
  _detachEvent(target, name2, event) {
    let eventName = event || this._getEventName(`${name2}Event`);
    if (!eventName) {
      return;
    }
    eventName = addNamespace2(eventName, this.NAME);
    const EVENT_HANDLER_NAME = this._getEventHandlerName(name2);
    const isSelector = isString(target);
    if (isSelector) {
      m_events_engine_default.off(dom_adapter_default.getDocument(), eventName, target, this[EVENT_HANDLER_NAME]);
    } else {
      m_events_engine_default.off(getPublicElement(renderer_default(target)), eventName, this[EVENT_HANDLER_NAME]);
    }
  }
  _getEventHandlerName(name2) {
    return `_${name2}EventHandler`;
  }
  _getEventNameByOption(optionValue) {
    return isObject(optionValue) ? optionValue.name : optionValue;
  }
  _getEventName(optionName) {
    const optionValue = this.option(optionName);
    return this._getEventNameByOption(optionValue);
  }
  _getEventDelay(optionName) {
    const optionValue = this.option(optionName);
    return isObject(optionValue) && optionValue.delay;
  }
  _renderArrow() {
    this._$arrow = renderer_default("<div>").addClass("dx-popover-arrow").prependTo(this.$overlayContent());
  }
  _documentDownHandler(e) {
    if (this._isOutsideClick(e)) {
      return super._documentDownHandler(e);
    }
    return true;
  }
  _isOutsideClick(e) {
    const {
      target
    } = this.option();
    return !renderer_default(e.target).closest(target).length;
  }
  _animate(animation2) {
    if (null !== animation2 && void 0 !== animation2 && animation2.to && "object" === typeof animation2.to) {
      extend(animation2.to, {
        position: this._getContainerPosition()
      });
    }
    super._animate.apply(this, arguments);
  }
  _stopAnimation() {
    super._stopAnimation.apply(this, arguments);
  }
  _renderTitle() {
    this.$wrapper().toggleClass("dx-popover-without-title", !this.option("showTitle"));
    super._renderTitle();
  }
  _renderPosition() {
    let shouldUpdateDimensions = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;
    super._renderPosition();
    this._renderOverlayPosition(shouldUpdateDimensions);
    this._actions.onPositioned();
  }
  _renderOverlayPosition(shouldUpdateDimensions) {
    this._resetOverlayPosition(shouldUpdateDimensions);
    this._updateContentSize(shouldUpdateDimensions);
    const contentPosition = this._getContainerPosition();
    const resultLocation = position_default.setup(this.$overlayContent(), contentPosition);
    const positionSide = this._getSideByLocation(resultLocation);
    this._togglePositionClass(`dx-position-${positionSide}`);
    this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);
    const isArrowVisible = this._isHorizontalSide() || this._isVerticalSide();
    if (isArrowVisible) {
      this._renderArrowPosition(positionSide);
    }
  }
  _resetOverlayPosition(shouldUpdateDimensions) {
    this._setContentHeight(shouldUpdateDimensions);
    this._togglePositionClass(`dx-position-${this._positionController._positionSide}`);
    move(this.$overlayContent(), {
      left: 0,
      top: 0
    });
    this._$arrow.css({
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    });
  }
  _updateContentSize(shouldUpdateDimensions) {
    if (!this.$content() || !shouldUpdateDimensions) {
      return;
    }
    const containerLocation = position_default.calculate(this.$overlayContent(), this._getContainerPosition());
    if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {
      const newContainerWidth = getWidth(this.$overlayContent()) - containerLocation.h.oversize;
      setWidth(this.$overlayContent(), newContainerWidth);
    }
    if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {
      const newOverlayContentHeight = getHeight(this.$overlayContent()) - containerLocation.v.oversize;
      const newPopupContentHeight = getHeight(this.$content()) - containerLocation.v.oversize;
      setHeight(this.$overlayContent(), newOverlayContentHeight);
      setHeight(this.$content(), newPopupContentHeight);
    }
  }
  _getContainerPosition() {
    return this._positionController._getContainerPosition();
  }
  _getHideOnParentScrollTarget() {
    return renderer_default(this._positionController._position.of || super._getHideOnParentScrollTarget());
  }
  _getSideByLocation(location) {
    const isFlippedByVertical = location.v.flip;
    const isFlippedByHorizontal = location.h.flip;
    return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionController._positionSide] : this._positionController._positionSide;
  }
  _togglePositionClass(positionClass) {
    this.$wrapper().removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom").addClass(positionClass);
  }
  _toggleFlippedClass(isFlippedHorizontal, isFlippedVertical) {
    this.$wrapper().toggleClass("dx-popover-flipped-horizontal", isFlippedHorizontal).toggleClass("dx-popover-flipped-vertical", isFlippedVertical);
  }
  _renderArrowPosition(side) {
    const arrowRect = getBoundingRect(this._$arrow.get(0));
    const arrowFlip = -(this._isVerticalSide(side) ? arrowRect.height : arrowRect.width);
    this._$arrow.css(POSITION_FLIP_MAP[side], arrowFlip);
    const axis = this._isVerticalSide(side) ? "left" : "top";
    const sizeProperty = this._isVerticalSide(side) ? "width" : "height";
    const $target = renderer_default(this._positionController._position.of);
    const targetOffset = position_default.offset($target) ?? {
      top: 0,
      left: 0
    };
    const contentOffset = position_default.offset(this.$overlayContent());
    const arrowSize = arrowRect[sizeProperty];
    const contentLocation = null === contentOffset || void 0 === contentOffset ? void 0 : contentOffset[axis];
    const contentSize = getBoundingRect(this.$overlayContent().get(0))[sizeProperty];
    const targetLocation = targetOffset[axis];
    const targetElement = $target.get(0);
    const targetSize = targetElement && !targetElement.preventDefault ? getBoundingRect(targetElement)[sizeProperty] : 0;
    const min = Math.max(contentLocation, targetLocation);
    const max = Math.min(contentLocation + contentSize, targetLocation + targetSize);
    let arrowLocation;
    const {
      arrowPosition
    } = this.option();
    if ("start" === arrowPosition) {
      arrowLocation = min - contentLocation;
    } else if ("end" === arrowPosition) {
      arrowLocation = max - contentLocation - arrowSize;
    } else {
      arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2;
    }
    const borderWidth = this._positionController._getContentBorderWidth(side);
    const {
      arrowOffset
    } = this.option();
    const finalArrowLocation = fitIntoRange(arrowLocation - borderWidth + arrowOffset, borderWidth, contentSize - arrowSize - 2 * borderWidth);
    this._$arrow.css(axis, finalArrowLocation);
  }
  _isPopoverInside() {
    return this._positionController._isPopoverInside();
  }
  _setContentHeight(fullUpdate) {
    if (fullUpdate) {
      super._setContentHeight();
    }
  }
  _getPositionControllerConfig() {
    const {
      shading,
      target
    } = this.option();
    return extend({}, super._getPositionControllerConfig(), {
      target,
      shading,
      $arrow: this._$arrow
    });
  }
  _initPositionController() {
    this._positionController = new PopoverPositionController(this._getPositionControllerConfig());
  }
  _renderWrapperDimensions() {
    if (this.option("shading")) {
      this.$wrapper().css({
        width: "100%",
        height: "100%"
      });
    }
  }
  _isVerticalSide(side) {
    return this._positionController._isVerticalSide(side);
  }
  _isHorizontalSide(side) {
    return this._positionController._isHorizontalSide(side);
  }
  _clearEventTimeout(name2) {
    clearTimeout(this._timeouts[name2]);
  }
  _clearEventsTimeouts() {
    this._clearEventTimeout("show");
    this._clearEventTimeout("hide");
  }
  _clean() {
    this._detachEvents(this.option("target"));
    super._clean.apply(this, arguments);
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "arrowPosition":
      case "arrowOffset":
        this._renderGeometry();
        break;
      case "fullScreen":
        if (value2) {
          this.option("fullScreen", false);
        }
        break;
      case "target":
        if (previousValue) {
          this._detachEvents(previousValue);
        }
        this._positionController.updateTarget(value2);
        this._invalidate();
        break;
      case "showEvent":
      case "hideEvent": {
        const eventName = name2.substring(0, 4);
        const event = this._getEventNameByOption(previousValue);
        this.hide();
        const {
          target
        } = this.option();
        this._detachEvent(target, eventName, event);
        this._attachEvent(eventName);
        break;
      }
      case "visible":
        this._clearEventTimeout(value2 ? "show" : "hide");
        super._optionChanged(args);
        break;
      case "disabled":
        this._detachEvents(this.option("target"));
        this._attachEvents();
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  show(target) {
    if (target) {
      this.option("target", target);
    }
    return super.show();
  }
};
component_registrator_default("dxPopover", Popover);
var m_popover_default = Popover;

// node_modules/devextreme/esm/ui/popover/ui.popover.js
var ui_popover_default = m_popover_default;

// node_modules/devextreme/esm/__internal/ui/m_tooltip.js
var Tooltip = class extends ui_popover_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      toolbarItems: [],
      showCloseButton: false,
      enableBodyScroll: true,
      showTitle: false,
      title: null,
      titleTemplate: null,
      onTitleRendered: null,
      bottomTemplate: null,
      preventScrollEvents: false,
      propagateOutsideClick: true
    });
  }
  _render() {
    this.$element().addClass("dx-tooltip");
    this.$wrapper().addClass("dx-tooltip-wrapper");
    super._render();
  }
  _renderContent() {
    super._renderContent();
    this._toggleAriaAttributes();
  }
  _toggleAriaDescription(showing) {
    const {
      target
    } = this.option();
    const $target = renderer_default(target);
    const label = showing ? this._contentId : void 0;
    if (!isWindow($target.get(0))) {
      this.setAria("describedby", label, $target);
    }
  }
  _toggleAriaAttributes() {
    this._contentId = `dx-${new guid_default2()}`;
    this.$overlayContent().attr({
      id: this._contentId
    });
    this._toggleAriaDescription(true);
  }
};
component_registrator_default("dxTooltip", Tooltip);
var m_tooltip_default = Tooltip;

// node_modules/devextreme/esm/ui/tooltip.js
var tooltip_default = m_tooltip_default;

// node_modules/devextreme-react/esm/core/component.js
var React6 = __toESM(require_react());
var import_react8 = __toESM(require_react());

// node_modules/devextreme-react/esm/core/component-base.js
var React4 = __toESM(require_react());

// node_modules/devextreme/esm/common/core/events.js
var on = m_events_engine_default.on;
var one = m_events_engine_default.one;
var off = m_events_engine_default.off;
var trigger = m_events_engine_default.trigger;
var Event = m_events_engine_default.Event;

// node_modules/devextreme/esm/events/events.types.js
var triggerHandler = m_events_engine_default.triggerHandler;

// node_modules/devextreme-react/esm/core/component-base.js
var import_react6 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/devextreme-react/esm/core/use-option-scanning.js
var import_react2 = __toESM(require_react());

// node_modules/devextreme-react/esm/core/configuration/utils.js
function mergeNameParts(...args) {
  return args.filter((value2) => value2).join(".");
}
function parseOptionName(name2) {
  const parts = name2.split("[");
  if (parts.length === 1) {
    return {
      isCollectionItem: false,
      name: name2
    };
  }
  return {
    isCollectionItem: true,
    name: parts[0],
    index: Number(parts[1].slice(0, -1))
  };
}
var shallowEquals2 = (first, second) => {
  if (Object.keys(first).length !== Object.keys(second).length) {
    return false;
  }
  return Object.keys(first).every((key) => first[key] === second[key]);
};

// node_modules/devextreme-react/esm/core/configuration/config-node.js
var React = __toESM(require_react());

// node_modules/devextreme-react/esm/core/widget-config.js
var elementPropNames = ["style", "id"];
var classNamePropName = "className";
var refPropName = ["dropZone", "dialogTrigger"];
var internalProps = {
  WidgetClass: {},
  isPortalComponent: false,
  defaults: {},
  templateProps: [],
  expectedChildren: {},
  subscribableOptions: [],
  independentEvents: [],
  useRequestAnimationFrameFlag: false,
  clearExtensions: () => void 0,
  renderChildren: () => void 0,
  beforeCreateWidget: () => void 0,
  afterCreateWidget: () => void 0,
  children: null
};
function isIgnoredProp(name2) {
  return name2 === "children" || name2 === classNamePropName || elementPropNames.includes(name2) || Object.prototype.hasOwnProperty.call(internalProps, name2);
}
function getRefElement(value2) {
  if (value2?.current) {
    if (value2.current.instance?.().element()) {
      return value2.current.instance().element();
    }
    return value2.current;
  }
  return value2;
}
function separateProps(props, defaultsProps, templateProps) {
  templateProps = templateProps || [];
  const defaults = {};
  const options2 = {};
  const templates = {};
  const knownTemplates = {};
  templateProps.forEach((value2) => {
    knownTemplates[value2.component] = true;
    knownTemplates[value2.render] = true;
  });
  Object.keys(props).forEach((key) => {
    const defaultOptionName = defaultsProps ? defaultsProps[key] : null;
    const value2 = props[key];
    if (isIgnoredProp(key)) {
      return;
    }
    if (defaultOptionName) {
      defaults[defaultOptionName] = value2;
      return;
    }
    if (knownTemplates[key]) {
      templates[key] = value2;
      return;
    }
    if (refPropName.includes(key)) {
      options2[key] = getRefElement(value2);
      return;
    }
    options2[key] = props[key];
  });
  return { options: options2, defaults, templates };
}
function getClassName(props) {
  return props[classNamePropName];
}

// node_modules/devextreme-react/esm/core/configuration/react/templates.js
function getAnonymousTemplate(props, templateMeta, hasTranscludedContent) {
  if (templateMeta.tmplOption === "template" && hasTranscludedContent) {
    return {
      optionName: templateMeta.tmplOption,
      isAnonymous: true,
      type: "children",
      content: props.children
    };
  }
  if (props[templateMeta.render]) {
    return {
      optionName: templateMeta.tmplOption,
      isAnonymous: true,
      type: "render",
      content: props[templateMeta.render]
    };
  }
  if (props[templateMeta.component]) {
    return {
      optionName: templateMeta.tmplOption,
      isAnonymous: true,
      type: "component",
      content: props[templateMeta.component]
    };
  }
  return null;
}
function getNamedTemplate(props) {
  if (!props.name) {
    return null;
  }
  if (props.component) {
    return {
      optionName: props.name,
      isAnonymous: false,
      type: "component",
      content: props.component
    };
  }
  if (props.render) {
    return {
      optionName: props.name,
      isAnonymous: false,
      type: "render",
      content: props.render
    };
  }
  return {
    optionName: props.name,
    isAnonymous: false,
    type: "children",
    content: props.children
  };
}

// node_modules/devextreme-react/esm/core/contexts.js
var import_react = __toESM(require_react());
var RemovalLockerContext = (0, import_react.createContext)(void 0);
var RestoreTreeContext = (0, import_react.createContext)(void 0);
var NestedOptionContext = (0, import_react.createContext)({
  parentExpectedChildren: {},
  parentFullName: "",
  onChildOptionsReady: () => void 0,
  onNamedTemplateReady: () => void 0,
  getOptionComponentKey: () => 0,
  treeUpdateToken: Symbol("initial tree update token"),
  parentType: "component"
});
var TemplateRenderingContext = (0, import_react.createContext)({
  isTemplateRendering: false
});

// node_modules/devextreme-react/esm/core/configuration/config-node.js
function buildNodeFullName(node) {
  let currentNode = node;
  let fullName = "";
  while (currentNode && currentNode.name) {
    fullName = currentNode.name.concat(typeof currentNode.index === "number" ? `[${currentNode.index}]` : "", fullName ? `.${fullName}` : "");
    currentNode = currentNode.parentNode;
  }
  return fullName;
}
var renderContextValue = {
  isTemplateRendering: true
};
var createConfigBuilder = (optionElement, parentFullName) => {
  const separatedValues = separateProps(optionElement.props, optionElement.descriptor.initialValuesProps, optionElement.descriptor.templates);
  return {
    node: {
      name: optionElement.descriptor.name,
      predefinedOptions: optionElement.descriptor.predefinedValuesProps,
      initialOptions: separatedValues.defaults,
      options: separatedValues.options,
      templates: [],
      configCollections: {},
      configs: {}
    },
    configCollectionMaps: {},
    getConfigCollectionData(name2) {
      if (!this.node.configCollections[name2]) {
        this.node.configCollections[name2] = [];
        this.configCollectionMaps[name2] = {};
      }
      return [this.node.configCollections[name2], this.configCollectionMaps[name2]];
    },
    addChildNode(name2, childNode) {
      childNode.parentNode = this.node;
      this.node.configs[name2] = childNode;
    },
    addCollectionNode(name2, collectionNode, collectionNodeKey) {
      const [collection, collectionMap] = this.getConfigCollectionData(name2);
      const itemIndex = collectionMap[collectionNodeKey] ?? collection.length;
      collectionNode.index = itemIndex;
      collectionNode.parentNode = this.node;
      if (itemIndex < collection.length) {
        collection[itemIndex] = collectionNode;
      } else {
        collectionMap[collectionNodeKey] = itemIndex;
        collection.push(collectionNode);
      }
    },
    addTemplate(template) {
      this.node.templates.push(template);
    },
    updateAnonymousTemplates(hasTemplateRendered) {
      this.node.templates = this.node.templates.filter((template) => !template.isAnonymous);
      optionElement.descriptor.templates.forEach((templateMeta) => {
        const template = getAnonymousTemplate(optionElement.props, templateMeta, hasTemplateRendered && (optionElement.descriptor.isCollection || parentFullName.length > 0));
        if (template) {
          this.node.templates.push(this.wrapTemplate(template));
        }
      });
    },
    wrapTemplate(template) {
      return template.type === "children" ? {
        ...template,
        content: React.createElement(TemplateRenderingContext.Provider, {
          value: renderContextValue
        }, template.content)
      } : template;
    }
  };
};

// node_modules/devextreme-react/esm/core/use-option-scanning.js
function useOptionScanning(optionElement, getHasTemplate, parentUpdateToken, parentType) {
  const parentContext = (0, import_react2.useContext)(NestedOptionContext);
  const { parentFullName } = parentContext;
  const updateToken = Symbol("update token");
  const configBuilder = createConfigBuilder(optionElement, parentFullName);
  const childComponentCounter = (0, import_react2.useRef)(0);
  const context2 = {
    parentExpectedChildren: optionElement.descriptor.expectedChildren,
    parentFullName: mergeNameParts(parentFullName, optionElement.descriptor.name),
    parentType,
    treeUpdateToken: updateToken,
    getOptionComponentKey: () => {
      childComponentCounter.current += 1;
      return childComponentCounter.current;
    },
    onNamedTemplateReady: (template, childUpdateToken) => {
      if (childUpdateToken !== updateToken) {
        return;
      }
      if (template) {
        configBuilder.addTemplate(template);
      }
    },
    onChildOptionsReady: (childConfigNode, childDescriptor, childUpdateToken, childComponentKey) => {
      if (childUpdateToken !== updateToken) {
        return;
      }
      const { isCollection, name: name2 } = childDescriptor;
      if (isCollection) {
        configBuilder.addCollectionNode(name2, childConfigNode, childComponentKey);
        return;
      }
      configBuilder.addChildNode(name2, childConfigNode);
    }
  };
  (0, import_react2.useLayoutEffect)(() => {
    configBuilder.updateAnonymousTemplates(getHasTemplate());
  }, [parentUpdateToken]);
  return [configBuilder.node, context2];
}

// node_modules/devextreme-react/esm/core/configuration/tree.js
function buildTemplates(node, optionsAccum, templatesAccum) {
  const fullName = buildNodeFullName(node);
  node.templates.forEach((template) => {
    if (template.isAnonymous) {
      const templateName = mergeNameParts(fullName, template.optionName);
      optionsAccum[template.optionName] = templateName;
      templatesAccum[templateName] = template;
    } else {
      templatesAccum[template.optionName] = template;
    }
  });
}
function buildNode(node, templatesAccum, ignoreInitialValues) {
  const result2 = {};
  Object.keys(node.predefinedOptions).forEach((key) => {
    result2[key] = node.predefinedOptions[key];
  });
  Object.keys(node.configs).forEach((key) => {
    result2[key] = buildNode(node.configs[key], templatesAccum, ignoreInitialValues);
  });
  Object.keys(node.configCollections).forEach((key) => {
    result2[key] = node.configCollections[key].map((item) => buildNode(item, templatesAccum, ignoreInitialValues));
  });
  if (!ignoreInitialValues) {
    Object.keys(node.initialOptions).forEach((key) => {
      result2[key] = node.initialOptions[key];
    });
  }
  Object.keys(node.options).forEach((key) => {
    result2[key] = node.options[key];
  });
  buildTemplates(node, result2, templatesAccum);
  return result2;
}
function buildConfig(root, ignoreInitialValues) {
  const templatesAccum = {};
  const options2 = buildNode(root, templatesAccum, ignoreInitialValues);
  return {
    templates: templatesAccum,
    options: options2
  };
}
var ValueType;
(function(ValueType2) {
  ValueType2[ValueType2["Simple"] = 0] = "Simple";
  ValueType2[ValueType2["Complex"] = 1] = "Complex";
  ValueType2[ValueType2["Array"] = 2] = "Array";
})(ValueType || (ValueType = {}));
function findValueInObject(obj, path) {
  const key = path.shift();
  if (!key) {
    return {
      value: obj,
      type: ValueType.Simple
    };
  }
  if (obj instanceof Object && Object.keys(obj).includes(key)) {
    return findValueInObject(obj[key], path);
  }
  return void 0;
}
function findValue(node, path) {
  const name2 = path.shift();
  if (!name2) {
    return {
      value: buildConfig(node, true).options,
      type: ValueType.Complex
    };
  }
  const optionInfo = parseOptionName(name2);
  if (optionInfo.name in node.options) {
    const options2 = optionInfo.isCollectionItem ? node.options[optionInfo.name][optionInfo.index] : node.options[optionInfo.name];
    return findValueInObject(options2, path);
  }
  if (optionInfo.isCollectionItem) {
    const collection = node.configCollections[optionInfo.name];
    if (!collection) {
      return void 0;
    }
    const item = collection[optionInfo.index];
    if (!item) {
      return void 0;
    }
    return findValue(item, path);
  }
  const child = node.configs[optionInfo.name];
  if (child) {
    return findValue(child, path);
  }
  const childCollection = node.configCollections[optionInfo.name];
  if (childCollection) {
    if (path.length !== 0) {
      return void 0;
    }
    return {
      value: childCollection.map((item) => buildNode(item, {}, true)),
      type: ValueType.Array
    };
  }
  return void 0;
}

// node_modules/devextreme-react/esm/core/configuration/comparer.js
function compareTemplates(current2, currentFullName, prev, changesAccum) {
  const currentTemplatesOptions = {};
  const currentTemplates = {};
  const prevTemplatesOptions = {};
  const prevTemplates = {};
  buildTemplates(current2, currentTemplatesOptions, currentTemplates);
  buildTemplates(prev, prevTemplatesOptions, prevTemplates);
  changesAccum.addRemovedValues(currentTemplatesOptions, prevTemplatesOptions, currentFullName);
  Object.keys(currentTemplatesOptions).forEach((key) => {
    if (currentTemplatesOptions[key] === prevTemplatesOptions[key]) {
      return;
    }
    changesAccum.options[mergeNameParts(currentFullName, key)] = currentTemplatesOptions[key];
  });
  Object.keys(currentTemplates).forEach((key) => {
    const currentTemplate = currentTemplates[key];
    const prevTemplate = prevTemplates[key];
    if (prevTemplate && currentTemplate.content === prevTemplate.content) {
      return;
    }
    changesAccum.templates[key] = currentTemplate;
  });
}
function compare2(current2, prev, changesAccum) {
  const fullName = buildNodeFullName(current2);
  if (!prev) {
    changesAccum.options[fullName] = buildNode(current2, changesAccum.templates, true);
    return;
  }
  changesAccum.addRemovedValues(current2.options, prev.options, fullName);
  changesAccum.addRemovedValues(current2.configCollections, prev.configCollections, fullName);
  changesAccum.addRemovedValues(current2.configs, prev.configs, fullName);
  compareCollections(current2, fullName, prev, changesAccum);
  Object.keys(current2.configs).forEach((key) => {
    compare2(current2.configs[key], prev.configs[key], changesAccum);
  });
  Object.keys(current2.options).forEach((key) => {
    if (current2.options[key] === prev.options[key]) {
      return;
    }
    changesAccum.options[mergeNameParts(fullName, key)] = current2.options[key];
  });
  compareTemplates(current2, fullName, prev, changesAccum);
}
function appendRemovedValues(current2, prev, path, changesAccum) {
  const removedKeys = Object.keys(prev).filter((key) => !Object.keys(current2).includes(key));
  removedKeys.forEach((key) => {
    changesAccum.push(mergeNameParts(path, key));
  });
}
function getChanges(current2, prev) {
  const changesAccum = {
    options: {},
    removedOptions: [],
    templates: {},
    addRemovedValues(currentOptions, prevOptions, path) {
      appendRemovedValues(currentOptions, prevOptions, path, this.removedOptions);
    }
  };
  compare2(current2, prev, changesAccum);
  return changesAccum;
}
function compareCollections(current2, currentFullName, prev, changesAccum) {
  Object.keys(current2.configCollections).forEach((key) => {
    const currentCollection = current2.configCollections[key];
    const prevCollection = prev.configCollections[key] || [];
    if (!currentCollection || currentCollection.length !== prevCollection.length) {
      const updatedCollection = [];
      currentCollection.forEach((item) => {
        const config3 = buildNode(item, changesAccum.templates, true);
        updatedCollection.push(config3);
      });
      changesAccum.options[mergeNameParts(currentFullName, key)] = updatedCollection;
      return;
    }
    for (let i = 0; i < currentCollection.length; i += 1) {
      compare2(currentCollection[i], prevCollection[i], changesAccum);
    }
  });
}

// node_modules/devextreme-react/esm/core/helpers.js
function generateID() {
  return Math.random().toString(36).substring(2);
}
var DoubleKeyMap = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  set({ key1, key2 }, value2) {
    let innerMap = this._map.get(key1);
    if (!innerMap) {
      innerMap = /* @__PURE__ */ new Map();
      this._map.set(key1, innerMap);
    }
    innerMap.set(key2, value2);
  }
  get({ key1, key2 }) {
    const innerMap = this._map.get(key1);
    return innerMap ? innerMap.get(key2) : void 0;
  }
  delete({ key1, key2 }) {
    const innerMap = this._map.get(key1);
    if (!innerMap) {
      return;
    }
    innerMap.delete(key2);
    if (innerMap.size === 0) {
      this._map.delete(key1);
    }
  }
  clear() {
    this._map.clear();
  }
  get empty() {
    return this._map.size === 0;
  }
  *[Symbol.iterator]() {
    for (const [key1, innerMap] of this._map) {
      for (const [key2, value2] of innerMap) {
        yield [{ key1, key2 }, value2];
      }
    }
  }
};
var TemplateInstantiationModels = class extends DoubleKeyMap {
};
function capitalizeFirstLetter(text) {
  if (text.length) {
    return `${text[0].toUpperCase()}${text.substr(1)}`;
  }
  return "";
}
function hasExpectedChildren(elementDescriptor) {
  return !!Object.keys(elementDescriptor.ExpectedChildren || {}).length;
}

// node_modules/devextreme-react/esm/core/options-manager.js
var optionsManagers = /* @__PURE__ */ new Set();
var guardTimeoutHandler = -1;
var innerGuardTimeoutHandler = -1;
function unscheduleGuards() {
  clearTimeout(guardTimeoutHandler);
  clearTimeout(innerGuardTimeoutHandler);
}
function scheduleGuards() {
  unscheduleGuards();
  guardTimeoutHandler = window.setTimeout(() => {
    innerGuardTimeoutHandler = window.setTimeout(() => {
      optionsManagers.forEach((optionManager) => optionManager.execGuards());
    });
  });
}
var OptionsManager = class {
  constructor() {
    this.guards = {};
    this.isUpdating = false;
    this.onOptionChanged = this.onOptionChanged.bind(this);
    this.wrapOptionValue = this.wrapOptionValue.bind(this);
  }
  setInstance(instance, config3, subscribableOptions, independentEvents) {
    this.instance = instance;
    this.currentConfig = config3;
    this.subscribableOptions = new Set(subscribableOptions);
    this.independentEvents = new Set(independentEvents);
    optionsManagers.add(this);
  }
  getInitialOptions(rootNode) {
    const config3 = buildConfig(rootNode, false);
    const options2 = {};
    Object.keys(config3.options).forEach((key) => {
      options2[key] = this.wrapOptionValue(key, config3.options[key]);
    });
    return options2;
  }
  getTemplateOptions(rootNode) {
    const config3 = buildConfig(rootNode, false);
    return config3.templates;
  }
  update(config3, dxtemplates) {
    const changedOptions = [];
    const optionChangedHandler = ({ value: value2, fullName }) => {
      changedOptions.push([fullName, value2]);
    };
    this.instance.on("optionChanged", optionChangedHandler);
    const changes = getChanges(config3, this.currentConfig);
    if (!changes.options && !changes.templates && !changes.removedOptions.length) {
      return;
    }
    this.instance.beginUpdate();
    this.isUpdating = true;
    changes.removedOptions.forEach((optionName) => {
      this.resetOption(optionName);
    });
    if (Object.keys(dxtemplates).length > 0) {
      this.setValue("integrationOptions", {
        templates: dxtemplates
      });
    }
    Object.keys(changes.options).forEach((key) => {
      this.setValue(key, changes.options[key]);
    });
    this.isUpdating = false;
    this.instance.off("optionChanged", optionChangedHandler);
    this.currentConfig = config3;
    changedOptions.forEach(([name2, value2]) => {
      const currentPropValue = config3.options[name2];
      if (Object.prototype.hasOwnProperty.call(config3.options, name2) && currentPropValue !== value2) {
        this.setValue(name2, currentPropValue);
      }
    });
    this.instance.endUpdate();
  }
  onOptionChanged(e) {
    if (this.isUpdating) {
      return;
    }
    let valueDescriptor = findValue(this.currentConfig, e.fullName.split("."));
    if (!valueDescriptor || valueDescriptor.value !== e.value) {
      this.callOptionChangeHandler(e.fullName, e.value);
    }
    valueDescriptor = findValue(this.currentConfig, e.fullName.split("."));
    if (!valueDescriptor) {
      return;
    }
    const { value: value2, type: type2 } = valueDescriptor;
    if (value2 instanceof Array && type2 === ValueType.Array) {
      for (let i = 0; i < value2.length; i += 1) {
        if (value2[i] !== e.value?.[i]) {
          this.addGuard(e.fullName, value2);
          return;
        }
      }
    } else if (type2 === ValueType.Complex && value2 instanceof Object) {
      Object.keys(value2).forEach((key) => {
        if (value2[key] === e.value?.[key]) {
          return;
        }
        this.addGuard(mergeNameParts(e.fullName, key), value2[key]);
      });
    } else {
      const valuesAreEqual = value2 === e.value;
      const valuesAreEqualObjects = !valuesAreEqual && value2 instanceof Object && e.value instanceof Object && shallowEquals2(value2, e.value);
      if (valuesAreEqual || valuesAreEqualObjects || this.instance.skipOptionsRollBack) {
        return;
      }
      this.addGuard(e.fullName, value2);
    }
  }
  get isInstanceSet() {
    return !!this.instance;
  }
  dispose() {
    optionsManagers.delete(this);
    Object.keys(this.guards).forEach((optionName) => {
      delete this.guards[optionName];
    });
    this.instance = null;
  }
  isOptionSubscribable(optionName) {
    return this.subscribableOptions.has(optionName);
  }
  isIndependentEvent(optionName) {
    return this.independentEvents.has(optionName);
  }
  callOptionChangeHandler(optionName, optionValue) {
    if (!this.isOptionSubscribable(optionName)) {
      return;
    }
    const parts = optionName.split(".");
    const propName = parts[parts.length - 1];
    if (propName.startsWith("on")) {
      return;
    }
    const eventName = `on${capitalizeFirstLetter(propName)}Change`;
    parts[parts.length - 1] = eventName;
    const changeEvent = findValue(this.currentConfig, parts);
    if (!changeEvent) {
      return;
    }
    if (typeof changeEvent.value !== "function") {
      throw new Error(`Invalid value for the ${eventName} property.
                ${eventName} must be a function.`);
    }
    changeEvent.value(optionValue);
  }
  wrapOptionValue(name2, value2) {
    if (name2.substr(0, 2) === "on" && typeof value2 === "function") {
      return (...args) => {
        if (!this.isUpdating || this.isIndependentEvent(name2)) {
          value2(...args);
        }
      };
    }
    return value2;
  }
  addGuard(optionName, optionValue) {
    if (this.guards[optionName] !== void 0) {
      return;
    }
    const handler = () => {
      this.setValue(optionName, optionValue);
      delete this.guards[optionName];
    };
    this.guards[optionName] = handler;
    scheduleGuards();
  }
  execGuards() {
    Object.values(this.guards).forEach((handler) => handler());
  }
  resetOption(name2) {
    if (this.isCollectionOption(name2)) {
      this.setValue(name2, []);
    } else {
      this.instance.resetOption(name2);
    }
  }
  isCollectionOption(name2) {
    const valueDescriptor = findValue(this.currentConfig, name2.split("."));
    return valueDescriptor?.type === ValueType.Array;
  }
  setValue(name2, value2) {
    if (this.guards[name2]) {
      delete this.guards[name2];
    }
    this.instance.option(name2, this.wrapOptionValue(name2, value2));
  }
};

// node_modules/devextreme-react/esm/core/template-manager.js
var React3 = __toESM(require_react());
var import_react4 = __toESM(require_react());

// node_modules/devextreme-react/esm/core/template-wrapper.js
var React2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var createHiddenNode = (containerNodeName, ref, defaultElement) => {
  const style = { display: "none" };
  switch (containerNodeName) {
    case "TABLE":
      return React2.createElement("tbody", { style, ref });
    case "TBODY":
      return React2.createElement("tr", { style, ref });
    default:
      return React2.createElement(defaultElement, { style, ref });
  }
};
var TemplateWrapperComponent = ({ templateFactory, data: data2, index: index2, container, onRemoved, onRendered }) => {
  const [removalListenerRequired, setRemovalListenerRequired] = (0, import_react3.useState)(false);
  const isRemovalLocked = (0, import_react3.useRef)(false);
  const removalLocker = (0, import_react3.useMemo)(() => ({
    lock() {
      isRemovalLocked.current = true;
    },
    unlock() {
      isRemovalLocked.current = false;
    }
  }), []);
  const element = (0, import_react3.useRef)();
  const hiddenNodeElement = (0, import_react3.useRef)();
  const removalListenerElement = (0, import_react3.useRef)();
  const onTemplateRemoved = (0, import_react3.useCallback)((_, args) => {
    if (args?.isUnmounting || isRemovalLocked.current) {
      return;
    }
    if (element.current) {
      off(element.current, DX_REMOVE_EVENT, onTemplateRemoved);
    }
    if (removalListenerElement.current) {
      off(removalListenerElement.current, DX_REMOVE_EVENT, onTemplateRemoved);
    }
    onRemoved();
  }, [onRemoved]);
  (0, import_react3.useLayoutEffect)(() => {
    const el = element.current;
    if (el && el.nodeType === Node.ELEMENT_NODE) {
      off(el, DX_REMOVE_EVENT, onTemplateRemoved);
      on(el, DX_REMOVE_EVENT, onTemplateRemoved);
    } else if (!removalListenerRequired) {
      setRemovalListenerRequired(true);
    } else if (removalListenerElement.current) {
      off(removalListenerElement.current, DX_REMOVE_EVENT, onTemplateRemoved);
      on(removalListenerElement.current, DX_REMOVE_EVENT, onTemplateRemoved);
    }
    return () => {
      const safeAppend = (child) => {
        if (child?.current && container && !container.contains(child.current)) {
          container.appendChild(child.current);
        }
      };
      safeAppend(element);
      safeAppend(hiddenNodeElement);
      safeAppend(removalListenerElement);
      if (el) {
        off(el, DX_REMOVE_EVENT, onTemplateRemoved);
      }
    };
  }, [onTemplateRemoved, removalListenerRequired, container]);
  (0, import_react3.useEffect)(() => {
    onRendered();
  }, [onRendered]);
  const hiddenNode = createHiddenNode(container?.nodeName, (node) => {
    hiddenNodeElement.current = node;
    element.current = node?.previousSibling;
  }, "div");
  const removalListener = removalListenerRequired ? createHiddenNode(container?.nodeName, (node) => {
    removalListenerElement.current = node;
  }, "span") : void 0;
  return (0, import_react_dom.createPortal)(React2.createElement(
    React2.Fragment,
    null,
    React2.createElement(
      RemovalLockerContext.Provider,
      { value: removalLocker },
      templateFactory({ data: data2, index: index2, onRendered }),
      hiddenNode,
      removalListener
    )
  ), container);
};
var TemplateWrapper2 = (0, import_react3.memo)(TemplateWrapperComponent);

// node_modules/devextreme-react/esm/core/config.js
var config2 = {
  useLegacyTemplateEngine: false
};
function getOption(optionName) {
  return config2[optionName];
}

// node_modules/devextreme-react/esm/core/template-manager.js
function normalizeProps2(props) {
  if (getOption("useLegacyTemplateEngine")) {
    const model = props.data;
    if (model && Object.prototype.hasOwnProperty.call(model, "key")) {
      model.dxkey = model.key;
    }
    return model;
  }
  return props;
}
var createMapKey = (key1, key2) => ({ key1, key2 });
var unsubscribeOnRemoval = (container, onRemoved) => {
  if (container.nodeType === Node.ELEMENT_NODE) {
    off(container, DX_REMOVE_EVENT, onRemoved);
  }
};
var subscribeOnRemoval = (container, onRemoved) => {
  if (container.nodeType === Node.ELEMENT_NODE) {
    on(container, DX_REMOVE_EVENT, onRemoved);
  }
};
var unwrapElement = (element) => element.get ? element.get(0) : element;
var getRandomId = () => `${generateID()}${generateID()}${generateID()}`;
var TemplateManager2 = ({ init: init2, onTemplatesRendered }) => {
  const mounted = (0, import_react4.useRef)(false);
  const [instantiationModels, setInstantiationModels] = (0, import_react4.useState)({
    collection: new TemplateInstantiationModels()
  });
  const [updateContext, setUpdateContext] = (0, import_react4.useState)();
  const widgetId = (0, import_react4.useRef)("");
  const templateFactories = (0, import_react4.useRef)({});
  const { collection } = instantiationModels;
  const getRenderFunc = (0, import_react4.useCallback)((templateKey2) => ({ model: data2, index: index2, container, onRendered }) => {
    const containerElement = unwrapElement(container);
    const key = createMapKey(data2, containerElement);
    const onRemoved = () => {
      if (collection.get(key)) {
        collection.delete(key);
        setInstantiationModels({ collection });
      }
    };
    const hostWidgetId = widgetId.current;
    collection.set(key, {
      templateKey: templateKey2,
      index: index2,
      componentKey: getRandomId(),
      onRendered: () => {
        unsubscribeOnRemoval(containerElement, onRemoved);
        if (hostWidgetId === widgetId.current) {
          onRendered?.();
        }
      },
      onRemoved
    });
    setInstantiationModels({ collection });
    return containerElement;
  }, [collection]);
  (0, import_react4.useMemo)(() => {
    function getTemplateFunction(template) {
      switch (template.type) {
        case "children":
          return () => template.content;
        case "render":
          return (props) => {
            normalizeProps2(props);
            return template.content(props.data, props.index);
          };
        case "component":
          return (props) => {
            props = normalizeProps2(props);
            return React3.createElement.bind(null, template.content)(props);
          };
        default:
          return () => React3.createElement(React3.Fragment);
      }
    }
    function createDXTemplates(templateOptions) {
      const factories = Object.entries(templateOptions).reduce((res, [key, template]) => ({
        ...res,
        [key]: getTemplateFunction(template)
      }), {});
      templateFactories.current = factories;
      const dxTemplates = Object.keys(factories).reduce((templates, templateKey2) => {
        templates[templateKey2] = { render: getRenderFunc(templateKey2) };
        return templates;
      }, {});
      return dxTemplates;
    }
    function clearInstantiationModels() {
      widgetId.current = getRandomId();
      instantiationModels.collection.clear();
      setInstantiationModels({ ...instantiationModels });
    }
    function updateTemplates(onUpdated) {
      if (mounted.current) {
        setUpdateContext({ onUpdated });
      }
    }
    init2({ createDXTemplates, clearInstantiationModels, updateTemplates });
  }, [init2, getRenderFunc]);
  (0, import_react4.useEffect)(() => {
    mounted.current = true;
    return () => {
      mounted.current = false;
    };
  }, []);
  (0, import_react4.useEffect)(() => {
    if (updateContext) {
      updateContext.onUpdated();
    }
    onTemplatesRendered();
  }, [updateContext, onTemplatesRendered]);
  if (instantiationModels.collection.empty) {
    return null;
  }
  return React3.createElement(React3.Fragment, null, Array.from(instantiationModels.collection).map(([{ key1: data2, key2: container }, { index: index2, templateKey: templateKey2, componentKey, onRendered, onRemoved }]) => {
    subscribeOnRemoval(container, onRemoved);
    const factory = templateFactories.current[templateKey2];
    if (factory) {
      return React3.createElement(TemplateWrapper2, { key: componentKey, templateFactory: factory, data: data2, index: index2, container, onRemoved, onRendered });
    }
    return null;
  }));
};

// node_modules/devextreme-react/esm/core/template.js
var import_react5 = __toESM(require_react());
var Template2 = (0, import_react5.memo)((props) => {
  const { onNamedTemplateReady, treeUpdateToken } = (0, import_react5.useContext)(NestedOptionContext);
  const { isTemplateRendering } = (0, import_react5.useContext)(TemplateRenderingContext);
  const template = getNamedTemplate(props);
  (0, import_react5.useLayoutEffect)(() => {
    if (!isTemplateRendering) {
      onNamedTemplateReady(template, treeUpdateToken);
    }
  }, [treeUpdateToken]);
  return null;
});

// node_modules/devextreme-react/esm/core/configuration/react/element.js
var ElementType;
(function(ElementType2) {
  ElementType2[ElementType2["Option"] = 0] = "Option";
  ElementType2[ElementType2["Template"] = 1] = "Template";
  ElementType2[ElementType2["Unknown"] = 2] = "Unknown";
})(ElementType || (ElementType = {}));
function getOptionInfo(elementDescriptor, props, parentExpectedChildren) {
  let name2 = elementDescriptor.OptionName;
  let isCollectionItem = elementDescriptor.IsCollectionItem;
  const expectation = parentExpectedChildren && parentExpectedChildren[name2];
  if (expectation) {
    isCollectionItem = expectation.isCollectionItem;
    if (expectation.optionName) {
      name2 = expectation.optionName;
    }
  }
  return {
    type: ElementType.Option,
    descriptor: {
      name: name2,
      isCollection: !!isCollectionItem,
      templates: elementDescriptor.TemplateProps || [],
      initialValuesProps: elementDescriptor.DefaultsProps || {},
      predefinedValuesProps: elementDescriptor.PredefinedProps || {},
      expectedChildren: elementDescriptor.ExpectedChildren || {}
    },
    props
  };
}

// node_modules/devextreme-react/esm/core/const.js
var UNITLESS_NUMBERS_SET = /* @__PURE__ */ new Set([
  "animationIterationCount",
  "aspectRatio",
  "borderImageOutset",
  "borderImageSlice",
  "borderImageWidth",
  "boxFlex",
  "boxFlexGroup",
  "boxOrdinalGroup",
  "columnCount",
  "columns",
  "flex",
  "flexGrow",
  "flexPositive",
  "flexShrink",
  "flexNegative",
  "flexOrder",
  "gridArea",
  "gridRow",
  "gridRowEnd",
  "gridRowSpan",
  "gridRowStart",
  "gridColumn",
  "gridColumnEnd",
  "gridColumnSpan",
  "gridColumnStart",
  "fontWeight",
  "lineClamp",
  "lineHeight",
  "opacity",
  "order",
  "orphans",
  "scale",
  "tabSize",
  "widows",
  "zIndex",
  "zoom",
  "fillOpacity",
  "floodOpacity",
  "stopOpacity",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "MozAnimationIterationCount",
  "MozBoxFlex",
  "MozBoxFlexGroup",
  "MozLineClamp",
  "msAnimationIterationCount",
  "msFlex",
  "msZoom",
  "msFlexGrow",
  "msFlexNegative",
  "msFlexOrder",
  "msFlexPositive",
  "msFlexShrink",
  "msGridColumn",
  "msGridColumnSpan",
  "msGridRow",
  "msGridRowSpan",
  "WebkitAnimationIterationCount",
  "WebkitBoxFlex",
  "WebKitBoxFlexGroup",
  "WebkitBoxOrdinalGroup",
  "WebkitColumnCount",
  "WebkitColumns",
  "WebkitFlex",
  "WebkitFlexGrow",
  "WebkitFlexPositive",
  "WebkitFlexShrink",
  "WebkitLineClamp"
]);

// node_modules/devextreme-react/esm/core/component-base.js
var DX_REMOVE_EVENT = "dxremove";
config_default2({
  buyNowLink: "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeReact.aspx",
  licensingDocLink: "https://go.devexpress.com/Licensing_Documentation_DevExtremeReact.aspx"
});
var ComponentBase = (0, import_react6.forwardRef)((props, ref) => {
  const { templateProps = [], defaults = {}, expectedChildren = {}, isPortalComponent = false, useRequestAnimationFrameFlag = false, subscribableOptions = [], WidgetClass, independentEvents = [], renderChildren, beforeCreateWidget = () => void 0, afterCreateWidget = () => void 0 } = props;
  const [, setForceUpdateToken] = (0, import_react6.useState)(Symbol("initial force update token"));
  const removalLocker = (0, import_react6.useContext)(RemovalLockerContext);
  const restoreParentLink = (0, import_react6.useContext)(RestoreTreeContext);
  const instance = (0, import_react6.useRef)();
  const element = (0, import_react6.useRef)();
  const portalContainer = (0, import_react6.useRef)();
  const useDeferUpdateForTemplates = (0, import_react6.useRef)(false);
  const guardsUpdateScheduled = (0, import_react6.useRef)(false);
  const childElementsDetached = (0, import_react6.useRef)(false);
  const shouldRestoreFocus = (0, import_react6.useRef)(false);
  const optionsManager = (0, import_react6.useRef)(new OptionsManager());
  const childNodes = (0, import_react6.useRef)();
  const createDXTemplates = (0, import_react6.useRef)();
  const clearInstantiationModels = (0, import_react6.useRef)();
  const updateTemplates = (0, import_react6.useRef)();
  const prevPropsRef = (0, import_react6.useRef)();
  const childrenContainerRef = (0, import_react6.useRef)(null);
  const { parentType } = (0, import_react6.useContext)(NestedOptionContext);
  const [widgetConfig, context2] = useOptionScanning({
    type: ElementType.Option,
    descriptor: {
      name: "",
      isCollection: false,
      templates: templateProps,
      initialValuesProps: defaults,
      predefinedValuesProps: {},
      expectedChildren
    },
    props
  }, () => !!childrenContainerRef.current?.childNodes.length, Symbol("initial update token"), "component");
  const restoreTree = (0, import_react6.useCallback)(() => {
    if (childElementsDetached.current && childNodes.current?.length && element.current) {
      element.current.append(...childNodes.current);
      childElementsDetached.current = false;
    }
    if (restoreParentLink && element.current && !element.current.isConnected) {
      restoreParentLink();
    }
  }, [
    childNodes.current,
    element.current,
    childElementsDetached.current,
    restoreParentLink
  ]);
  const updateCssClasses = (0, import_react6.useCallback)((prevProps, newProps) => {
    const prevClassName = prevProps ? getClassName(prevProps) : void 0;
    const newClassName = getClassName(newProps);
    if (prevClassName === newClassName) {
      return;
    }
    if (prevClassName) {
      const classNames = prevClassName.split(" ").filter((c) => c);
      if (classNames.length) {
        element.current?.classList.remove(...classNames);
      }
    }
    if (newClassName) {
      const classNames = newClassName.split(" ").filter((c) => c);
      if (classNames.length) {
        element.current?.classList.add(...classNames);
      }
    }
  }, [element.current]);
  const setInlineStyles = (0, import_react6.useCallback)((styles) => {
    if (element.current) {
      const el = element.current;
      Object.entries(styles).forEach(([name2, value2]) => {
        if (typeof value2 === "number" && !UNITLESS_NUMBERS_SET.has(name2)) {
          el.style[name2] = `${value2}px`;
        } else {
          el.style[name2] = value2;
        }
      });
    }
  }, [element.current]);
  const setTemplateManagerHooks = (0, import_react6.useCallback)(({ createDXTemplates: createDXTemplatesFn, clearInstantiationModels: clearInstantiationModelsFn, updateTemplates: updateTemplatesFn }) => {
    createDXTemplates.current = createDXTemplatesFn;
    clearInstantiationModels.current = clearInstantiationModelsFn;
    updateTemplates.current = updateTemplatesFn;
  }, [
    createDXTemplates.current,
    clearInstantiationModels.current,
    updateTemplates.current
  ]);
  const getElementProps = (0, import_react6.useCallback)(() => {
    const elementProps = {
      ref: (el) => {
        if (el) {
          element.current = el;
        }
      }
    };
    elementPropNames.forEach((name2) => {
      if (name2 in props) {
        elementProps[name2] = props[name2];
      }
    });
    return elementProps;
  }, [element.current, props]);
  const scheduleTemplatesUpdate = (0, import_react6.useCallback)(() => {
    if (guardsUpdateScheduled.current) {
      return;
    }
    guardsUpdateScheduled.current = true;
    const updateFunc = useDeferUpdateForTemplates.current ? deferUpdate : requestAnimationFrame;
    updateFunc(() => {
      guardsUpdateScheduled.current = false;
      updateTemplates.current?.(() => scheduleGuards());
    });
    unscheduleGuards();
  }, [
    guardsUpdateScheduled.current,
    useDeferUpdateForTemplates.current,
    updateTemplates.current
  ]);
  const createWidget = (0, import_react6.useCallback)((el) => {
    beforeCreateWidget();
    el = el || element.current;
    let options2 = {
      templatesRenderAsynchronously: true,
      ...optionsManager.current.getInitialOptions(widgetConfig)
    };
    const templateOptions = optionsManager.current.getTemplateOptions(widgetConfig);
    const dxTemplates = createDXTemplates.current?.(templateOptions);
    if (dxTemplates && Object.keys(dxTemplates).length) {
      options2 = {
        ...options2,
        integrationOptions: {
          templates: dxTemplates
        }
      };
    }
    clearInstantiationModels.current?.();
    instance.current = new WidgetClass(el, options2);
    if (!useRequestAnimationFrameFlag) {
      useDeferUpdateForTemplates.current = instance.current.option("integrationOptions.useDeferUpdateForTemplates");
    }
    optionsManager.current.setInstance(instance.current, widgetConfig, subscribableOptions, independentEvents);
    instance.current.on("optionChanged", optionsManager.current.onOptionChanged);
    afterCreateWidget();
  }, [
    beforeCreateWidget,
    afterCreateWidget,
    element.current,
    optionsManager.current,
    createDXTemplates.current,
    clearInstantiationModels.current,
    WidgetClass,
    useRequestAnimationFrameFlag,
    useDeferUpdateForTemplates.current,
    instance.current,
    subscribableOptions,
    independentEvents,
    widgetConfig
  ]);
  const onTemplatesRendered = (0, import_react6.useCallback)(() => {
    if (shouldRestoreFocus.current && instance.current?.focus) {
      instance.current.focus();
      shouldRestoreFocus.current = false;
    }
  }, [shouldRestoreFocus.current, instance.current]);
  const onComponentUpdated = (0, import_react6.useCallback)(() => {
    if (parentType === "option") {
      return;
    }
    if (!optionsManager.current?.isInstanceSet) {
      return;
    }
    updateCssClasses(prevPropsRef.current, props);
    const templateOptions = optionsManager.current.getTemplateOptions(widgetConfig);
    const dxTemplates = createDXTemplates.current?.(templateOptions) || {};
    optionsManager.current.update(widgetConfig, dxTemplates);
    scheduleTemplatesUpdate();
    prevPropsRef.current = props;
  }, [
    optionsManager.current,
    prevPropsRef.current,
    createDXTemplates.current,
    scheduleTemplatesUpdate,
    updateCssClasses,
    props,
    widgetConfig
  ]);
  const onComponentMounted = (0, import_react6.useCallback)(() => {
    if (parentType === "option") {
      return;
    }
    const { style } = props;
    if (childElementsDetached.current) {
      restoreTree();
    } else if (element.current?.childNodes.length) {
      childNodes.current = Array.from(element.current?.childNodes);
    }
    updateCssClasses(void 0, props);
    if (style) {
      setInlineStyles(style);
    }
    prevPropsRef.current = props;
  }, [
    childNodes.current,
    element.current,
    childElementsDetached.current,
    updateCssClasses,
    setInlineStyles,
    props
  ]);
  const onComponentUnmounted = (0, import_react6.useCallback)(() => {
    removalLocker?.lock();
    if (instance.current) {
      const dxRemoveArgs = { isUnmounting: true };
      shouldRestoreFocus.current = !!element.current?.contains(document.activeElement);
      childNodes.current?.forEach((child) => child.parentNode?.removeChild(child));
      childElementsDetached.current = true;
      if (element.current) {
        const preventFocusOut = (e) => e.stopPropagation();
        on(element.current, "focusout", preventFocusOut);
        triggerHandler(element.current, DX_REMOVE_EVENT, dxRemoveArgs);
        off(element.current, "focusout", preventFocusOut);
      }
      instance.current.dispose();
      instance.current = null;
    }
    optionsManager.current.dispose();
    removalLocker?.unlock();
  }, [
    removalLocker,
    instance.current,
    childNodes.current,
    element.current,
    optionsManager.current,
    childElementsDetached.current,
    shouldRestoreFocus.current
  ]);
  (0, import_react6.useLayoutEffect)(() => {
    onComponentMounted();
    return () => {
      onComponentUnmounted();
    };
  }, []);
  (0, import_react6.useLayoutEffect)(() => {
    onComponentUpdated();
  });
  (0, import_react6.useImperativeHandle)(ref, () => ({
    getInstance() {
      return instance.current;
    },
    getElement() {
      return element.current;
    },
    createWidget(el) {
      createWidget(el);
    }
  }), [instance.current, element.current, createWidget]);
  const _renderChildren = (0, import_react6.useCallback)(() => {
    if (renderChildren) {
      return renderChildren();
    }
    const { children } = props;
    return children;
  }, [props, renderChildren]);
  const renderPortal = (0, import_react6.useCallback)(() => portalContainer.current && (0, import_react_dom2.createPortal)(_renderChildren(), portalContainer.current), [portalContainer.current, _renderChildren]);
  const renderContent = (0, import_react6.useCallback)(() => {
    const { children } = props;
    return isPortalComponent && children ? React4.createElement("div", {
      ref: (node) => {
        if (node && portalContainer.current !== node) {
          portalContainer.current = node;
          setForceUpdateToken(Symbol("force update token"));
        }
      },
      style: { display: "contents" }
    }) : _renderChildren();
  }, [
    props,
    isPortalComponent,
    portalContainer.current,
    _renderChildren
  ]);
  const renderContextValue2 = (0, import_react6.useMemo)(() => ({
    isTemplateRendering: false
  }), []);
  return React4.createElement(
    RestoreTreeContext.Provider,
    { value: restoreTree },
    React4.createElement(
      TemplateRenderingContext.Provider,
      { value: renderContextValue2 },
      React4.createElement(
        "div",
        { ref: childrenContainerRef, ...getElementProps() },
        React4.createElement(NestedOptionContext.Provider, { value: context2 }, renderContent()),
        React4.createElement(TemplateManager2, { init: setTemplateManagerHooks, onTemplatesRendered }),
        isPortalComponent && React4.createElement(NestedOptionContext.Provider, { value: context2 }, renderPortal())
      )
    )
  );
});

// node_modules/devextreme-react/esm/core/extension-component.js
var React5 = __toESM(require_react());
var import_react7 = __toESM(require_react());
function elementIsExtension(el) {
  return el.type?.componentType === "extension";
}
var ExtensionComponent = (0, import_react7.forwardRef)((props, ref) => {
  const componentBaseRef = (0, import_react7.useRef)(null);
  const createWidget = (0, import_react7.useCallback)((el) => {
    componentBaseRef.current?.createWidget(el);
  }, [componentBaseRef.current]);
  (0, import_react7.useLayoutEffect)(() => {
    const { onMounted } = props;
    if (onMounted) {
      onMounted(createWidget);
    } else {
      createWidget();
    }
  }, []);
  (0, import_react7.useImperativeHandle)(ref, () => ({
    getInstance() {
      return componentBaseRef.current?.getInstance();
    },
    getElement() {
      return componentBaseRef.current?.getElement();
    },
    createWidget(el) {
      createWidget(el);
    }
  }), [componentBaseRef.current, createWidget]);
  return React5.createElement(ComponentBase, { ref: componentBaseRef, ...props });
});

// node_modules/devextreme-react/esm/core/component.js
var Component3 = (0, import_react8.forwardRef)((props, ref) => {
  const componentBaseRef = (0, import_react8.useRef)(null);
  const extensionCreators = (0, import_react8.useRef)([]);
  const registerExtension = (0, import_react8.useCallback)((creator) => {
    extensionCreators.current.push(creator);
  }, [extensionCreators.current]);
  const createExtensions = (0, import_react8.useCallback)(() => {
    extensionCreators.current.forEach((creator) => creator(componentBaseRef.current?.getElement()));
  }, [extensionCreators.current, componentBaseRef.current]);
  const renderChildren = (0, import_react8.useCallback)(() => React6.Children.map(props.children, (child) => {
    if (React6.isValidElement(child) && elementIsExtension(child)) {
      return React6.cloneElement(child, { onMounted: registerExtension });
    }
    return child;
  }), [props, registerExtension]);
  const createWidget = (0, import_react8.useCallback)((el) => {
    componentBaseRef.current?.createWidget(el);
  }, [componentBaseRef.current]);
  const clearExtensions = (0, import_react8.useCallback)(() => {
    if (props.clearExtensions) {
      props.clearExtensions();
    }
    extensionCreators.current = [];
  }, [
    extensionCreators.current,
    props.clearExtensions
  ]);
  (0, import_react8.useLayoutEffect)(() => {
    createWidget();
    createExtensions();
    return () => {
      clearExtensions();
    };
  }, []);
  (0, import_react8.useImperativeHandle)(ref, () => ({
    getInstance() {
      return componentBaseRef.current?.getInstance();
    },
    getElement() {
      return componentBaseRef.current?.getElement();
    },
    createWidget(el) {
      createWidget(el);
    },
    clearExtensions() {
      clearExtensions();
    }
  }), [componentBaseRef.current, createWidget, clearExtensions]);
  return React6.createElement(ComponentBase, { ref: componentBaseRef, renderChildren, ...props });
});

// node_modules/devextreme-react/esm/core/nested-option.js
var React7 = __toESM(require_react());
var import_react9 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());
var NestedOption = function NestedOption2(props) {
  const { children } = props;
  const { elementDescriptor, ...restProps } = props;
  const { isTemplateRendering } = (0, import_react9.useContext)(TemplateRenderingContext);
  if (!elementDescriptor || typeof document === "undefined" || isTemplateRendering) {
    return null;
  }
  const usesNamedTemplate = elementDescriptor.TemplateProps?.some((prop) => props[prop.tmplOption] && typeof props[prop.tmplOption] === "string");
  const { parentExpectedChildren, onChildOptionsReady: triggerParentOptionsReady, getOptionComponentKey, treeUpdateToken } = (0, import_react9.useContext)(NestedOptionContext);
  const [optionComponentKey] = (0, import_react9.useState)(getOptionComponentKey());
  const optionElement = getOptionInfo(elementDescriptor, restProps, parentExpectedChildren);
  const mainContainer = (0, import_react9.useMemo)(() => document.createElement("div"), []);
  const renderChildren = hasExpectedChildren(elementDescriptor) || usesNamedTemplate;
  const getHasTemplate = renderChildren ? () => !!mainContainer.childNodes.length : () => !!children;
  const [config3, context2] = useOptionScanning(optionElement, getHasTemplate, treeUpdateToken, "option");
  (0, import_react9.useLayoutEffect)(() => {
    triggerParentOptionsReady(config3, optionElement.descriptor, treeUpdateToken, optionComponentKey);
  }, [treeUpdateToken]);
  return renderChildren ? React7.createElement(React7.Fragment, {}, (0, import_react_dom3.createPortal)(React7.createElement(NestedOptionContext.Provider, {
    value: context2
  }, children), mainContainer)) : null;
};
var nested_option_default = NestedOption;

// node_modules/devextreme-react/esm/tooltip.js
var Tooltip2 = (0, import_react10.memo)((0, import_react10.forwardRef)((props, ref) => {
  const baseRef = (0, import_react10.useRef)(null);
  (0, import_react10.useImperativeHandle)(ref, () => ({
    instance() {
      return baseRef.current?.getInstance();
    }
  }), [baseRef.current]);
  const subscribableOptions = (0, import_react10.useMemo)(() => ["height", "position", "visible", "width"], []);
  const independentEvents = (0, import_react10.useMemo)(() => ["onContentReady", "onDisposing", "onHidden", "onHiding", "onInitialized", "onShowing", "onShown"], []);
  const defaults = (0, import_react10.useMemo)(() => ({
    defaultHeight: "height",
    defaultPosition: "position",
    defaultVisible: "visible",
    defaultWidth: "width"
  }), []);
  const expectedChildren = (0, import_react10.useMemo)(() => ({
    animation: { optionName: "animation", isCollectionItem: false },
    hideEvent: { optionName: "hideEvent", isCollectionItem: false },
    position: { optionName: "position", isCollectionItem: false },
    showEvent: { optionName: "showEvent", isCollectionItem: false }
  }), []);
  const templateProps = (0, import_react10.useMemo)(() => [
    {
      tmplOption: "contentTemplate",
      render: "contentRender",
      component: "contentComponent"
    }
  ], []);
  return React8.createElement(Component3, {
    WidgetClass: tooltip_default,
    ref: baseRef,
    isPortalComponent: true,
    subscribableOptions,
    independentEvents,
    defaults,
    expectedChildren,
    templateProps,
    ...props
  });
}));
var _componentAnimation = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "animation",
      ExpectedChildren: {
        hide: { optionName: "hide", isCollectionItem: false },
        show: { optionName: "show", isCollectionItem: false }
      }
    }
  });
};
var Animation = Object.assign(_componentAnimation, {
  componentType: "option"
});
var _componentAt = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "at"
    }
  });
};
var At = Object.assign(_componentAt, {
  componentType: "option"
});
var _componentBoundaryOffset = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "boundaryOffset"
    }
  });
};
var BoundaryOffset = Object.assign(_componentBoundaryOffset, {
  componentType: "option"
});
var _componentCollision = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "collision"
    }
  });
};
var Collision = Object.assign(_componentCollision, {
  componentType: "option"
});
var _componentFrom = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "from",
      ExpectedChildren: {
        position: { optionName: "position", isCollectionItem: false }
      }
    }
  });
};
var From = Object.assign(_componentFrom, {
  componentType: "option"
});
var _componentHide = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "hide",
      ExpectedChildren: {
        from: { optionName: "from", isCollectionItem: false },
        to: { optionName: "to", isCollectionItem: false }
      }
    }
  });
};
var Hide = Object.assign(_componentHide, {
  componentType: "option"
});
var _componentHideEvent = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "hideEvent"
    }
  });
};
var HideEvent = Object.assign(_componentHideEvent, {
  componentType: "option"
});
var _componentMy = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "my"
    }
  });
};
var My = Object.assign(_componentMy, {
  componentType: "option"
});
var _componentOffset = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "offset"
    }
  });
};
var Offset = Object.assign(_componentOffset, {
  componentType: "option"
});
var _componentPosition = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "position",
      ExpectedChildren: {
        at: { optionName: "at", isCollectionItem: false },
        boundaryOffset: { optionName: "boundaryOffset", isCollectionItem: false },
        collision: { optionName: "collision", isCollectionItem: false },
        my: { optionName: "my", isCollectionItem: false },
        offset: { optionName: "offset", isCollectionItem: false }
      }
    }
  });
};
var Position = Object.assign(_componentPosition, {
  componentType: "option"
});
var _componentShow = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "show",
      ExpectedChildren: {
        from: { optionName: "from", isCollectionItem: false },
        to: { optionName: "to", isCollectionItem: false }
      }
    }
  });
};
var Show = Object.assign(_componentShow, {
  componentType: "option"
});
var _componentShowEvent = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "showEvent"
    }
  });
};
var ShowEvent = Object.assign(_componentShowEvent, {
  componentType: "option"
});
var _componentTo = (props) => {
  return React8.createElement(nested_option_default, {
    ...props,
    elementDescriptor: {
      OptionName: "to",
      ExpectedChildren: {
        position: { optionName: "position", isCollectionItem: false }
      }
    }
  });
};
var To = Object.assign(_componentTo, {
  componentType: "option"
});
var tooltip_default2 = Tooltip2;
export {
  Animation,
  At,
  BoundaryOffset,
  Collision,
  From,
  Hide,
  HideEvent,
  My,
  Offset,
  Position,
  Show,
  ShowEvent,
  To,
  Tooltip2 as Tooltip,
  tooltip_default2 as default
};
/*! Bundled license information:

devextreme-react/esm/core/configuration/utils.js:
devextreme-react/esm/core/widget-config.js:
devextreme-react/esm/core/configuration/react/templates.js:
devextreme-react/esm/core/contexts.js:
devextreme-react/esm/core/configuration/config-node.js:
devextreme-react/esm/core/use-option-scanning.js:
devextreme-react/esm/core/configuration/tree.js:
devextreme-react/esm/core/configuration/comparer.js:
devextreme-react/esm/core/helpers.js:
devextreme-react/esm/core/options-manager.js:
devextreme-react/esm/core/template-wrapper.js:
devextreme-react/esm/core/config.js:
devextreme-react/esm/core/template-manager.js:
devextreme-react/esm/core/template.js:
devextreme-react/esm/core/configuration/react/element.js:
devextreme-react/esm/core/const.js:
devextreme-react/esm/core/component-base.js:
devextreme-react/esm/core/extension-component.js:
devextreme-react/esm/core/component.js:
devextreme-react/esm/core/nested-option.js:
devextreme-react/esm/tooltip.js:
  (*!
   * devextreme-react
   * Version: 25.1.3
   * Build date: Wed Jun 25 2025
   *
   * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-react
   *)
*/
//# sourceMappingURL=devextreme-react_tooltip.js.map
